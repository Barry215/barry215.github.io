<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>麦金</title>
  
  <subtitle>麦金的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://barry215.github.io/"/>
  <updated>2018-04-30T09:58:00.000Z</updated>
  <id>https://barry215.github.io/</id>
  
  <author>
    <name>frank</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机组成原理基础知识</title>
    <link href="https://barry215.github.io/2018/02/06/computer-foundation/"/>
    <id>https://barry215.github.io/2018/02/06/computer-foundation/</id>
    <published>2018-02-06T05:34:06.000Z</published>
    <updated>2018-04-30T09:58:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://pic4.zhimg.com/8bf6ef80ddbcd9ed5984fe9a51bb5b78_r.jpg" alt></p><h4 id="计算机之父"><a href="#计算机之父" class="headerlink" title="计算机之父"></a>计算机之父</h4><p>冯诺依曼   计算机由CPU处理器、运算器、存储器（ RAM， ROM等 ）输入设备、输出设备五部分组成</p><p>图灵提出了计算机的理论模型和图灵机概念</p><h4 id="逻辑地址和物理地址"><a href="#逻辑地址和物理地址" class="headerlink" title="逻辑地址和物理地址"></a>逻辑地址和物理地址</h4><p>为了解决使用物理地址不连续的问题，逻辑地址可以连续，而且映射到物理地址时，是不连续的。</p><p>需要页表来储存逻辑页和物理页的对应号关系，页表是页码，储存在内存，而段表储存在内存或寄存器</p><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><ol><li>为了让CPU的利用率提高，就需要增加更多的进程给CPU，但是进程需要内存空间，所以会导致内存不够，需要利用磁盘等空间，虚拟化内存，利用某种算法，把暂时不用的信息放在磁盘，有可能会用到的信息放内存中。这样在某进程处理IO操作时，CPU可以即时切换到另一个进程。</li><li>如果计算机内存不够，则需要利用虚拟内存在逻辑上进行容量扩展。而实际上，它通常被分割成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换，即磁盘转内存。</li><li>虚拟地址可以保证每个进程的地址独立，并且可以保证连续性，映射到物理内存就可以不连续，可以被分成很细小的一页一页</li></ol><h4 id="页和段的区别"><a href="#页和段的区别" class="headerlink" title="页和段的区别"></a>页和段的区别</h4><p>页是信息的物理单位，是出于系统内存利用率的角度提出的离散分配机制；段是信息的逻辑单位，每个段含有一组意义完整的信息，是出于用户角度提出的内存管理机制。</p><p>页的大小是固定的，由系统决定；段的大小是不确定的，由用户决定</p><p>页地址空间是一维的，段地址空间是二维的。</p><p>因为页表也是在内存中，需要很占空间，所以产生了两级页表，这样可以在需要的时候再分配页表空间。</p><h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><p>进程有就绪、执行、阻塞3种状态</p><h4 id="SRAM和DRAM区别"><a href="#SRAM和DRAM区别" class="headerlink" title="SRAM和DRAM区别"></a>SRAM和DRAM区别</h4><blockquote><p>SRAM是英文Static RAM的缩写，它是一种具有静志存取功能的内存，不需要刷新电路即能保存它内部存储的数据。不像DRAM内存那样需要刷新电路，每隔一段时间，固定要对DRAM刷新充电一次，否则内部的数据即会消失，因此SRAM具有较高的性能，但是SRAM也有它的缺点，即它的集成度较低，相同容量的DRAM内存可以设计为较小的体积，但是SRAM却需要很大的体积，所以在主板上SRAM存储器要占用一部分面积。</p></blockquote><p>DRAM，动态随机存取存储器，需要不断的刷新，才能保存数据。而且是行列地址复用的，许多都有页模式。<br>SRAM，静态的随机存取存储器，加电情况下，不需要刷新，数据不会丢失，而且，一般不是行列地址复用的。<br>SDRAM，同步的DRAM，即数据的读写需要时钟来同步。</p><p>SRAM用作于置于CPU与主存间的高速缓存(cache)。<br>DRAM用作于内存。</p><h4 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h4><p>高速缓存(Cache)是位于CPU与主内存间的一种容量较小但速度很高的存储器。由于CPU的速度远高于主内存，CPU直接从内存中存取数据要等待一定时间周期，Cache中保存着CPU刚用过或循环使用的一部分数据，即也就是用于暂时存放内存中的数据，若果寄存器要取内存中的一部分数据时，可直接从缓存中取到，这样可以调高速度。高速缓存是内存的部分拷贝。Cache又分为一级Cache(L1 Cache)和二级Cache(L2 Cache)。</p><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p>寄存器(Register)是中央处理器(CPU)内的组成部份，拥有非常高的读写速度。寄存器是有限存贮容量的高速存贮部件，它们可用来暂存<strong>指令、数据和位址</strong>。在中央处理器的控制部件中，包含的寄存器有指令寄存器(IR)和程序计数器(PC)。在中央处理器的算术及逻辑部件中，包含的寄存器有累加器(ACC)。</p><p>寄存器的工作方式很简单，只有两步：（1）找到相关的位，（2）读取这些位。</p><p>总体来说：CPU  <---> 寄存器<---> 缓存<--->内存</---></---></---></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://pic4.zhimg.com/8bf6ef80ddbcd9ed5984fe9a51bb5b78_r.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h4 id=&quot;计算机之父&quot;&gt;&lt;a href=&quot;#计算机之父&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="Computer" scheme="https://barry215.github.io/categories/Computer/"/>
    
    
      <category term="computer" scheme="https://barry215.github.io/tags/computer/"/>
    
  </entry>
  
  <entry>
    <title>Socket和Websocket的关系</title>
    <link href="https://barry215.github.io/2017/07/16/http-socket/"/>
    <id>https://barry215.github.io/2017/07/16/http-socket/</id>
    <published>2017-07-16T12:23:28.000Z</published>
    <updated>2017-07-16T14:16:32.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前一直被误导的同学注意了，它们的关系就像Java和JavaScript根本没有sm关系</p></blockquote><p><img src="http-socket/RelationShip.png" alt></p><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><blockquote><p>Socket其实并不是一个协议，它是对传输层 TCP/IP 协议的抽象层，它是一组接口，提供一套调用TCP/IP协议的API</p></blockquote><p>如果你要使用HTTP来构建服务，那么就不需要关心Socket，如果你想基于TCP/IP来构建服务，那么就要使用Socket的API了</p><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><blockquote><p>WebSocket是HTML5中的协议，支持页面使用WebSocket协议与远程主机进行全双工的通信。</p></blockquote><p>WebSocket和Http一样，都是应用层协议，只是WebSocket是通过在客户端与服务器之间HTTP协议的初始握手阶段将其升级到WebSocket协议来建立的，不过其底层仍是TCP连接。</p><h4 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h4><p>websocket 建立连接先通过 Http 协议与服务器进行握手，服务器解析相应的 Http 协议，确认出本次连接是 Http 还是 websocket连接，如果是 websocket 连接，则双端直接进入 TCP/IP 常规的三次握手阶段，建立TCP连接，进行双向数据通信。</p><h4 id="WebSocket好处"><a href="#WebSocket好处" class="headerlink" title="WebSocket好处"></a>WebSocket好处</h4><ul><li>Http协议的单向行导致服务器只能被动的返回信息，WebSocket协议可以让服务器主动返回信息。</li><li>传统的轮询方式（即采用Http协议不断发送请求）有很多缺点，比如<strong>浪费流量</strong>（Http请求头比较大）、<strong>浪费资源</strong>（没有更新也要请求）、<strong>消耗服务器CPU占用</strong>（没有信息也要接收请求）</li><li>http1.1之后，浏览器默认开启keep-alive connection ，虽然这样可以在一次 Http连接中可以发送多个Request，接收多个Response，但是对每个请求仍然要单独发 header；然而websocket是基于回调设计的，不是request和response的形式，用于协议控制的数据包头部相对较小。如果请求频繁的话，就极大的减少了不必要的网络流量与延迟。</li></ul><h3 id="常用名词总结"><a href="#常用名词总结" class="headerlink" title="常用名词总结"></a>常用名词总结</h3><ol><li><p><strong>轮询</strong>：客户端定时向服务器发送Ajax请求，服务器接到请求后马上返回响应信息并关闭连接。<br>优点：后端程序编写比较容易。<br>缺点：请求中有大半是无用，浪费带宽和服务器资源。<br>实例：适于小型应用。</p></li><li><p><strong>长轮询</strong>：客户端向服务器发送Ajax请求，服务器接到请求后hold住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。<br>优点：在无消息的情况下不会频繁的请求。<br>缺点：服务器hold连接会消耗资源。<br>实例：WebQQ、Hi网页版、Facebook IM。</p></li><li><p><strong>长连接</strong>：在页面里嵌入一个隐蔵iframe，将这个隐蔵iframe的src属性设为对一个长连接的请求，服务器端就能源源不断地往客户端输入数据。<br>优点：消息即时到达，不发无用请求。<br>缺点：服务器维护一个长连接会增加开销。<br>实例：Gmail聊天</p></li><li><p><strong>WebSocket</strong>：客户端发送一次http(websocket协议升级)请求，服务器响应请求，三次握手后，双方建立持久连接，并进行双向数据传输，后面不进行HTTP连接，而是使用TCP连接。</p><p>优点：<strong>双向通信</strong>，<strong>减小服务器开销</strong>，<strong>更强的实时性</strong>，<strong>保持连接状态</strong></p><p>缺点：一旦服务器故障，连接就会中断，过老浏览器不支持WebSocket</p><p>实例：网页游戏</p></li><li><p>Http的无状态短连接：每次请求结束后，TCP连接就关闭，相关的内容就释放了，记不住任何状态。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;之前一直被误导的同学注意了，它们的关系就像Java和JavaScript根本没有sm关系&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http-socket/RelationShip.png&quot; alt&gt;&lt;/p&gt;
&lt;h3 id=&quot;S
      
    
    </summary>
    
      <category term="Http" scheme="https://barry215.github.io/categories/Http/"/>
    
    
      <category term="http" scheme="https://barry215.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>算法练习(不断更新中)</title>
    <link href="https://barry215.github.io/2017/05/16/algorithmList/"/>
    <id>https://barry215.github.io/2017/05/16/algorithmList/</id>
    <published>2017-05-16T06:29:52.000Z</published>
    <updated>2018-02-27T12:30:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>求链表环的入口结点</p><blockquote><p>先用快慢指针判断是否为环，然后快慢指针相交的点就是在环内，然后让慢指针不动，快指针到起点改为每次一步，慢指针也每次一步，继续遍历，（更麻烦的方法：然后再走一圈环回到相交点，就是这个环的长度。有了环的长度，则让两个指针相隔这个长度，然后前进，一旦后一个指针进入环，这两个指针就一定会相遇。）相遇的这个点就是入口结点</p></blockquote><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>一个排好序的数组，找出两数之和为m的所有组合</p><blockquote><p>从数组两边进行推进，如果两数之和小就把前指针往后移，反之也如此，直到找到之后，就可以两边同时缩紧</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params"> array, m </span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> j = array.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> ret = [];</span><br><span class="line">  <span class="keyword">while</span>( i &lt;= j ) &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = array[i] + array[j];</span><br><span class="line">    <span class="keyword">if</span> ( sum &gt; m ) &#123;</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( sum &lt; m ) &#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      ret.push( [ i, j, array[i], array[j] ] );</span><br><span class="line">      i++;</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自然数序列，找出任意连续之和等于n的所有子序列</p><blockquote><p>从0开始累加，如果到一个点累加的值比n大，就把这个累加数组从最小开始循环移出元素，直至找到匹配</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">total_sum = <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_seq</span><span class="params">(lst)</span>:</span></span><br><span class="line">    seq = []</span><br><span class="line">    ct = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> lst:</span><br><span class="line">        seq.append(x)</span><br><span class="line">        ct += x</span><br><span class="line">        <span class="keyword">if</span> ct == total_sum:</span><br><span class="line">            <span class="keyword">print</span> seq</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> ct &lt; total_sum:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> ct &gt; total_sum:</span><br><span class="line">            seq_len = len(seq)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(seq_len):</span><br><span class="line">                tr = seq.pop(<span class="number">0</span>)</span><br><span class="line">                ct -= tr</span><br><span class="line">                <span class="keyword">if</span> ct &lt; total_sum:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> ct == total_sum:</span><br><span class="line">                    <span class="keyword">print</span> seq</span><br><span class="line"></span><br><span class="line">sum_seq(lst)</span><br></pre></td></tr></table></figure><p>判断数组内是否有重复元素</p><blockquote><p>总体思想都是利用额外的数据结构的方式减少时间复杂度，比如辅助数组和哈希表</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种</span></span><br><span class="line"><span class="comment">//利用js对象是字典类型的结构(或者Java的Map)，判断是否存在key就好了，时间复杂度为O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isRepeat</span>(<span class="params">arr</span>)</span>&#123;  </span><br><span class="line">     <span class="keyword">var</span> hash = &#123;&#125;;  </span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> arr) &#123;  </span><br><span class="line">         <span class="keyword">if</span>(hash[arr[i]])  </span><br><span class="line">              <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">         hash[arr[i]] = <span class="literal">true</span>;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="comment">//如果数组里都是数字，而且都在一个范围内，那么可以用辅助数组的下标形式判断</span></span><br><span class="line"><span class="comment">//代码略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种</span></span><br><span class="line"><span class="comment">//如果数组里不是数字，那么可以利用HashMap的思想，利用hashcode%数组长度为数组下标+相同hashcode加链表的方式判重</span></span><br><span class="line"><span class="comment">//代码略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第四种</span></span><br><span class="line"><span class="comment">//先排序，然后判断相邻是否为重复元素，时间复杂度为排序的复杂度</span></span><br><span class="line"><span class="keyword">var</span> ary = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"111"</span>,<span class="string">"22"</span>,<span class="string">"33"</span>,<span class="string">"111"</span>);  </span><br><span class="line"><span class="keyword">var</span> nary=ary.sort();   </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;ary.length;i++)&#123;    </span><br><span class="line"><span class="keyword">if</span> (nary[i]==nary[i+<span class="number">1</span>])&#123;  </span><br><span class="line">alert(<span class="string">"数组重复内容："</span>+nary[i]);</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>寻找从小到大的第1500个丑数（只包含2，3，5为因子的数是丑数，如4，6，8）</p><blockquote><p>利用空间换时间，保存1500个丑数就好了，关键是如果有序地生成丑数。</p><p>因为丑数肯定是丑数*(2,3,5)，我们可以根据已有丑数数组来算，把列表的丑数读乘2，比较是否大于数组里最大的丑数，然后选最小的那个大于数作为后一位丑数，如果都小于，则再试乘3，一次类推</p></blockquote><p>求连续子数组的的最大和，数组里面有正数也有负数。如{1,-2,3,10,-4,7,2,-5}中和最大的子数组是{3,10,-4,7,2}</p><blockquote><p>问题的原型好像就是找出一段和最大的数组。我们可以先从起点开始，保持一个最大数，一直累加，如果累加后一位的时候，发现是负数，则还是保持之前的最大数，如果累加得到的值比当前这个数还小，则累加起点变成这个点，然后最大数变成这个数的值。</p></blockquote><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>求二叉查找树中的两个结点的最低公共祖先</p><blockquote><p>从上往下进行遍历，如果结点的值比这两个结点都大或小，则进入他的左子树或右子树，然后如果碰到的结点大小刚好在两个结点的中间，则这个结点就是最低公共祖先。如果遇到刚好等于其中一个结点的值，那么这个结点就是最低公共祖先</p></blockquote><p>求普通二叉树的两个结点的最低公共祖先</p><blockquote><p>既然不是排序树，则判断是否有指向父节点的指针，如果有，可以转化为链表求第一个公共节点的问题；如果还是没有指向父节点的指针，用两个链表分别保存从根节点到输入的两个节点的路径，然后把问题转换成两个链表的最后公共节点</p></blockquote><p><img src="algorithmList/ordinaryTree.png" alt></p><p>我们首先得到一条从根结点到树中某一结点的路径，这就要求在遍历的时候，有一个辅助内存来保存路径．比如我们用前序遍历的方法来得到从根结点到H的路径的过程是这样的：（ 1 ）遍历到A，把A 存放到路径中去，路径中只有一个结点A; ( 2 ）遍历到B，把B 存到路径中去，此时路径为A-&gt;B; ( 3 ）遍历到D，把D 存放到路径中去，此，时路径为A-&gt;B-&gt;D; ( 4 ） ：遍历到F，把F 存放到路径中去，此时路径为A-&gt;B-&gt;D-&gt;F;( 5) F 已经没有子结点了，因此这条路径不可能到这结点H. 把F 从路径中删除，变成A-&gt;B-&gt;D; ( 6 ）遍历G. 和结点F 一样，这条路径也不能到达H. 边历完G 之后，路径仍然是A-&gt;B-&gt;D; ( 7 ）由于D 的所有子结点都遍历过了，不可能到这结点H，因此D 不在从A 到H 的路径中，把D 从路径中删除，变成A-&gt;B; ( 8 ）遥历E，把E 加入到路径中，此时路径变成A-&gt;B-&gt;E, ( 9 ）遍历H，已经到达目标给点， A-&gt;B-&gt;E 就是从根结点开始到达H 必须经过的路径。</p><p>从上到下打印二叉树</p><p><img src="algorithmList/printTree.png" alt></p><p>效果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">6 10</span><br><span class="line">5 7 9 11</span><br></pre></td></tr></table></figure><blockquote><p>利用栈的思想，压入从左到右，从上到下的结点，再保持两个变量，一个是下层要打印的节点数，一个是当前层要打印的结点数。比如顶点8，先压栈8，打印后，8出栈，此层打完了就打换行符，再压栈6和10。接着打印6，压栈5和7，6出栈，再打印10，压栈9和11，10出栈，最后打印5，7，9，11</p></blockquote><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>十进制转十六进制</p><blockquote><p>先算出他有几个16次方，然后每次都转换成一个十六进制符号</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toHex</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> divisor = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>[] table = <span class="string">"0123456789ABCDEF"</span>.toCharArray();</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">while</span> (divisor * base &lt;= num) &#123;</span><br><span class="line">        divisor *= base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; divisor &gt;= <span class="number">1</span>; divisor /= base) &#123;</span><br><span class="line">        result.append(table[num/divisor]);</span><br><span class="line">        num %= divisor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(toHex(<span class="number">1220</span>,<span class="number">16</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>十六进制转十进制</p><blockquote><p>从字符串的头开始算，然后每次都乘转换数，比如16，然后累加</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">stoi</span><span class="params">(String src, <span class="keyword">int</span> base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> digit, result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; src.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = src.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (c &gt;= <span class="string">'a'</span>) &#123;</span><br><span class="line">            digit = c - <span class="string">'a'</span> + <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">'A'</span>) &#123;</span><br><span class="line">            digit = c - <span class="string">'A'</span> + <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            digit = c - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result = base*result + digit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(stoi(<span class="string">"4C4"</span>,<span class="number">16</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>约瑟夫环问题：已知n个人（以编号1，2，3…n分别表示）围坐在一张圆桌周围。从编号为k的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人又出列；依此规律重复下去，直到圆桌周围的人全部出列，求出列人的顺序编号</p><blockquote><p>关键在于获取每次出列的人的index，其实index=startNum+countNum（开始的序号‘‘0~1’’+规定的长度-1），如果index大于列表总长了，就要用%取余，获取到index后，就remote它，接着开始的序号就变成刚刚remote的index了</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yue</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line"><span class="comment">//        Scanner scanner = new Scanner(System.in);  </span></span><br><span class="line"><span class="comment">//        System.out.print("请输入总人数：");  </span></span><br><span class="line"><span class="comment">//        int totalNum = scanner.nextInt();  </span></span><br><span class="line"><span class="comment">//        System.out.print("请输入报数的大小：");  </span></span><br><span class="line"><span class="comment">//        int cycleNum = scanner.nextInt();  </span></span><br><span class="line"><span class="comment">//        System.out.print("请输入开始编号：");  </span></span><br><span class="line"><span class="comment">//        int  startNO= scanner.nextInt();  </span></span><br><span class="line"><span class="comment">//        yuesefu(totalNum, cycleNum,startNO);  </span></span><br><span class="line">        yuesefu(<span class="number">5</span>, <span class="number">2</span>,<span class="number">3</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">yuesefu</span><span class="params">(<span class="keyword">int</span> totalNum, <span class="keyword">int</span> countNum,<span class="keyword">int</span> startNO)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 初始化人数  </span></span><br><span class="line">        List&lt;Integer&gt; start = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= totalNum; i++) &#123;  </span><br><span class="line">            start.add(i);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//从下标为K开始计数  </span></span><br><span class="line">        <span class="keyword">int</span> k = startNO-<span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">while</span> (start.size() &gt;<span class="number">0</span>) &#123;  </span><br><span class="line">            System.out.println(start);</span><br><span class="line">            <span class="comment">//第m人的索引位置</span></span><br><span class="line">            k = (k + countNum) % (start.size()) - <span class="number">1</span>;  </span><br><span class="line">           <span class="comment">// 判断是否到队尾  到队尾时候k=-1</span></span><br><span class="line">            <span class="keyword">if</span> (k &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">                System.out.println(start.get(start.size()-<span class="number">1</span>));  </span><br><span class="line">                start.remove(start.size() - <span class="number">1</span>);  </span><br><span class="line">                k = <span class="number">0</span>;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                System.out.println(start.get(k));  </span><br><span class="line">                start.remove(k);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考路径</p><p><a href="http://www.jianshu.com/p/8e794879dd29" target="_blank" rel="noopener">http://www.jianshu.com/p/8e794879dd29</a></p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>求找钱的所有方法数</p><p><img src="algorithmList/zhaoqian.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findNum</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span> || aim == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> process(arr, <span class="number">0</span>, aim);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过递归来切换arr的index，内部循环来进行枚举</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> aim)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (index == arr.length)&#123;</span><br><span class="line">        num = aim == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; arr[index] * i &lt;= aim; i++)&#123;</span><br><span class="line">            num += process(arr, index + <span class="number">1</span>, aim - arr[index]*i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">10</span>,<span class="number">25</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> aim = <span class="number">15</span>;</span><br><span class="line">    System.out.println(findNum(arr,aim));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汉诺塔</p><p>汉诺塔有3个柱子，求把n个叠在左侧的塔全移到右侧和搬运的次数，要求一次只能移一个塔，并且小的不能在大的下面</p><blockquote><p>通过递归的方式，寻找抽象的动作，每次都有一个起点，暂放点和重点，可以抽象地从搬多个可以递归到搬一个</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> move(n, <span class="string">"left"</span>, <span class="string">"right"</span>, <span class="string">"mid"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> n, String from, String to, String helper)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)&#123;</span><br><span class="line">        System.out.println(from + <span class="string">" move to "</span> + to);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    num += move(n-<span class="number">1</span>, from, helper, to);</span><br><span class="line">    System.out.println(from + <span class="string">" move to "</span> + to);</span><br><span class="line">    num ++;</span><br><span class="line">    num += move(n-<span class="number">1</span>, helper, to, from);</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(hanoi(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>深度优先遍历</p><p>假设在一个9 × 9的格子里，每一步可以往正上、正下、正左、正右、左上、左下、右上、右下八个方向走，但是空白区域不能走，走过的点不能再走。求能吃最多果实的路线。</p><p><img src="http://o7x0ygc3f.bkt.clouddn.com/%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98-9.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pos</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;  <span class="comment">// 横坐标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;  <span class="comment">// 纵坐标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// get、set、construct方法省略</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"Pos&#123;"</span>);</span><br><span class="line">        sb.append(<span class="string">"x="</span>).append(x);</span><br><span class="line">        sb.append(<span class="string">", y="</span>).append(y);</span><br><span class="line">        sb.append(<span class="string">'&#125;'</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Pos pos = (Pos) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x == pos.x &amp;&amp; y == pos.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = x;</span><br><span class="line">        result = <span class="number">31</span> * result + y;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sdbl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过深度优先搜索算法获取最长路径</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map        地图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start      起点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> moveOffset 移动偏移量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 最长路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Pos&gt; <span class="title">getLongestPathByDFS</span><span class="params">(<span class="keyword">int</span>[][] map, Pos start, Pos[] moveOffset)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Pos&gt; longestPath = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(start, map, <span class="keyword">new</span> ArrayList&lt;&gt;(), longestPath, moveOffset);</span><br><span class="line">        <span class="keyword">return</span> longestPath;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归实现深度优先搜索</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Pos pos, <span class="keyword">int</span>[][] map, List&lt;Pos&gt; oldPath, List&lt;Pos&gt; result, Pos[] moveOffset)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录当前位置向周围格子移动的记录</span></span><br><span class="line">        List&lt;Pos&gt; visited = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 依次向周围移动</span></span><br><span class="line">        <span class="keyword">for</span> (Pos aMoveOffset : moveOffset) &#123;</span><br><span class="line">            Pos next = <span class="keyword">new</span> Pos(pos.getX() + aMoveOffset.getX(), pos.getY() + aMoveOffset.getY());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (inMap(map, next) &amp;&amp; !oldPath.contains(next) &amp;&amp; map[next.getX()][next.getY()] == <span class="number">1</span>) &#123;</span><br><span class="line">                oldPath.add(next);</span><br><span class="line">                visited.add(next);</span><br><span class="line">                dfs(next, map, oldPath, result, moveOffset);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若在当前位置下，没有向周围的格子移动过时，保存最长路径</span></span><br><span class="line">        <span class="keyword">if</span> (visited.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldPath.size() &gt; result.size()) &#123;</span><br><span class="line">                result.clear();</span><br><span class="line">                result.addAll(oldPath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 周围的格子都不可以移动时回退到上一格子</span></span><br><span class="line"><span class="comment">//        for (Pos neighbour : neighbours) &#123;</span></span><br><span class="line"><span class="comment">//            if (canPath(map, oldPath, neighbour, visited)) &#123;</span></span><br><span class="line"><span class="comment">//                System.out.println("我到了 "+neighbour);</span></span><br><span class="line"><span class="comment">//                return;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        oldPath.remove(pos);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断格子是否可以移动</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canPath</span><span class="params">(<span class="keyword">int</span>[][] map, List&lt;Pos&gt; path, Pos pos, List&lt;Pos&gt; visited)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不在地图里，不能移动</span></span><br><span class="line">        <span class="keyword">if</span> (!inMap(map, pos)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 空白格子，不能移动</span></span><br><span class="line">        <span class="keyword">if</span> (map[pos.getY()][pos.getX()] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 已经在路径中或经过，不能移动</span></span><br><span class="line">        <span class="keyword">if</span> (path.contains(pos) || visited.contains(pos)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断格子是否在地图内</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">inMap</span><span class="params">(<span class="keyword">int</span>[][] map, Pos pos)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pos.getY() &lt; <span class="number">0</span> || pos.getY() &gt;= map.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pos.getX() &lt; <span class="number">0</span> || pos.getX() &gt;= map[<span class="number">0</span>].length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化参数</span></span><br><span class="line">        <span class="keyword">int</span>[][] simpleMap = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Pos[] moveOffset = <span class="keyword">new</span> Pos[]&#123;</span><br><span class="line">                <span class="keyword">new</span> Pos(-<span class="number">1</span>, <span class="number">0</span>),    <span class="comment">// 向左移动</span></span><br><span class="line">                <span class="keyword">new</span> Pos(-<span class="number">1</span>, -<span class="number">1</span>),    <span class="comment">// 向左上移动</span></span><br><span class="line">                <span class="keyword">new</span> Pos(<span class="number">0</span>, -<span class="number">1</span>),    <span class="comment">// 向上移动</span></span><br><span class="line">                <span class="keyword">new</span> Pos(<span class="number">1</span>, -<span class="number">1</span>),    <span class="comment">// 向右上移动</span></span><br><span class="line">                <span class="keyword">new</span> Pos(<span class="number">1</span>, <span class="number">0</span>),    <span class="comment">// 向右移动</span></span><br><span class="line">                <span class="keyword">new</span> Pos(<span class="number">1</span>, <span class="number">1</span>),    <span class="comment">// 向右下移动</span></span><br><span class="line">                <span class="keyword">new</span> Pos(<span class="number">0</span>, <span class="number">1</span>),    <span class="comment">// 向下移动</span></span><br><span class="line">                <span class="keyword">new</span> Pos(-<span class="number">1</span>, <span class="number">1</span>)     <span class="comment">// 向左下移动</span></span><br><span class="line">        &#125;;</span><br><span class="line">        Pos start = <span class="keyword">new</span> Pos(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行深度优先算法</span></span><br><span class="line">        List&lt;Pos&gt; longestPath = getLongestPathByDFS(simpleMap, start, moveOffset);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印路径</span></span><br><span class="line">        System.out.println(longestPath);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>你正在爬n层的楼梯，但每次你只能爬一步或者两步，你能有多少种不同的方法爬到楼顶部？</p><blockquote><p>已知爬1层和2层的方法数，在前面的基础上，可以知道爬3层的数方法数，同理4层只能是通过2层的基础+2步或3层的基础+1步来实现的，而前面已经知道2层和3层的方法数了，相加就好了，这个是动态规划的思想</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">climb</span>(<span class="params">floor</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(floor &lt; <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> plans = [];</span><br><span class="line"></span><br><span class="line">plans[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">plans[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> cur = <span class="number">3</span>; cur &lt;= floor; cur++)&#123;</span><br><span class="line">plans[cur] = plans[cur - <span class="number">1</span>] + plans[cur - <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> plans[floor];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>矩阵求从[0,0]路径[3,3]点的最小值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 5 4 8</span><br><span class="line">1 4 2 6</span><br><span class="line">9 2 5 7</span><br><span class="line">0 2 8 2</span><br></pre></td></tr></table></figure><blockquote><p>先求上面一行和左边一行的路径最小值</p><p>2 7 11 19<br>3<br>12<br>12</p><p>然后可以开始遍历剩余的点，左边和上边选一个最小值，再加上自己的值就是这个点的最小路径值，直到遍历到[3,3]点</p></blockquote><p><img src="algorithmList/juzheng1.png" alt></p><p>最长递增子序列（不连续）</p><blockquote><p>先从末尾分析，如果n位大于n-1位，则dp(n) = dp(n-1)+1，然后从0位开始积累dp数组</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lis</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxLength = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//例如dp[3]是前4位序列包含的最长递增子序列的值</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    <span class="comment">//第一个数，自己是自己的最长递增子序列，初始值为1</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">//不去考虑之前的值，的确初始值为1</span></span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="comment">//找出前面dp大于当前dp的位置 并且 要求之前序列的最后位的值小于当前值才符合条件</span></span><br><span class="line">            <span class="keyword">if</span> (dp[j] &gt;= dp[i] &amp;&amp; arr[j] &lt; arr[i]) &#123;</span><br><span class="line">                dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                System.out.println(<span class="string">"d["</span>+i+<span class="string">"] 找前面的值是:d["</span>+j+<span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">              <span class="comment">//if (arr[j] &lt; arr[i]) &#123;</span></span><br><span class="line">              <span class="comment">//  dp[i] = dp[j] + 1;</span></span><br><span class="line">              <span class="comment">//  System.out.println("d["+i+"] 找前面的值是:d["+j+"]");</span></span><br><span class="line">              <span class="comment">//  break;</span></span><br><span class="line">              <span class="comment">//&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] &gt; maxLength) &#123;</span><br><span class="line">            maxLength = dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最长公共子序列（不连续）</p><blockquote><p>从末尾分析，如果<code>X[i]==Y[j]</code>，则<code>c[i][j] = c[i-1][j-1]+1</code>;如果<code>X[i]!=Y[j]</code>，则<code>c[i][j] = Math.max(c[i][j-1],c[i-1][j])</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] lengthofLCS(<span class="keyword">char</span>[] X, <span class="keyword">char</span>[] Y)&#123;</span><br><span class="line">    <span class="comment">/* 构造二维数组c[][]记录X[i]和Y[j]的LCS长度 (i,j)是前缀</span></span><br><span class="line"><span class="comment">     * c[i][j]=0; 当 i = j = 0;</span></span><br><span class="line"><span class="comment">     * c[i][j]=c[i-1][j-1]+1; 当 i = j &gt; 0; Xi == Y[i]</span></span><br><span class="line"><span class="comment">     * c[i][j]=max(c[i-1][j],c[i][j+1]); 当 i = j &gt; 0; Xi </span></span><br><span class="line"><span class="comment">     * 需要计算 m*n 个子问题的长度 即 任意c[i][j]的长度</span></span><br><span class="line"><span class="comment">     * -- 填表过程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span>[][]c = <span class="keyword">new</span> <span class="keyword">int</span>[X.length+<span class="number">1</span>][Y.length+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 动态规划计算所有子问题</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=X.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=Y.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(X[i-<span class="number">1</span>]==Y[j-<span class="number">1</span>])&#123;</span><br><span class="line">                c[i][j] = c[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                c[i][j] = Math.max(c[i][j-<span class="number">1</span>],c[i-<span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印C数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=X.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=Y.length;j++)&#123;</span><br><span class="line">            System.out.print(c[i][j]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最长公共子串（连续）</p><blockquote><p>和上面的基本一样，但是如果<code>X[i]!=Y[j]</code>，则<code>c[i][j]</code>为0</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthofLCString</span><span class="params">(String X, String Y)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 构造二维数组c[][]记录X[i]和Y[j]的LCS长度 (i,j)是前缀</span></span><br><span class="line"><span class="comment">     * c[i][j]=0; 当 i = j = 0;</span></span><br><span class="line"><span class="comment">     * c[i][j]=c[i-1][j-1]+1; 当 i = j &gt; 0; Xi == Y[i]</span></span><br><span class="line"><span class="comment">     * c[i][j]=0; 当 i = j &gt; 0; Xi != Y[i]</span></span><br><span class="line"><span class="comment">     * 需要计算 m*n 个子问题的长度 即 任意c[i][j]的长度</span></span><br><span class="line"><span class="comment">     * -- 填表过程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span>[][]c = <span class="keyword">new</span> <span class="keyword">int</span>[X.length()+<span class="number">1</span>][Y.length()+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;=X.length();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=Y.length();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(X.charAt(i-<span class="number">1</span>) == Y.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                c[i][j] = c[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(c[i][j] &gt; maxlen)</span><br><span class="line">                &#123;</span><br><span class="line">                    maxlen = c[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxlen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="algorithmList/gongzu.png" alt></p><blockquote><p>设dp是走到这一步最少要有的血量，先算出最后一行的dp，然后在从下遍历到上一行，因为每一个点的dp是依赖于正下和右边的dp的，所以遍历结束，就知道了<code>dp[0][0]</code>需要多少的初始血量了</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minHP</span><span class="params">(<span class="keyword">int</span>[][] m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="keyword">null</span> || m.length == <span class="number">0</span> || m[<span class="number">0</span>] == <span class="keyword">null</span> || m[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> row = m.length;</span><br><span class="line">    <span class="keyword">int</span> col = m[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">    dp[row-<span class="number">1</span>][col-<span class="number">1</span>] = m[row-<span class="number">1</span>][col-<span class="number">1</span>] &gt; <span class="number">0</span> ? <span class="number">1</span> : -m[row-<span class="number">1</span>][col-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = col - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">        dp[row-<span class="number">1</span>][j] = Math.max(dp[row-<span class="number">1</span>][j+<span class="number">1</span>] - m[row-<span class="number">1</span>][j], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> down = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        dp[i][col-<span class="number">1</span>] = Math.max(dp[i+<span class="number">1</span>][col-<span class="number">1</span>] - m[i][col-<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = col - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            right = Math.max(dp[i][j+<span class="number">1</span>] - m[i][j], <span class="number">1</span>);</span><br><span class="line">            down = Math.max(dp[i+<span class="number">1</span>][j] - m[i][j], <span class="number">1</span>);</span><br><span class="line">            dp[i][j] = Math.min(right,down);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] m1 = &#123;-<span class="number">2</span>,-<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] m2 = &#123;-<span class="number">5</span>,-<span class="number">10</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] m3 = &#123;<span class="number">0</span>,<span class="number">30</span>,-<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[][] n = &#123;m1,m2,m3&#125;;</span><br><span class="line">    System.out.println(minHP(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><blockquote><p>尝试一下，如果失败则回退到之前的逻辑</p></blockquote><p>八皇后</p><p>在8*8的棋盘上要求放8个棋子，而且他们互不在同一行同一列同一斜线</p><blockquote><p>先放8个不同的行，然后遍历放列，每次遍历判断是否和之前的不在同一列同一斜线</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一共有多少个皇后（此时设置为8皇后在8X8棋盘，可以修改此值来设置N皇后问题）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> max = <span class="number">8</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该数组保存结果，第一个皇后摆在array[0]列，第二个摆在array[1]列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> WolfQueen().check(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * n代表当前是第几个皇后</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment"> * 皇后n在array[n]列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//终止条件是最后一行已经摆完，由于每摆一步都会校验是否有冲突，所以只要最后一行摆完，说明已经得到了一个正确解</span></span><br><span class="line">    <span class="keyword">if</span> (n == max) &#123;</span><br><span class="line">        print();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从第一列开始放值，然后判断是否和本行本列本斜线有冲突，如果OK，就进入下一行的逻辑</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">        array[n] = i;</span><br><span class="line">        <span class="keyword">if</span> (judge(n)) &#123;</span><br><span class="line">            check(n + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        System.out.print(array[i] + <span class="number">1</span> + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h3&gt;&lt;p&gt;求链表环的入口结点&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;先用快慢指针判断是否为环，然后快慢指针相交的点就是在环内，然后让慢指针不动，快指
      
    
    </summary>
    
      <category term="Algorithm" scheme="https://barry215.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="https://barry215.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Git命令篇</title>
    <link href="https://barry215.github.io/2017/05/06/git-learn/"/>
    <id>https://barry215.github.io/2017/05/06/git-learn/</id>
    <published>2017-05-06T07:18:24.000Z</published>
    <updated>2019-05-12T10:15:40.402Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>虽然公司里面用SVN，但是为了探索更好的团队协作方式，我觉得有必要再把Git弄懂一些。就像是石墨文档一样，提高团队协作效率才是第一生产力嘛。在这篇文章中，我尽可能地记录多数情况下会用到的命令和正确的协作方式</p></blockquote><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><p><img src="git-learn/git2.png" style="width: 700px;"></p><blockquote><p>本地的git本地结构由这三个部分组成，第一个是工作目录，第二个是暂存区，第三个本地仓库</p></blockquote><p>基本命令：</p><p>初始化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看git版本</span></span><br><span class="line">git version</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">创建</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">配置email</span></span><br><span class="line">git config --global user.email "you@example.com" </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">配置用户名</span></span><br><span class="line">git config --global user.name "Name" </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">取消某一配置项</span></span><br><span class="line">git config --unset user.name</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看配置列表</span></span><br><span class="line">git config --list</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看配置</span></span><br><span class="line">cat ~/.gitconfig</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">配置github密钥，生成id_rsa和id_rsa.pub</span></span><br><span class="line">ssh-keygen -t rsa -b 4096 -C "ynkonghao@gmail.com"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">测试ssh通道</span></span><br><span class="line">ssh -T git@github.com</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">全局设置git大小写敏感</span></span><br><span class="line">git config --global core.ignorecase false</span><br></pre></td></tr></table></figure><p>克隆：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">克隆本地仓库</span></span><br><span class="line">git clone /path/to/repository</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">克隆远端仓库</span></span><br><span class="line">git clone username@host:/path/to/repository</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">克隆远程某个分支</span></span><br><span class="line">git clone -b 远程分支 git地址</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">git clone .git地址</span><br><span class="line"></span><br><span class="line">git branch -a 先查看当前远端分支情况</span><br><span class="line"></span><br><span class="line">git checkout origin/xxx  选择远端xxx分支</span><br><span class="line"></span><br><span class="line">git branch xxx  创建本地xxx分支</span><br><span class="line"></span><br><span class="line">git checkout xxx  选择新创建的分支就可以了。</span><br></pre></td></tr></table></figure><p>添加：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">添加指定文件到暂存区</span></span><br><span class="line">git add &lt;filename&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">添加所有文件到暂存区</span></span><br><span class="line">git add *</span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">显示有变更的文件</span></span><br><span class="line">git status</span><br></pre></td></tr></table></figure><p>提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">提交文件到本地仓库</span></span><br><span class="line">git commit -m "代码提交信息"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">提交文件到本地仓库，只处理跟踪过的文件，未跟踪过的文件不会提交</span></span><br><span class="line">git commit -a -m "代码提交信息"</span><br></pre></td></tr></table></figure><p>删除：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">直接删除已commit的文件</span></span><br><span class="line">git rm [file]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">保留文件，但是删除跟踪</span></span><br><span class="line">git rm --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">强制把已add但是还未commit的删除</span></span><br><span class="line">gir rm -f [file]</span><br></pre></td></tr></table></figure><p>远程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">将你的仓库连接到某个远程服务器</span></span><br><span class="line">git remote add origin [server]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">显示所有远程仓库</span></span><br><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">显示某个远程仓库的信息</span></span><br><span class="line">git remote show [remote]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">增加一个新的远程仓库，并命名</span></span><br><span class="line">git remote add origin git地址</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">删除远程仓库</span></span><br><span class="line">git remote remove origin</span><br></pre></td></tr></table></figure><p>更新&amp;推送：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">更新远程仓库的所有变动</span></span><br><span class="line">git fetch [remote]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">取回远程仓库的变化，并与当前分支合并</span></span><br><span class="line">git pull [remote] [branch] = git fetch origin + git merge origin/branch</span><br><span class="line"><span class="meta">#</span><span class="bash">抓取最新版本到本地仓库+把工作区更新合并</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">取回origin主机的next分支，与本地的master分支合并</span></span><br><span class="line">git pull origin next:master</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">从远程拉取分支到本地</span></span><br><span class="line">git pull origin iot:iot</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它</span></span><br><span class="line">git fetch origin + git reset --hard origin/master</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">将该分支推送到远端仓库，如origin</span></span><br><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class="line">git push origin &lt;本地远程名一样&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line">git push [remote] --force</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">强制推送本地master到远程master</span></span><br><span class="line">git push -f master master</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">推送所有分支到远程仓库</span></span><br><span class="line">git push [remote] --all</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">当前分支与远程分支之间建立追踪关系，以后直接git push</span></span><br><span class="line">git push --set-upstream branch origin/branch  </span><br><span class="line">git branch --set-upstream-to=origin/remote_branch  your_branch</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">推送本地分支到远程的remote_branch分支并建立关联</span></span><br><span class="line">git push --set-upstream origin remote_branch</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">设置为默认远程，以后直接git push</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">列出所有本地分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">列出所有远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -r</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">列出所有本地分支和远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">新建一个分支，但依然停留在当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch [branch-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">删除分支</span></span><br><span class="line">git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">指定master分支追踪origin/next分支</span></span><br><span class="line">git branch --set-upstream master origin/next</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">把本地分支与远程分支关联</span></span><br><span class="line">git branch --set-upstream-to origin/next</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">切换到远程的某一分支</span></span><br><span class="line">git checkout -b dev origin/dev</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看本地远程分支对应情况</span></span><br><span class="line">git branch -vv</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">重命名远程分支对应的本地分支</span></span><br><span class="line">git branch -m oldName newName</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">删除远程分支</span></span><br><span class="line">git push --delete origin oldName</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">上传新命名的本地分支</span></span><br><span class="line">git push origin newName</span><br></pre></td></tr></table></figure><p>切换：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">新建一个分支，并切换到该分支</span></span><br><span class="line">git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">如预发布分支是从Develop分支上面分出来的，并切换到该分支</span></span><br><span class="line">git checkout -b release-1.2 develop</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">切换分支，并更新工作区</span></span><br><span class="line">git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">切换到上一个分支</span></span><br><span class="line">git checkout -</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">恢复暂存区的所有文件到工作区</span></span><br><span class="line">git checkout .</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">恢复暂存区的指定文件到工作区，即丢弃工作区修改</span></span><br><span class="line">git checkout -- [file]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">文件从本地仓库复制到工作区</span></span><br><span class="line">git checkout HEAD -- [file]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line">git checkout [commit] [file]</span><br></pre></td></tr></table></figure><p>标签：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">列出所有tag</span></span><br><span class="line">git tag</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">新建一个tag在当前commit</span></span><br><span class="line">git tag [tag]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送tag到远端</span></span><br><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure><p>合并：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">合并其他分支到你的当前分支</span></span><br><span class="line">git merge [branch]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">取消快进式合并-fast-farward merge</span></span><br><span class="line">git merge --no-ff [branch]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">所有的合并都有可能会有冲突，冲突手动解决之后，需要add以标记合并成功</span></span><br><span class="line">git add &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看本地仓库提交日志</span></span><br><span class="line">git log</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看的同时显示每次提交内容的差异</span></span><br><span class="line">git log -p</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">只看frank作者的提交日志</span></span><br><span class="line">git log --author=frank</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">一个压缩后的每一条提交记录只占一行的输出</span></span><br><span class="line">git log --pretty=oneline</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">通过 ASCII 艺术的树形结构来展示所有的分支</span></span><br><span class="line">git log --graph --oneline --decorate --all</span><br></pre></td></tr></table></figure><p>区别：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">显示暂存区和工作区的差异</span></span><br><span class="line">git diff [filepath..]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line">git diff HEAD [filepath..]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">在合并改动之前可以预览分支间的差异</span></span><br><span class="line">git diff &lt;source_branch&gt; &lt;target_branch&gt; [filepath..]</span><br><span class="line">git diff master origin/master [filepath..] </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">比较本地工作区与运程版本库</span></span><br><span class="line">git diff origin/master [filepath..]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">比较暂存区和版本库的差异</span></span><br><span class="line">git diff --cached [filepath..]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">比较暂存区与运程版本库</span></span><br><span class="line">git diff --cached origin/master [filepath..]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">比较工作区与指定commit-id的差异</span></span><br><span class="line">git diff commit-id  [filepath..] </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">比较两个commit-id之间的差异</span></span><br><span class="line">git diff commit-id commit-id</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">比较暂存区与指定commit-id的差异</span></span><br><span class="line">git diff --cached commit-id [filepath..] </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看某次提交内容</span></span><br><span class="line">git show commit-id</span><br></pre></td></tr></table></figure><p>撤销：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">重置暂存区，与上一次commit保持一致</span></span><br><span class="line">git reset</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">重置暂存区，但工作区不变</span></span><br><span class="line"><span class="meta">#</span><span class="bash">(HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，往上100个版本写成HEAD~100)</span></span><br><span class="line">git reset HEAD [file]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class="line">git reset --hard</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line">git reset [commit]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line">git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line">git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">仅仅只是撤销已提交的版本库，不会修改暂存区和工作区</span></span><br><span class="line">git reset --soft [commit]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">仅仅只是撤销已提交的版本库和暂存区，不会修改工作区</span></span><br><span class="line">git reset --mixed [commit]</span><br></pre></td></tr></table></figure><p>备忘<br>这是让master分支上的改动merge到zhangli分支<br><img src="git-learn/merge_rem.png" alt></p><p>参考资料</p><p><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">常用 Git 命令清单</a></p><p><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的Git教程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;虽然公司里面用SVN，但是为了探索更好的团队协作方式，我觉得有必要再把Git弄懂一些。就像是石墨文档一样，提高团队协作效率才是第一生产力嘛。在这篇文章中，我尽可能地记录多数情况下会用到的命令和正确的协作方式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h
      
    
    </summary>
    
      <category term="Git" scheme="https://barry215.github.io/categories/Git/"/>
    
    
      <category term="git" scheme="https://barry215.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>MySQL持续更新</title>
    <link href="https://barry215.github.io/2017/04/04/mysql-review/"/>
    <id>https://barry215.github.io/2017/04/04/mysql-review/</id>
    <published>2017-04-04T11:53:23.000Z</published>
    <updated>2017-08-23T16:44:33.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>MySQL是我比较常用的数据库，要持续刷新对它的认知呀</p></blockquote><h3 id="数据库事务的四个属性（ACID）"><a href="#数据库事务的四个属性（ACID）" class="headerlink" title="数据库事务的四个属性（ACID）"></a>数据库事务的四个属性（ACID）</h3><p><strong>原子性</strong>是指事务包含的所有操作要么全部成功，要么全部失败回滚</p><p><strong>一致性</strong>是指事务必须使数据库从一个一致性状态变换到另一个一致性状态</p><p><strong>隔离性</strong>是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p><p><strong>持久性</strong>是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p><h3 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h3><p><strong>脏读</strong>是指一个线程中的事务读取到了另外一个线程中未提交的数据。</p><p><strong>不可重复读（虚读）</strong>是指一个线程中的事务读取到了另外一个线程中提交的update的数据，两次读的不一样</p><p><strong>幻读</strong>是指一个线程中的事务读取到了另外一个线程中提交的insert或delete的数据，两次读的不一样</p><p>第1类丢失更新：事务A撤销时，把已经提交的事务B的更新数据覆盖了。</p><p>第2类丢失更新：事务A覆盖事务B已经提交的数据，造成事务B所做的操作丢失。</p><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读（Dirty Read）</th><th style="text-align:center">不可重复读（NonRepeatable Read）</th><th style="text-align:center">幻读（Phantom Read）</th><th style="text-align:center">第一类丢失更新</th><th style="text-align:center">第二类丢失更新</th></tr></thead><tbody><tr><td style="text-align:center">未提交读（Read uncommitted）</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">已提交读（Read committed）</td><td style="text-align:center">×</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">可重复读（Repeatable read）</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">可串行化（Serializable ）</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr></tbody></table><p>级别越高，数据越安全，但性能越低，×表示不允许，√表示允许</p><p>在MySQL数据库中，支持上面四种隔离级别，默认的为Repeatable read (可重复读)，有可能发现幻读；而在Oracle数据库中，只支持Serializable (串行化)级别和Read committed (读已提交)这两种级别，其中默认的为Read committed级别。</p><h4 id="不可重复读（虚读）和幻读的差别"><a href="#不可重复读（虚读）和幻读的差别" class="headerlink" title="不可重复读（虚读）和幻读的差别"></a>不可重复读（虚读）和幻读的差别</h4><p>从总的结果来看, 似乎两者都表现为两次读取的结果不一致.<br>但如果你从控制的角度来看, 两者的区别就比较大：<br>对于前者, 只需要<strong>锁住满足条件的记录</strong><br>对于后者, 要<strong>锁住满足条件及其相近的记录</strong></p><h3 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h3><p>第一范式：强调的是列的原子性，即列不能够再分成其他几列</p><p>第二范式：一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的其中一部分。</p><p>第三范式：非主键列必须直接依赖于主键，不能存在传递依赖</p><h3 id="sql优化的经验"><a href="#sql优化的经验" class="headerlink" title="sql优化的经验"></a>sql优化的经验</h3><ul><li>SELECT子句中避免使用 <code>*</code></li><li>用TRUNCATE替代DELETE</li><li>sql语句用大写的；因为oracle总是先解析sql语句，把小写的字母转换成大写的再执行</li></ul><h3 id="触发器优点和缺点"><a href="#触发器优点和缺点" class="headerlink" title="触发器优点和缺点"></a>触发器优点和缺点</h3><p>优点：自动执行，级联更新</p><p>缺点：不好维护，性能一般</p><h3 id="存储过程优点和缺点"><a href="#存储过程优点和缺点" class="headerlink" title="存储过程优点和缺点"></a>存储过程优点和缺点</h3><p>优点：可以封装数据逻辑和业务规则，减少sql传输的时间，存储过程在第一次执行时进行语法检查和编译，快速执行</p><p>缺点：代码可复用性差</p><p>触发器和存储过程在复杂的程序里尽量不要多用</p><h3 id="JDBC操作数据库步骤"><a href="#JDBC操作数据库步骤" class="headerlink" title="JDBC操作数据库步骤"></a>JDBC操作数据库步骤</h3><p>下面的代码以连接本机的Oracle数据库为例，演示JDBC操作数据库的步骤。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">加载驱动</span><br><span class="line">Class.forName(<span class="string">"oracle.jdbc.driver.OracleDriver"</span>);</span><br><span class="line"></span><br><span class="line">创建连接</span><br><span class="line">Connection con = DriverManager.getConnection(<span class="string">"jdbc:oracle:thin:@localhost:1521:orcl"</span>, <span class="string">"scott"</span>, <span class="string">"tiger"</span>);</span><br><span class="line"></span><br><span class="line">创建语句</span><br><span class="line">PreparedStatement ps = con.prepareStatement(<span class="string">"select * from emp where sal between ? and ?"</span>);</span><br><span class="line">ps.setInt(<span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">ps.setInt(<span class="number">2</span>, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">执行语句</span><br><span class="line">ResultSet rs = ps.executeQuery();</span><br><span class="line"></span><br><span class="line">处理结果</span><br><span class="line"><span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">    System.out.println(rs.getInt(<span class="string">"empno"</span>) + <span class="string">" - "</span> + rs.getString(<span class="string">"ename"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">关闭资源</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(con != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            con.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Statement和PreparedStatement有什么区别？哪个性能更好？</strong></p><p>①PreparedStatement接口代表预编译的语句，它主要的优势在于可以减少SQL的编译错误并增加SQL的安全性，防止注入</p><blockquote><ol><li>在使用参数化查询的情况下，数据库系统（eg:MySQL）不会将参数的内容视为SQL指令的一部分来处理，而是在数据库完成SQL指令的编译后，才套用参数运行，因此就算参数中含有破坏性的指令，也不会被数据库所运行</li><li>数据库系统会对sql语句进行预编译处理（如果JDBC驱动支持的话），预处理语句将被预先编译好，这条预编译的sql查询语句能在将来的查询中重用，这样一来，它比Statement对象生成的查询速度更快。</li></ol></blockquote><p>②PreparedStatement中的SQL语句是可以带参数的，采用占位符，避免了用字符串连接拼接SQL语句的麻烦和不安全</p><p>③当批量处理SQL或频繁执行相同的查询时，PreparedStatement有明显的性能上的优势，由于数据库可以将编译优化后的SQL语句缓存起来，下次执行相同结构的语句时就会很快（不用再次编译和生成执行计划）</p><p><a href="http://www.importnew.com/5006.html" target="_blank" rel="noopener">http://www.importnew.com/5006.html</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreparedStmtExample</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Connection conn = DriverManager.getConnection(<span class="string">"mysql:\\localhost:1520"</span>, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br><span class="line">        PreparedStatement preStatement = conn.prepareStatement(<span class="string">"select distinct loan_type from loan where bank=?"</span>);</span><br><span class="line">        preStatement.setString(<span class="number">1</span>, <span class="string">"Citibank"</span>);</span><br><span class="line"> </span><br><span class="line">        ResultSet result = preStatement.executeQuery();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span>(result.next())&#123;</span><br><span class="line">            System.out.println(<span class="string">"Loan Type: "</span> + result.getString(<span class="string">"loan_type"</span>));</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">Output:</span><br><span class="line">Loan Type: Personal Loan</span><br><span class="line">Loan Type: Auto Loan</span><br><span class="line">Loan Type: Home Loan</span><br><span class="line">Loan Type: Gold Loan</span><br></pre></td></tr></table></figure><h3 id="联合（复合）索引"><a href="#联合（复合）索引" class="headerlink" title="联合（复合）索引"></a>联合（复合）索引</h3><h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>索引是key index (a,b,c). 可以支持a | a,b| a,b,c 3种组合进行查找，但不支持 b,c或a,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。</p><p>要注意的是a，b，c的顺序可以乱调，mysql会调成合适的顺序，但是复合索引的最前面的字段a最好是经常出现在where条件中的</p><p>mysql的索引如果单索引在联合索引之前定义，那么只会用单索引而不会用联合索引了</p><p><strong>OR操作是不能用联合索引的</strong></p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>MySQL只对&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN使用索引</li><li>MySQL对LIKE ‘%name%’不使用索引，对LIKE ‘name%’使用索引</li></ul><h4 id="优化索引"><a href="#优化索引" class="headerlink" title="优化索引"></a>优化索引</h4><ul><li><p>索引不会包含有NULL值的列</p><p>只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。</p></li><li><p>使用短索引</p><p>对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。</p></li><li><p>索引列排序</p><p>MySQL查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。</p></li><li><p>like语句操作</p><p>一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。</p></li><li><p>不要在列上进行运算</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(adddate)&lt;<span class="number">2007</span>;</span><br></pre></td></tr></table></figure><p>将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> adddate&lt;<span class="string">'2007-01-01'</span>;</span><br></pre></td></tr></table></figure></li><li><p>不使用NOT IN和&lt;&gt;操作</p><p>这个很简单，因为这两个操作不会使用索引。</p></li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>索引虽然能提高查询性能，但是泛滥使用也会导致一些问题：</p><ul><li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件</li><li>建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。</li></ul><h4 id="参考路径"><a href="#参考路径" class="headerlink" title="参考路径"></a>参考路径</h4><p><a href="http://kael-aiur.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95.html" target="_blank" rel="noopener">数据库索引</a></p><h3 id="松散索引"><a href="#松散索引" class="headerlink" title="松散索引"></a>松散索引</h3><p>实际上就是当MySQL 完全利用索引扫描来实现GROUP BY 的时候，并不需要扫描所有满足条件的索引键即可完成操作得出结果。</p><p>要利用到松散索引扫描实现GROUP BY，需要至少满足以下几个条件：</p><ul><li>GROUP BY 条件字段必须在同一个索引中最前面的连续位置；</li><li>在使用GROUP BY 的同时，只能使用MAX 和MIN 这两个聚合函数；</li><li>如果引用到了该索引中GROUP BY 条件之外的字段条件的时候，必须以常量形式存在；</li></ul><h4 id="为什么松散索引扫描的效率会很高"><a href="#为什么松散索引扫描的效率会很高" class="headerlink" title="为什么松散索引扫描的效率会很高"></a>为什么松散索引扫描的效率会很高</h4><p>因为在没有WHERE 子句，也就是必须经过全索引扫描的时候， 松散索引扫描需要读取的键值数量与分组的组数量一样多，也就是说比实际存在的键值数目要少很多。而在WHERE 子句包含范围判断式或者等值表达式的时候， 松散索引扫描查找满足范围条件的每个组的第1 个关键字，并且再次读取尽可能最少数量的关键字。</p><h3 id="紧凑索引"><a href="#紧凑索引" class="headerlink" title="紧凑索引"></a>紧凑索引</h3><p>紧凑索引扫描实现GROUP BY 和松散索引扫描的区别主要在于他需要在扫描索引的时候，读取所有满足条件的索引键，然后再根据读取的数据来完成GROUP BY 操作得到相应结果。</p><h3 id="索引合并"><a href="#索引合并" class="headerlink" title="索引合并"></a>索引合并</h3><blockquote><p>index merge：对多个索引分别进行条件扫描，然后将它们各自的结果进行合并</p><p>MySQL5.0之前，<strong>一个表一次只能使用一个索引</strong>，无法同时使用多个索引分别进行条件扫描。但是从5.1开始，引入了 index merge 优化技术，对<strong>同一个表可以使用多个索引</strong>分别进行条件扫描。</p></blockquote><p>在mysql 5.1版本之前只要用了or，sql就不会用任何索引；<br>5.1之后依旧不能用联合索引，但是两个字段都建了索引的话，会用index_merge，但是如果只有其中一个字段建了索引，那就只会用那个索引</p><p>在使用or的时候，如果那两个字段都有索引，那么mysql会自动选择是不是索引合并比全表扫描好</p><h4 id="index-intersect-merge"><a href="#index-intersect-merge" class="headerlink" title="index intersect merge"></a>index intersect merge</h4><p>index intersect merge就是多个索引条件（单索引和联合索引）扫描得到的结果进行交集运算。显然在多个索引提交之间是 AND 运算时，才会出现 index intersect merge. 但是一般都可以用联合索引替代。</p><h4 id="index-uion-merge"><a href="#index-uion-merge" class="headerlink" title="index uion merge"></a>index uion merge</h4><p>index uion merge就是多个索引条件扫描，对得到的结果进行并集运算，显然是多个条件之间进行的是 OR 运算</p><h3 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h3><p>辅助索引又叫二级索引，他是指除了主键索引之外的索引，innodb的主键索引是聚簇索引，数据和索引放在一起，但是辅助索引是非聚簇索引，myisam的主键索引和辅助索引一样都是非聚簇索引</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;MySQL是我比较常用的数据库，要持续刷新对它的认知呀&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;数据库事务的四个属性（ACID）&quot;&gt;&lt;a href=&quot;#数据库事务的四个属性（ACID）&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="Mysql" scheme="https://barry215.github.io/categories/Mysql/"/>
    
    
      <category term="mysql" scheme="https://barry215.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis基础回顾</title>
    <link href="https://barry215.github.io/2017/04/04/mybatis-review/"/>
    <id>https://barry215.github.io/2017/04/04/mybatis-review/</id>
    <published>2017-04-04T11:40:09.000Z</published>
    <updated>2017-08-09T13:46:59.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>用了很久的Mybatis，但是一直没有全面去学过，这次补一下基础吧</p></blockquote><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><p>当使用Mybatis时，首先用字节流通过Resource将配置文件读入，然后通过SqlSessionFactoryBuilder().build方法创建SqlSessionFactory，然后再通过sqlSessionFactory.openSession()方法创建一个sqlSession。Mybatis通过xml文件映射到各实体类的Mapper接口，Mapper接口中配置了每个类对数据库所需进行的sql语句映射。<br>经历了Mybatis初始化 –&gt;创建SqlSession –&gt;运行SQL语句 返回结果三个过程</p><h3 id="mybatis缓存概念"><a href="#mybatis缓存概念" class="headerlink" title="mybatis缓存概念"></a>mybatis缓存概念</h3><p>当我们使用Mybatis进行数据库的操作时候，MyBatis会开启一个会话时，然后创建一个新的<strong>SqlSession</strong>对象，<strong>SqlSession</strong>对象中会有一个新的<strong>Executor</strong>对象，<strong>Executor</strong>对象中持有一个新的<strong>PerpetualCache</strong>对象；当会话结束时，<strong>SqlSession</strong>对象及其内部的<strong>Executor</strong>对象还有<strong>PerpetualCache</strong>对象也一并释放掉。</p><p>一级缓存：（HashMap来实现，并没有对<strong>HashMap</strong>的容量和大小进行限制，key为hashCode+sqlId+Sql语句。value为从查询出来映射生成的java对象）</p><p>对SqlSession的操作mybatis内部都是通过Executor来执行的，Executor在执行数据库查询的时候总是先查看缓存中是否存在，若不存在则查询数据库。</p><blockquote><p>SqlSession是对外接口，Executor是内部执行器</p></blockquote><p>二级缓存：</p><p>二级缓存的范围更大，根据<code>namespace</code>划分的，多个<code>SqlSession</code>可以共享一个<code>UserMapper</code>的二级缓存区域。</p><p>每一个<code>namespace</code>的<code>mapper</code>有一个二级缓存区域。也就是说如果两个<code>mapper</code>的<code>namespace</code>相同，那么这两个<code>mapper</code>执行<code>sql</code>查询到的数据将存储在一个二级缓存区域中。</p><blockquote><p>mybatis的二级缓存是通过CacheExecutor实现的。CacheExecutor其实是Executor的代理对象。所有的查询操作，在CacheExecutor中都会先匹配缓存中是否存在，不存在则查询数据库。二级缓存是可以跨SqlSession的</p></blockquote><p>MyBatis查询数据的顺序是：</p><p>二级缓存 ———&gt; 一级缓存——&gt; 数据库</p><p><img src="mybatis-review/mybatis.png" alt></p><p>要使用Mybatis的二级缓存，需要对Mybatis进行配置，配置分三步</p><ul><li><p>Mybatis全局配置中启用二级缓存配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在对应的Mapper.xml中配置cache节点</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"userMapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cache</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在对应的select查询节点中添加useCache=true</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultMap</span>=<span class="string">"user"</span> <span class="attr">useCache</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">  select * from users where id=#&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>实体类要实现序列化接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">  <span class="comment">//属性......</span></span><br><span class="line">  <span class="comment">//getter and setter......  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>一级缓存是sqlSession级别的缓存。在操作数据库时需要构造sqlSession对象，在对象中有一个数据结构(HashMap),用于存储缓存数据。不同的sqlSession之间的缓存区域(HashMap)是互不影响的。</p><p>二级缓存是mapper级别的缓存，多个sqlSession去操作同一个Mapper的sql语句，多个SqlSession可以公用二级缓存，二级缓存是跨sqlSession的。</p><h3 id="MyBatis和Hibernate各有什么优缺点"><a href="#MyBatis和Hibernate各有什么优缺点" class="headerlink" title="MyBatis和Hibernate各有什么优缺点?"></a>MyBatis和Hibernate各有什么优缺点?</h3><p><code>Hibernate</code>的优点是它是一个完全的<code>ORM框架</code>，使用<code>Hibernate</code>可以做到不用手写SQL，而且无须关心使用何种数据库，可移植性较好，当需要更变数据库时需要做的修改很少甚至为0。其缺点是需要根据数据库的设计在实体进行又一次的配置，且帮程序员做了太多事，如果需要进行调优的话需要对<code>Hibernate</code>有比较深的了解。<br><code>MyBatis</code>的优缺点差不多和<code>Hibernate</code>相反，我们需要<code>手写SQL</code>语句和<code>配置结果集和实体类的映射</code>，即使是简单的单表操作也需要写SQL(可以通过<code>拦截器</code>来实现CommonMapper，或者可以使用生成器来生成代码)，因此<code>MyBatis</code>要进行SQL调优也简单直接。其次是<code>MyBatis</code>的<code>二级缓存</code>功能较弱，是针对<code>namespace</code>的。</p><h3 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h3><p><a href="http://www.jianshu.com/p/7dd95270864c" target="_blank" rel="noopener">MyBatis系列之动态SQL语句</a></p><p><a href="http://www.ctolib.com/topics-102259.html" target="_blank" rel="noopener">MyBatis中的OGNL教程</a></p><h3 id="TypeHandler"><a href="#TypeHandler" class="headerlink" title="TypeHandler"></a>TypeHandler</h3><blockquote><p>TypeHandler可以让数据库字段类型和Java类做一个映射，就好像默认text类可以转成String，但是可以用TypeHandler来转成Java自定义类型</p></blockquote><p><a href="http://www.jianshu.com/p/17313a00a102" target="_blank" rel="noopener">http://www.jianshu.com/p/17313a00a102</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;用了很久的Mybatis，但是一直没有全面去学过，这次补一下基础吧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Mybatis&quot;&gt;&lt;a href=&quot;#Mybatis&quot; class=&quot;headerlink&quot; title=&quot;Mybatis&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="Mybatis" scheme="https://barry215.github.io/categories/Mybatis/"/>
    
    
      <category term="mybatis" scheme="https://barry215.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程详解</title>
    <link href="https://barry215.github.io/2017/03/27/java-thread/"/>
    <id>https://barry215.github.io/2017/03/27/java-thread/</id>
    <published>2017-03-27T02:48:22.000Z</published>
    <updated>2018-02-06T06:07:34.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>多线程之前了解的有点乱，特此整理</p></blockquote><h3 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h3><p><strong>公平性：</strong></p><ol><li>公平锁：线程按照他们发出请求的顺序来获得锁。如果有另一个线程持有这个锁或者有其他线程在队列中等待这个锁，那么新发出请求的线程将放入队列中。</li><li>非公平锁：非公平锁允许“插队”：当一个线程请求非公平的锁时，如果在发出请求的同时该锁的状态变为可用，那么这个线程将跳过排队队列，直接获取这个锁。</li></ol><blockquote><p>也就是说非公平锁在入队同时可以强锁，如果没抢到就得排队，公平锁只能排队</p></blockquote><p><strong>悲观／乐观：</strong></p><ol><li><p>悲观锁：把数据库里的某行数据锁住，或者整张表锁住，不让其他事务访问，数据库里一般会使用排它锁来实现悲观锁，但是因为其他事务不能访问，所以效率很低，适合数据竞争激烈的环境。可以防脏读。</p></li><li><p>乐观锁：在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。它可以让各事务能够在不产生锁的情况下处理各自影响的那部分数据。</p><p>乐观锁是基于CAS实现的，为了解决ABA问题，可以加上version的方法解决</p></li></ol><p><strong>排他(独占)／共享：</strong></p><ol><li>排他锁：只能有1个线程持有锁,可以有效的防止脏读</li><li>共享锁：共享锁不会阻止其他用户读，但是阻止其他的用户写和修改</li></ol><h5 id="锁状态"><a href="#锁状态" class="headerlink" title="锁状态"></a>锁状态</h5><blockquote><p>锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）</p></blockquote><p><strong>偏向锁：</strong></p><p>适合只有一个线程访问同步代码的场景</p><p>只要加了一次锁，之后访问里面的临界区都不用再加锁</p><p><strong>自旋锁：</strong></p><p>自身空循环来等待，然后再CAS请求锁</p><p><strong>轻量级锁：</strong></p><p>b线程在锁竞争时，发现锁已经被a线程占用，则b线程不进入内核态，让b线程自旋，执行空循环，等待a线程释放锁。如果，完成自旋策略执行CAS换锁操作，发现a线程还是没有释放锁，或者让c线程占用了。则b线程试图将轻量级锁升级为重量级锁。始终得不到锁竞争的线程使用自旋会消耗CPU。</p><p><strong>重量级锁：</strong></p><p>线程竞争不使用自旋，不会消耗CPU    线程阻塞，响应时间缓慢，适合追求吞吐量,锁占用时间较长</p><table><thead><tr><th><strong>锁</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td><td>适用于只有一个线程访问同步块场景</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高了程序的响应速度</td><td>如果始终得不到索竞争的线程，使用自旋会消耗CPU</td><td>追求响应速度，同步块执行速度非常快</td></tr><tr><td>重量级锁</td><td>线程竞争不使用自旋，不会消耗CPU</td><td>线程阻塞，响应时间缓慢</td><td>追求吞吐量，同步块执行速度较长</td></tr></tbody></table><p><strong>另外</strong></p><p>可重入锁：当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2。</p><p><strong>速学路径</strong></p><p><a href="http://kaimingwan.com/post/java/javanei-zhi-suo-kai-xiao-you-hua-pian-xiang-suo-qing-liang-ji-suo" target="_blank" rel="noopener">http://kaimingwan.com/post/java/javanei-zhi-suo-kai-xiao-you-hua-pian-xiang-suo-qing-liang-ji-suo</a></p><h3 id="CAS介绍"><a href="#CAS介绍" class="headerlink" title="CAS介绍"></a>CAS介绍</h3><p>CAS（Compare and Swap）即比较并替换，设计并发算法时常用到的一种技术。返回boolean值。</p><p>CAS是通过unsafe类的compareAndSwap方法实现的，是底层实现的原子指令</p><p>CAS用户程序不用直接调用，但是automicInteger内实现了这些方法，比如incrementAndGet()方法实际上就是不断循环CAS操作，直到成功</p><h4 id="具体说明"><a href="#具体说明" class="headerlink" title="具体说明"></a>具体说明</h4><p>赋值操作即是新值替换旧值，所以先比较现在的值是否为自己所以为的旧值，如果不是，则说明自己发生了脏读。本次操作失败返回false。</p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p><h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p>就是一个变量V，如果变量V初次读取的时候是A，并且在准备赋值的时候检查到它仍然是A，那能说明它的值没有被其他线程修改过了吗？如果在这段期间它的值曾经被改成了B，然后又改回A，那CAS操作就会误认为它从来没有被修改过。</p><p>ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1。java并发包中提供了一个带有标记的原子引用类”AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。</p><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p>java.util.concurrent包完全建立在CAS之上的，乐观锁就是基于CAS。</p><p>java.util.concurrent.atomic包下的原子操作类都是基于CAS实现的</p><h3 id="AQS介绍"><a href="#AQS介绍" class="headerlink" title="AQS介绍"></a>AQS介绍</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">  <span class="comment">// 等待对列的头节点</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line">  <span class="comment">// 等待队列的尾节点</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">  <span class="comment">// 同步状态</span></span><br><span class="line">  <span class="keyword">private</span> valatile <span class="keyword">int</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;<span class="comment">//该节点的状态</span></span><br><span class="line"><span class="keyword">volatile</span> Node prev;<span class="comment">//同步等待队列前驱节点</span></span><br><span class="line"><span class="keyword">volatile</span> Node next;<span class="comment">//同步等待队列后继节点</span></span><br><span class="line"><span class="keyword">volatile</span> Thread thread;<span class="comment">//持有该节点的线程</span></span><br><span class="line">Node nextWaiter;<span class="comment">//存储condition队列中的后继节点。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tryAcquire()修改状态，获取锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加入到等待队列，用cas原子替换tail，防止多线程错误</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failur</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不断循环获取队列前一个node，如果是头结点，则再次尝试修改state，获取锁，不然被阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>队列同步器AQS是用来构建锁或其他同步组件的基础框架，内部使用了一个int类型的volatile修饰的state来表示同步状态，通过acquire来尝试修改state的值（未实现），修改成功的线程表示获取到该锁，没有修改成功，或者发现状态state已经是加锁状态，则把当前线程包装成一个node节点，并通过CAS指令插入到FIFO等待队列的队尾。node插入到队尾后该线程不会马上挂起，而是进行自旋操作。如果前一个节点是头结点，他会自旋后再次尝试tryAcquire方法获取锁。只有当前一个节点pred的线程状态位SIGNAL时，当前节点的线程才能被挂起，并等待被唤醒。等待队列的头节点head和尾结点tail都是通过volatile修饰，保证了多个线程之间的可见性。</p><h3 id="synchronized介绍"><a href="#synchronized介绍" class="headerlink" title="synchronized介绍"></a>synchronized介绍</h3><p>synchronized是java语言的关键字，由jvm实现的语法级别的锁机制。是一种可重入/非公平/悲观/独占锁。</p><p>原理：</p><p>synchronized可以对一个代码块或是对一个方法上锁，方法块的原理是使用monitorenter和monitorexit指令，被“锁住”的地方称为临界区。线程执行到 monitorenter 指令时，将会尝试获取对象所对应的 monitor 的所有权，即尝试获得对象的锁，这样其他尝试进入临界区的线程会因无法获取monitor而被阻塞。由于等待另一个线程释放monitor而被阻塞的线程无法被中断。</p><p>同步方法 并不是由 monitorenter 和 monitorexit 指令来实现同步的，而是由方法调用指令读取运行时常量池中方法的 ACC_SYNCHRONIZED 标志来隐式实现的</p><blockquote><p>monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，每个monitorenter必须有一个monitorexit对应。</p></blockquote><p>Java中的每个对象都可以作为锁。</p><blockquote><p>任何对象都有一个 monitor 与之关联，当且一个monitor 被持有后，它将处于锁定状态</p></blockquote><ol><li>普通同步方法，锁是当前实例对象。</li><li>静态同步方法，锁是当前类的class对象。</li><li>同步代码块，锁是括号中的对象。</li></ol><p>作用于一段代码或方法，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到物理内存中。因此可以保证<strong>可见性</strong>，也能够保证<strong>原子性</strong>，synchronized修饰方法是获得对象锁</p><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="comment">// todo</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写法一修饰的是一个方法，写法二修饰的是一个代码块，但写法一与写法二是等价的，都是锁定了整个方法时的内容。</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadlockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="keyword">new</span> String(<span class="string">"资源1"</span>);</span><br><span class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">"资源2"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Lock(str1, str2), <span class="string">"线程1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Lock(str2, str1), <span class="string">"线程2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String str1;</span><br><span class="line">    <span class="keyword">private</span> String str2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Lock</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.str1 = str1;</span><br><span class="line">        <span class="keyword">this</span>.str2 = str2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"运行"</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (str1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"锁住"</span> + str1);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (str2) &#123;</span><br><span class="line">                    <span class="comment">// 执行不到这里</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"锁住"</span> + str2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="效率低"><a href="#效率低" class="headerlink" title="效率低"></a>效率低</h4><p>监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从<strong>用户态</strong>转换到<strong>核心态</strong>，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因</p><h4 id="备注-1"><a href="#备注-1" class="headerlink" title="备注"></a>备注</h4><ol><li>synchronized关键字不能继承。</li><li>在定义接口方法时不能使用synchronized关键字。</li><li>构造方法不能使用synchronized关键字，但可以使用synchronized代码块来进行同步。</li><li>一个线程访问一个对象中的synchronized(this)同步代码块时，其他试图访问该对象的线程将被阻塞。</li></ol><p><a href="https://segmentfault.com/a/1190000004453860" target="_blank" rel="noopener">synchronized实现死锁</a></p><h3 id="Lock介绍"><a href="#Lock介绍" class="headerlink" title="Lock介绍"></a>Lock介绍</h3><p>Lock是Java 5以后引入的新的API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取锁，否则会一直等待</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;    </span><br><span class="line">    <span class="comment">//获取锁，否则一直等待，但是等待状态可以被其他线程中断</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">//尝试获得锁，没抢到直接返回失败</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;        </span><br><span class="line">    <span class="comment">//尝试获取锁，没抢到则会等待一段时间，等待状态可以被其他线程中断</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//生成锁的条件变量，线程获取锁后，可以等待或者通知该条件变量</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Lock lock= ...;<span class="comment">//获取锁</span></span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//处理任务</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>synchronized和Lock区别</strong></p><p><strong>相同点</strong></p><p>Lock 能完成synchronized所实现的所有功能</p><p><strong>不同点</strong></p><ul><li>synchronized会自动释放锁，而Lock一定要求程序员手工释放，且最好在finally 块中释放（否则会出现死锁）</li><li>通过Lock可以知道有没有成功获取锁，而synchronized却无法办到</li><li>synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生。Lock在发生异常时，如果没有主动通过unLock()方法去释放锁，则很可能造成死锁的现象，因此使用Lock时需要在finally块中释放锁</li></ul><h3 id="ReentrantLock介绍"><a href="#ReentrantLock介绍" class="headerlink" title="ReentrantLock介绍"></a>ReentrantLock介绍</h3><p>ReentrantLock实现了 Lock 接口，并提供了与 synchronized 相同的互斥和内存可见性</p><p>ReentrantLock 是可重入锁，根据构造器传入的布尔值来决定是否要公平锁</p><p>ReentrantLock是基于AQS实现的</p><h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><p>可重入锁中可重入表示的意义在于<strong>对于同一个线程，可以继续调用加锁的方法，而不会被挂起</strong>。可重入锁内部维护一个计数器，对于同一个线程调用lock方法，计数器+1，调用unlock方法，计数器-1</p><p>举例：在一个加锁方法execute中调用另外一个加锁方法anotherLock并不会被挂起，可以直接调用</p><blockquote><p>调用execute方法时计数器+1，然后内部又调用了anotherLock方法，计数器+1，变成了2</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" do something synchronize"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            anotherLock();</span><br><span class="line">            Thread.sleep(<span class="number">5000l</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(Thread.currentThread().getName() + <span class="string">" interrupted"</span>);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anotherLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" invoke anotherLock"</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span> <span class="keyword">do</span> something synchronize</span><br><span class="line">Thread-<span class="number">0</span> invoke anotherLock</span><br><span class="line"><span class="comment">// 隔了5秒钟 输入下面</span></span><br><span class="line">Thread-<span class="number">1</span> <span class="keyword">do</span> something synchronize</span><br><span class="line">Thread-<span class="number">1</span> invoke anotherLock</span><br></pre></td></tr></table></figure><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ol><li>lock()，如果获取了锁立即返回，如果别的线程持有锁，当前线程则一直处于休眠状态，直到获取锁</li><li>tryLock()，如果获取了锁立即返回true，如果别的线程正持有锁，立即返回false；</li><li>tryLock(long timeout,TimeUnit unit)，如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false；</li><li>lockInterruptibly，如果获取了锁定立即返回，如果没有获取锁定，当前线程处于休眠状态，这期间当前线程可以被中断。举个粟子，当A，B线程都试图使用lockInterruptibly()获取锁时，如果A获得了锁，B线程正在等待获取锁，则可以调用threadB.interrupt()能够中断线程B的等待。</li></ol><h4 id="举例-3"><a href="#举例-3" class="headerlink" title="举例"></a>举例</h4><p>线程A和B都要获取对象O的锁定，假设A获取了对象O锁，B将等待A释放对O的锁定，如果使用 synchronized ，如果A不释放，B将一直等下去，不能被中断如果 使用ReentrantLock，如果A不释放，可以使B在等待了足够长的时间以后，中断等待，而干别的事情</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Condition condition = lock.newCondition();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">while</span>(条件判断表达式) &#123;</span><br><span class="line">      condition.await();</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 处理逻辑</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="和synchronized区别"><a href="#和synchronized区别" class="headerlink" title="和synchronized区别"></a>和synchronized区别</h4><table><thead><tr><th></th><th>synchronized</th><th>ReentrantLock</th></tr></thead><tbody><tr><td>获取锁方式</td><td>抢锁失败只能无限等待</td><td>提供多种等待锁方式，可以中断正在等候获取一个锁的线程</td></tr><tr><td></td><td></td><td>可以限制等待超时</td></tr><tr><td></td><td></td><td>等待时可以被中断</td></tr><tr><td></td><td></td><td>可以<strong>无阻塞</strong>尝试获取锁</td></tr><tr><td>等待线程调度</td><td>未知，视 JVM 实现</td><td>公平锁：FIFO，按照进入同步队列顺序</td></tr><tr><td></td><td></td><td>非公平锁：<strong>第一次</strong>获取锁时有机会插队</td></tr><tr><td>编程便利性</td><td>获取锁/等待锁/释放锁都有内部实现，使用便利</td><td>需要显示获取锁，释放锁，切记<strong>要捕捉 exception， 在 finally 中释放锁</strong></td></tr><tr><td>性能</td><td>略低，Java6 后有显著提高</td><td>较高，Java6 后差距减小</td></tr><tr><td>调试</td><td>线程转储中给出哪些调用帧获得哪些锁</td><td>Java6 后提供管理和调试接口，锁需要通过该接口注册，相关加锁信息出现在线程转储中</td></tr></tbody></table><p><strong>总结</strong></p><p>Synchronized 与Lock都是可重入锁，同一个线程再次进入同步代码的时候.可以使用自己已经获取到的锁。</p><p>Synchronized是悲观锁机制，独占锁。而Locks.ReentrantLock是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。 ReentrantLock适用场景</p><ol><li>某个线程在等待一个锁的控制权的这段时间需要中断</li><li>需要分开处理一些wait-notify，ReentrantLock里面的Condition应用，能够控制notify哪个线程，锁可以绑定多个条件。</li><li>具有公平锁功能，每个到来的线程都将排队等候。</li></ol><h3 id="Condition介绍"><a href="#Condition介绍" class="headerlink" title="Condition介绍"></a>Condition介绍</h3><p>Condition是为解决Object.wait/notify/notifyAll难以使用的问题</p><p>一个ReentrantLock对象可以有多个Condition对象</p><blockquote><p>Condition的await方法代替Object的wait；<br>Condition的signal方法代替Object的notify方法；<br>Condition的signalAll方法代替Object的notifyAll方法；<br>Condition实例在使用时需要绑定到一个锁上，可以通过newCondition方法获取Condition实例。</p></blockquote><h4 id="举例-4"><a href="#举例-4" class="headerlink" title="举例"></a>举例</h4><p>一个线程调用<code>condition.await()</code>，此线程就会释放锁，阻塞。当另一个线程调用相同的condition的signal时，它才会重新竞争锁，然后从之前阻塞的地方继续开始。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">final</span> Condition condition = reentrantLock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    reentrantLock.lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"在等待被唤醒"</span>);</span><br><span class="line">                    condition.await();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"恢复执行了"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    reentrantLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"thread1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    reentrantLock.lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"抢到了锁"</span>);</span><br><span class="line">                    condition.signal();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"唤醒其它等待的线程"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    reentrantLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"thread2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thread1在等待被唤醒</span><br><span class="line">thread2抢到了锁</span><br><span class="line">thread2唤醒其它等待的线程</span><br><span class="line">thread1恢复执行了</span><br></pre></td></tr></table></figure><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ol><li><strong>await()</strong></li></ol><p><strong>调用await方法后，当前线程在接收到唤醒信号之前或被中断之前一直处于等待休眠状态。</strong>调用此方法时，当前线程保持了与此Condition有关联的锁，<strong>调用此方法后，当前线程释放持有的锁</strong>。此方法在返回当前线程之前，都必须重新获取与此条件有关的锁，在线程返回时，可以保证它保持此锁</p><ol start="2"><li><strong>await(long time,TimeUnit unit)</strong></li></ol><p><strong>调用此方法后，会造成当前线程在接收到唤醒信号之前、被中断之前或到达指定等待时间之前一直处于等待状态。</strong>调用此方法时，当前线程保持了与此Condition有关联的锁，<strong>调用此方法后，当前线程释放持有的锁</strong>。time参数为最长等待时间；unit参数为time的时间单位。如果在从此方法返回前检测到等待时间超时，则返回 false，否则返回true。此方法在返回当前线程之前，都必须重新获取与此条件有关的锁，在线程返回时，可以保证它保持此锁。</p><ol start="3"><li><strong>signal()</strong></li></ol><p><strong>唤醒一个等待线程，如果所有的线程都在等待此条件，则选择其中的一个唤醒。</strong>在从await返回之前，该线程必须重新获取锁。</p><ol start="4"><li><strong>signalAll()</strong></li></ol><p><strong>唤醒所有等待线程，如果所有的线程都在等待此条件，则唤醒所有线程。</strong> 在从await返回之前，每个线程必须重新获取锁。</p><h4 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h4><blockquote><p>生产者消费者的实现</p><ol><li>通过java阻塞队列</li><li>wait，notify或await，signal的方式</li><li>通过不断轮询地cas</li><li>通过观察者模式</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();<span class="comment">//锁对象  </span></span><br><span class="line"> <span class="keyword">final</span> Condition notFull  = lock.newCondition();<span class="comment">//写线程条件   </span></span><br><span class="line"> <span class="keyword">final</span> Condition notEmpty = lock.newCondition();<span class="comment">//读线程条件   </span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];<span class="comment">//缓存队列  </span></span><br><span class="line"> <span class="keyword">int</span> putptr<span class="comment">/*写索引*/</span>, takeptr<span class="comment">/*读索引*/</span>, count<span class="comment">/*队列中存在的数据个数*/</span>;  </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">   lock.lock();  </span><br><span class="line">   <span class="keyword">try</span> &#123;  </span><br><span class="line">     <span class="keyword">while</span> (count == items.length)<span class="comment">//如果队列满了   </span></span><br><span class="line">       notFull.await();<span class="comment">//阻塞写线程  </span></span><br><span class="line">     items[putptr] = x;<span class="comment">//赋值   </span></span><br><span class="line">     <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;<span class="comment">//如果写索引写到队列的最后一个位置了，那么置为0  </span></span><br><span class="line">     ++count;<span class="comment">//个数++  </span></span><br><span class="line">     notEmpty.signal();<span class="comment">//唤醒读线程  </span></span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">     lock.unlock();  </span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">   lock.lock();  </span><br><span class="line">   <span class="keyword">try</span> &#123;  </span><br><span class="line">     <span class="keyword">while</span> (count == <span class="number">0</span>)<span class="comment">//如果队列为空  </span></span><br><span class="line">       notEmpty.await();<span class="comment">//阻塞读线程  </span></span><br><span class="line">     Object x = items[takeptr];<span class="comment">//取值   </span></span><br><span class="line">     <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;<span class="comment">//如果读索引读到队列的最后一个位置了，那么置为0  </span></span><br><span class="line">     --count;<span class="comment">//个数--  </span></span><br><span class="line">     notFull.signal();<span class="comment">//唤醒写线程  </span></span><br><span class="line">     <span class="keyword">return</span> x;  </span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">     lock.unlock();  </span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>注意</p><p>上面代码中使用while来判断队列，而不是用if，是因为多线程情况下，唤醒了wait状态的线程，如果保证不了它是想要的那个线程，那就用while来多判断一次缓冲队列的状态</p><ul><li>一种是wait和notify体系，消费者一次消费结束，notify了另一个阻塞的消费者，而那个消费者没有做再一次的判断，所以会造成多消费</li><li>一种是普遍模式，如果生产者生产了，然后唤醒了一个消费者，但是不幸又来了一个消费者提前把生产的消费了，所以这个被唤醒的消费者，如果不再一次进行检查，那会造成又一次的消费</li></ul><p>所以wait一定要放在while语句里</p><p>参考路径：</p><p><a href="http://www.jianshu.com/p/8123b85cdc87" target="_blank" rel="noopener">生产者消费者的五种实现</a></p><p><a href="http://blog.csdn.net/u011784767/article/details/51656697" target="_blank" rel="noopener">生产者和消费者的例子，有解释</a></p><p><a href="https://juejin.im/entry/5800896fa22b9d005b2cd766" target="_blank" rel="noopener">Java 多线程之并发协作生产者消费者设计模式</a></p><h3 id="volatile介绍"><a href="#volatile介绍" class="headerlink" title="volatile介绍"></a>volatile介绍</h3><p>volatile关键字提供了内存可见性和禁止内存重排序</p><h4 id="具体说明-1"><a href="#具体说明-1" class="headerlink" title="具体说明"></a>具体说明</h4><ul><li>某一个线程修改了被volatile修饰的变量之后，会立即把值更新到主内存，其他线程获取这个变量的时候不会在工作内存中拿取，而是直接去主内存中拿取，保证了<strong>可见性</strong></li><li>volatile可以禁止进行指令重排，保证了<strong>有序性</strong></li></ul><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>volatile是基于内存屏障（Memory Barrier）实现的</p><blockquote><p>内存屏障，又称内存栅栏，是一个CPU指令，基本上它是一条这样的指令：<br>1、插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。<br>2、强制更新一次不同CPU的缓存。例如，一个写屏障会把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程将得到最新值，而不用考虑到底是被哪个cpu核心或者哪颗CPU执行的。<br>3、如果你的字段是volatile，Java内存模型将在写操作后插入一个写屏障指令，在读操作前插入一个读屏障指令。这意味着如果你对一个volatile字段进行写操作，你必须知道：1、一旦你完成写入，任何访问这个字段的线程将会得到最新的值。2、在你写入前，会保证所有之前发生的事已经发生，并且任何更新过的数据值也是可见的，因为内存屏障会把之前的写入值都刷新到缓存。</p></blockquote><p><strong>原子性原理</strong></p><p>即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p><p>比如<code>x++</code>包括3个操作：</p><p>1）读取volatile变量值到local； 2）增加变量的值；3）把local的值写回，让其它的线程可见。</p><p>这3步的jvm指令为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov    <span class="number">0xc</span>(%r10),%r8d ; Load</span><br><span class="line">inc    %r8d           ; Increment</span><br><span class="line">mov    %r8d,<span class="number">0xc</span>(%r10) ; Store</span><br><span class="line">lock addl $<span class="number">0x0</span>,(%rsp) ; StoreLoad Barrier  <span class="comment">//注意最后一步是内存屏障</span></span><br></pre></td></tr></table></figure><p>从Load到store到内存屏障，一共4步，其中最后一步jvm让这个最新的变量的值在所有线程可见，也就是最后一步让所有的CPU内核都获得了最新的值，但在执行内存屏障之前，中间的几步（从Load到Store）是不安全的。</p><p>内存屏障可以被分为以下几种类型：</p><p>LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</p><p>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</p><p>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</p><p>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。</p><p><strong>可见性原理</strong></p><p>为在虚拟机内存中有主内存和工作内存的概念，每个线程都有自己的工作内存，当读取一个普通变量时，优先读取工作内存的变量，如果工作内存中没有对应的变量，则从主内存中加载到工作内存，对工作内存的普通变量进行修改，不会立马同步到主内存。<strong>对volatile修饰的变量进行写操作时，直接把最新值写到主内存中，并清空其它cpu工作内存中该变量所在的内存行数据</strong>（Write-Barrier（写入屏障）将刷新所有在 Barrier 之前写入 cache 的数据），<strong>对volatile修饰的变量进行读操作时，会读取主内存的数据</strong>。内存可见性保证了在多线程的场景下，保证了线程A对变量的修改，其它线程可以读到最新值。</p><p><strong>有序性原理</strong></p><p>插入一条Memory Barrier会告诉编译器和CPU：不管什么指令都不能和这条Memory Barrier指令重排序</p><h4 id="缺陷-1"><a href="#缺陷-1" class="headerlink" title="缺陷"></a>缺陷</h4><p>volatile并不保证原子性，比如i++，因为两个线程可以同时在主存获取变量i的值，然后同时修改后，保存到主存，这个过程一点也不违背可见性（获取最新，修改后立马更新），比如i=0的时候，两个线程同时获取，然后同时修改后，i是等于1，而不是等于2</p><p>不要将volatile用在getAndOperate场合（这种场合不原子，需要再加锁），仅仅set或者get的场景是适合volatile的。</p><p>参考路径</p><p><a href="http://blog.csdn.net/sinat_35512245/article/details/60325685" target="_blank" rel="noopener">http://blog.csdn.net/sinat_35512245/article/details/60325685</a></p><h3 id="ThreadLocal介绍"><a href="#ThreadLocal介绍" class="headerlink" title="ThreadLocal介绍"></a>ThreadLocal介绍</h3><p>ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>每当线程去访问TreadLocal时，它都会从线程对应的TreadLocalMap（其实是一个Entry数组，索引是ThreadLocal对象的hash与运算，如果重复会nextIndex，再获取一个索引）中拿出与之对应的Entry，Entry的key是当前ThreadLocal对象，Entry的value就是当前线程下ThreadLocal的值</p><p><img src="java-thread/ThreadLocal.png" alt></p><p>ThreadLocalMap实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个ThreadLocalMap对象赋值给当前线程的成员变量threadLocals</span></span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">        <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">        table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        setThreshold(INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>ThreadLocal.set() 实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i]; e != <span class="keyword">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ThreadLocal.get() 实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="举例-5"><a href="#举例-5" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> SimpleDateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Date date = <span class="keyword">new</span> Date();</span><br><span class="line">                System.out.println(dateFormatThreadLocal.get().format(date));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Date date = <span class="keyword">new</span> Date();</span><br><span class="line">                <span class="comment">//dateFormatThreadLocal.set(new SimpleDateFormat("yyyy-MM-dd")); </span></span><br><span class="line">                System.out.println(dateFormatThreadLocal.get().format(date));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><h4 id="Servlet不是线程安全的"><a href="#Servlet不是线程安全的" class="headerlink" title="Servlet不是线程安全的"></a>Servlet不是线程安全的</h4><p>serlvet采用多线程来处理多个请求同时访问，Tomcat容器维护了一个线程池来服务请求，serlvet也只会初始化一次，当被请求访问到的时候初始化。当容器收到一个Servlet请求，Dispatcher线程从线程池中选出一个工作组线程，将请求传递给该线程，然后由该线程来执行Servlet的service方法。当这个线程正在执行的时候，容器收到另一个请求，调度者线程将从线程池中选出另外一个工作组线程来服务这个新的请求，容器并不关心这个请求是否访问的是同一个Servlet还是另一个Servlet。当容器收到对同一个Servlet的多个请求的时候，那这个servlet的service方法将在多线程中并发的执行。</p><h4 id="SimpleDateFormat线程不安全"><a href="#SimpleDateFormat线程不安全" class="headerlink" title="SimpleDateFormat线程不安全"></a>SimpleDateFormat线程不安全</h4><p>SimpleDateFormat里会保持一个Calendar变量，如果每个线程都操作这个变量，就会发生线程安全问题</p><p><a href="http://blog.csdn.net/zq602316498/article/details/40263083" target="_blank" rel="noopener">http://blog.csdn.net/zq602316498/article/details/40263083</a></p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。</p><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>当在某个线程创建一个新的线程，这个线程有与创建线程相同的优先级。<br><code>setPriority(int newPriority)</code></p><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>当一个jvm启动，这里通常有一个非守护线程(运行main函数)，但是jvm只剩下守护线程，守护线程不会支持jvm继续运行。</p><p><code>setDaemon(boolean on)</code></p><h4 id="线程API"><a href="#线程API" class="headerlink" title="线程API"></a>线程API</h4><p><img src="java-thread/threadapi.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前线程可转让cpu控制权，让优先级更高的线程运行(有可能还是自己)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Thread.yield()</span><br><span class="line"><span class="comment">//线程暂停一段时间，但在等待的时候仍然会持有monitor或者锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Thread.sleep()</span><br><span class="line"><span class="comment">//在一个线程中调用other.join(),将等待other执行完后才继续本线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">join</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//判断是否有中断信息，同时也会对中断状态进行复位</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>interrupt方法通过修改了被调用线程的中断状态来告知那个线程, 说它被中断了. 对于非阻塞中的线程, 只是改变了中断状态, 即Thread.isInterrupted()将返回true; 对于可取消的阻塞状态中的线程, 比如等待在这些函数上的线程, Thread.sleep(), Object.wait(), Thread.join(), 这个线程收到中断信号后, 会抛出InterruptedException，提前结束阻塞状态，但是run方法不会中断，需要自己实现中断方法执行。不是所有的阻塞方法收到中断后都可以取消阻塞状态, 输入和输出流类会阻塞等待 I/O 完成，但是它们不抛出 InterruptedException，而且在被中断的情况下也不会退出阻塞状态. 同时会把中断状态置回为true.但调用Thread.interrupted()会对中断状态进行复位。只有方法上有InterruptedException，才能进行中断，比如使用synchronized时线程获取锁而受阻，就无法中断，但是因为lock的lock方法上有这个异常，所以lock锁的阻塞可以中断。</p></blockquote><p><a href="http://blog.csdn.net/canot/article/details/51087772" target="_blank" rel="noopener">http://blog.csdn.net/canot/article/details/51087772</a></p><h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><p><img src="java-thread/ThreadLife.png" alt></p><ul><li><strong>NEW</strong> ：还未开始的线程</li><li><strong>RUNNABLE</strong> ：正在被jvm执行，但可能正在等待CPU调度</li><li><strong>BLOCKED</strong> ： 等待获取锁以进入同步方法/代码块</li><li><strong>WAITING</strong> ： 线程在这个状态下等待其他线程执行特定操作。通常为当执行以下操作后<br><code>Object.wait</code>,<br><code>Thread.join</code>,<br><code>LockSupport.park</code></li><li><strong>TIMED_WAITING</strong> ：当线程开始等待一段时间。通常为当执行以下操作后<br><code>Thread.sleep(long)</code>,<br><code>Object.wait(long)</code>,<br><code>Thread.join(long)</code>,<br><code>LockSupport.parkNanos</code>,<br><code>LockSupport.parkUntil</code></li><li><strong>TERMINATED</strong> ：线程已结束</li></ul><h4 id="操作系统的线程状态"><a href="#操作系统的线程状态" class="headerlink" title="操作系统的线程状态"></a>操作系统的线程状态</h4><ul><li>就绪</li><li>运行</li><li>阻塞</li></ul><h4 id="线程阻塞"><a href="#线程阻塞" class="headerlink" title="线程阻塞"></a>线程阻塞</h4><p>java线程到阻塞状态，需要从用户态转换到核心态，所以会耗费很多处理器时间，要尽量减少阻塞状态的频繁切换</p><h4 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h4><ul><li>线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务</li><li>进程是资源分配的最小单位，线程是程序执行的最小单位</li><li>一个进程是一个独立的运行环境，它可以被看作一个程序或者一个应用</li><li>一个进程下的所有线程共用一片内存，但是它们有各自的栈内存</li></ul><h4 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h4><ul><li>继承Thread，覆盖run()方法，创建线程对象并用start()方法启动线程</li><li>实现Runnable接口来创建Thread线程</li><li>通过实现Callable接口来创建Thread线程</li><li>借助框架程序 可用Executor框架来创建线程池，线程池可以限制线程的数量并且可以回收再利用这些线程</li></ul><h4 id="start-和-run-方法区别"><a href="#start-和-run-方法区别" class="headerlink" title="start() 和 run() 方法区别"></a>start() 和 run() 方法区别</h4><p>start()方法被用来启动新创建的线程，使该被创建的线程状态变为可运行状态。<br>当你调用run()方法的时候，没有新的线程启动，只会是在原来的线程中调用，这个方法同普通类的run方法一样。</p><h3 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待 / 通知机制"></a>等待 / 通知机制</h3><p><strong>wait()</strong>：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁； </p><p><strong>sleep()</strong>：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常； </p><p><strong>notify()</strong>：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；notify之后，需要把自身的同步代码块执行完毕后才会让出锁。</p><p><strong>notityAll()</strong>：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；</p><p><strong>join()</strong>：当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到执行join的线程运行结束，当前线程再由阻塞状态变为就绪状态。</p><p><strong>join(long millis)</strong>：millis的时间过后，当前线程转入阻塞状态，直到执行join的线程运行结束</p><h4 id="举例-6"><a href="#举例-6" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by j_zhan on 2016/7/6.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotify</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread A = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Wait(), <span class="string">"wait thread"</span>);</span><br><span class="line">        A.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        Thread B = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Notify(), <span class="string">"notify thread"</span>);</span><br><span class="line">        B.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Wait</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread() + <span class="string">" flag is true"</span>);</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">" flag is false"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Notify</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">7</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其相关方法定义在java.lang.Object上，线程A在获取锁后调用了对象lock的wait方法进入了等待状态，线程B调用对象lock的notifyAll()方法，线程A收到通知后从wait方法处返回继续执行，线程B对共享变量flag的修改对线程A来说是可见的。</p><p><strong>Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?</strong><br>sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，<strong>但是对象的锁依然保持</strong>，因此休眠时间结束后会自动恢复。wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果<strong>线程重新获得对象的锁就可以进入就绪状态</strong></p><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ol><li>使用wait()、notify()和notifyAll()时需要先对调用对象加锁，调用wait()方法后会释放锁。</li><li>调用wait()方法之后，线程状态由RUNNING变为WAITING，并将当前线程放置到对象的等待队列中。</li><li>notify()或notifyAll()方法调用后，等待线程不会立刻从wait()中返回，需要等该线程释放锁之后，才有机会获取锁之后从wait()返回。</li><li>notify()方法将等待队列中的一个等待线程从等待队列中移动到同步队列中；notifyAll()方法则是把等待队列中的所有线程都移动到同步队列中；被移动的线程状态从WAITING变为BLOCKED。</li><li>该线程从wait()方法返回的前提是获得了调用对象的锁。</li></ol><h3 id="Runnable介绍"><a href="#Runnable介绍" class="headerlink" title="Runnable介绍"></a>Runnable介绍</h3><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()).start();</span><br></pre></td></tr></table></figure><h3 id="Callable介绍"><a href="#Callable介绍" class="headerlink" title="Callable介绍"></a>Callable介绍</h3><h4 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;()),<span class="string">"线程名"</span>).start();</span><br></pre></td></tr></table></figure><h4 id="Callable和Runnable的区别"><a href="#Callable和Runnable的区别" class="headerlink" title="Callable和Runnable的区别"></a>Callable和Runnable的区别</h4><ol><li>Callable 的 call() 方法可以返回值和抛出异常，而 Runnable 的 run() 方法没有这些功能。</li><li>Callable 可以使用ExecutorService</li></ol><h3 id="Future介绍"><a href="#Future介绍" class="headerlink" title="Future介绍"></a>Future介绍</h3><p>Future是一个接口，定义了Future对于具体的Runnable或者Callable任务的执行结果进行取消、查询任务是否被取消，查询是否完成、获取结果。</p><h4 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//试图取消对此任务的执行。如果任务已完成、或已取消，或者由于某些其他原因而无法取消，则此尝试将失败。当调用 cancel() 时，如果调用成功，而此任务尚未启动，则此任务将永不运行。如果任务已经启动，则 mayInterruptIfRunning 参数确定是否应该以试图停止任务的方式来中断执行此任务的线程。此方法返回后，对 isDone() 的后续调用将始终返回 true。如果此方法返回 true，则对 isCancelled() 的后续调用将始终返回 true。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果在任务正常完成前将其取消，则返回 true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果任务已完成，则返回 true。 可能由于正常终止、异常或取消而完成，在所有这些情况中，此方法都将返回 true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如有必要，等待计算完成，然后获取其结果。如果运算尚未完成get方法将会阻塞</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如有必要，最多等待为使计算完成所给定的时间之后，获取其结果（如果结果可用）</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="举例-7"><a href="#举例-7" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"做一些耗时的任务..."</span>);</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureSimpleDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        Future&lt;String&gt; future = executorService.submit(<span class="keyword">new</span> MyCallable());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"dosomething..."</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"得到异步任务返回结果："</span> + future.get());</span><br><span class="line">        System.out.println(<span class="string">"Completed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FutureTask介绍"><a href="#FutureTask介绍" class="headerlink" title="FutureTask介绍"></a>FutureTask介绍</h3><p>FutureTask的父类是RunnableFuture，而RunnableFuture继承了Runnbale和Futrue这两个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.callable = callable;</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>FutureTask最终都是执行Callable类型的任务。</li><li>如果构造函数参数是Runnable，会被Executors.callable方法转换为Callable类型。</li></ol><h4 id="举例-8"><a href="#举例-8" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableAndFuture</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Callable&lt;Integer&gt; callable = <span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        FutureTask&lt;Integer&gt; future = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(callable);</span><br><span class="line">        <span class="keyword">new</span> Thread(future).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);<span class="comment">// 可能做一些事情</span></span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li>提高线程的可管理性。</li></ol><h4 id="线程池接口图"><a href="#线程池接口图" class="headerlink" title="线程池接口图"></a>线程池接口图</h4><p><img src="java-thread/Executor.png" alt></p><h4 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h4><p>普通类 Executors 里面调用的就是 ThreadPoolExecutor。</p><p>Executors提供了一系列工厂方法用于创先线程池，返回的线程池都实现了ExecutorService接口。ScheduleExecutorService代表可在指定延迟后或周期性地执行线程任务的线程池。</p><h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p><img src="java-thread/ThreadPool.png" alt></p><h5 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         threadFactory, defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>corePoolSize</strong>：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。<br><strong>maximumPoolSize</strong>：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。<br><strong>keepAliveTime</strong>： 线程池维护线程所允许的空闲时间<br><strong>unit</strong>： 线程池维护线程所允许的空闲时间的单位<br><strong>workQueue</strong>： 线程池所使用的缓冲队列<br><strong>threadFactory</strong>：线程工厂，它是一个接口，用来为线程池创建新线程的<br><strong>handler</strong>： 超出线程池容量以及队列长度后拒绝任务的策略</p></blockquote><p>针对handler，线程池提供了4种策略：<br>1、AbortPolicy：直接抛出异常，默认策略；<br>2、CallerRunsPolicy：用调用者所在的线程来执行任务；<br>3、DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；<br>4、DiscardPolicy：直接丢弃任务；</p><h4 id="corePoolSize-和-maximumPoolSize"><a href="#corePoolSize-和-maximumPoolSize" class="headerlink" title="corePoolSize 和 maximumPoolSize"></a>corePoolSize 和 maximumPoolSize</h4><p><img src="java-thread/corePoolSize.png" alt></p><h5 id="具体说明-2"><a href="#具体说明-2" class="headerlink" title="具体说明"></a>具体说明</h5><p>提交任务，线程池中的线程数可以增长至corePoolSize，之后继续提交任务将暂存至队列中，如果队列满，则看是否能继续增长线程数至maximumPoolSize，超出后将进行拒绝策略处理。如果采用无界队列，那么maximumPoolSize将失效，线程池中的线程最多就是corePoolSize个线程工作</p><h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><h5 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h5><p>一个基于数组实现的有界阻塞队列。ArrayBlockingQueue在生产者放入和消费者获取数据时共用一个锁对象，所以说对一个queue而言并没有做到真正的并行</p><h5 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h5><p>SynchronousQueue无数据缓冲区，相当于生产者和消费者直接交换数据而不通过任何中介。SynchronousQueue中每一个put操作必须等待一个take操作，否则不能继续添加元素。如果没有空闲线程，就构造一个新的线程加入线程池，如果线程池里没有空闲线程，则不会进行任务，newCachedThreadPool采用的便是这种策略</p><h5 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h5><p>一个基于链表实现的有界阻塞队列。不同于ArrayBlockingQueue，其对生产者和消费者端分别采用了独立的锁来控制数据同步，因此提高了队列的并发性能。需要注意的是此队列的默认长度是Integer,MAX_VALUE，即无限大小，当生产者速度过快时，系统内存有被耗尽的风险，newFixedThreadPool采用的便是这种策略</p><h5 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h5><p>元素是按照顺序储存的，一个具有优先级的无限阻塞队列</p><h5 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h5><p>队列中的每个元素实现了Delayed接口，只有当指定的延迟时间到了，才能够从队列中获取该元素。DelayQueue可以用于保存将要执行的任务和执行时间，newScheduledThreadPool采用的便是这种策略，也是无界</p><h4 id="Executors-提供四种线程池"><a href="#Executors-提供四种线程池" class="headerlink" title="Executors 提供四种线程池"></a>Executors 提供四种线程池</h4><h5 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h5><p>一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。<strong>对于执行很多短期异步任务的程序而言，这个线程池通常可提高程序性能。</strong>调用 execute() 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。如果是长期异步任务，就不要用这种，因为每当创建新线程执行任务，会导致一定的系统开销，<strong>所以，使用该线程池时，一定要注意控制并发的任务数，否则创建大量的线程可能导致严重的性能问题。</strong>线程池的线程数可达到Integer.MAX_VALUE，即2147483647</p><h5 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h5><p>一个单线程池，也就是该线程池只有一个线程在工作，所有的任务是串行执行的，如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它，此线程池保证所有任务的执行顺序按照任务的提交顺序执行</p><h5 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h5><p>创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小，线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程</p><h5 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h5><p>初始化的线程池可以在指定的时间内周期性的执行所提交的任务，在实际的业务场景中可以使用该线程池定期的同步数据。</p><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService0 = Executors.newCachedThreadPool();</span><br><span class="line">ExecutorService executorService1 = Executors.newSingleThreadExecutor();  </span><br><span class="line">ExecutorService executorService2 = Executors.newFixedThreadPool(<span class="number">10</span>);  </span><br><span class="line">ExecutorService executorService3 = Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h4 id="ExecutorService方法"><a href="#ExecutorService方法" class="headerlink" title="ExecutorService方法"></a>ExecutorService方法</h4><ol><li>execute(Runnable)  </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">executorService.execute(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Asynchronous task"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li>submit(Runnable)  </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Future future = executorService.submit(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Asynchronous task"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li>submit(Callable) </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Future future = executorService.submit(<span class="keyword">new</span> Callable()&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Asynchronous Callable"</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Callable Result"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="4"><li>submit(new FutureTask<integer>(Callable))</integer></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">submit(<span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Callable()&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Asynchronous Callable"</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Callable Result"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><ol start="5"><li><p>invokeAny(…)  </p><p>方法 invokeAny() 接收一个包含 Callable 对象的集合作为参数。调用该方法不会返回 Future 对象，而是返回集合中某一个 Callable 对象的结果，而且无法保证调用之后返回的结果是哪一个 Callable，只知道它是这些 Callable 中一个执行结束的 Callable 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newSingleThreadExecutor();  </span><br><span class="line"></span><br><span class="line">Set&lt;Callable&lt;String&gt;&gt; callables = <span class="keyword">new</span> HashSet&lt;Callable&lt;String&gt;&gt;();  </span><br><span class="line"></span><br><span class="line">callables.add(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Task 1"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);  </span><br><span class="line">callables.add(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Task 2"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);  </span><br><span class="line">callables.add(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Task 3"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line">String result = executorService.invokeAny(callables);  </span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"result = "</span> + result);  </span><br><span class="line"></span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure></li><li><p>invokeAll(…)</p><p>方法 invokeAll() 会调用存在于参数集合中的所有 Callable 对象，并且返回一个包含 Future 对象的集合，你可以通过这个返回的集合来管理每个 Callable 的执行结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个线程数固定大小为10的线程池</span></span><br><span class="line">ExecutorService executorService = Executors.newFixedThreadPool( <span class="number">10</span> ) ;</span><br><span class="line">List&lt;Callable&lt;String&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;() ;</span><br><span class="line"><span class="comment">//创建第一个 Callable</span></span><br><span class="line">Callable&lt;String&gt; callable1 = <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.d( <span class="string">"callable 1 线程是： "</span>+ Thread.currentThread().getName()  );</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"执行完了 callable 1"</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//创建第二个 Callable</span></span><br><span class="line">Callable&lt;String&gt; callable2 = <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.d( <span class="string">"callable 2 线程是： "</span>+ Thread.currentThread().getName()  );</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"执行完了 callable 2"</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">list.add(callable1 ) ;</span><br><span class="line">list.add(callable2 ) ;</span><br><span class="line">List&lt;Future&lt;String&gt;&gt; result;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    result = executorService.invokeAll( list );</span><br><span class="line">    <span class="keyword">for</span> (Future&lt;String&gt; future : result) &#123;</span><br><span class="line">        Log.d( <span class="string">"结果是： "</span>+ future.get()  );</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭线程池</span></span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure></li><li><p>shutdown()</p><p>不会立即的终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务</p></li><li><p>shutdownNow() </p><p>立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务</p></li></ol><h4 id="ForkJoinPool介绍"><a href="#ForkJoinPool介绍" class="headerlink" title="ForkJoinPool介绍"></a>ForkJoinPool介绍</h4><p>ForkJoinPool同ThreadPoolExecutor一样，也实现了Executor和ExecutorService接口。它使用了一个无限队列来保存需要执行的任务，而线程的数量则是通过构造函数传入，如果没有向构造函数中传入希望的线程数量，那么当前计算机可用的CPU数量会被设置为线程数量作为默认值。</p><p>ForkJoinPool的另外一个特性是它能够实现工作窃取(Work Stealing)，在该线程池的每个线程中会维护一个队列来存放需要被执行的任务。当线程自身队列中的任务都执行完毕后，它会从别的线程中拿到未被执行的任务并帮助它执行。</p><p>可以把一个任务拆分成多个小任务，然后再把多个小任务合成总的计算结果</p><ul><li>分解（Fork）操作：当需要将一个任务拆分成更小的多个任务时，在框架中执行这些任务</li><li>合并（Join）操作：当一个主任务等待其创建的多个子任务的完成执行</li><li>ForkJoinPool类的execute(ForkJoinTask<t> task)方法是异步调用的</t></li><li>ForkJoinPool类的invoke(ForkJoinTask<t> task)方法则是同步调用的</t></li></ul><p><img src="java-thread/ForkJoinPool.png" alt></p><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><table><thead><tr><th>区别</th><th>Executor</th><th>ForkJoinPool</th></tr></thead><tbody><tr><td>接受的对象</td><td>Runnable和Callable的实例</td><td>Runnable、Callable和ForkJoinTask的实例</td></tr><tr><td>调度模式</td><td>处于后面等待中的任务需要等待前面任务执行后才有机会被执行，是否被执行取决于具体的调度规则</td><td>采用work-stealing模式帮助其他线程执行任务，即ExcuteService解决的是并发问题，而ForkJoinPool解决的是并行问题。</td></tr></tbody></table><h5 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h5><p>ForkJoinTask继承与Future接口，代表一个可以并行、合并的任务.</p><p>它有两个抽象子类：RecursiveAction和RecursiveTask。</p><ul><li>RecursiveTask代表有返回值的任务</li><li>RecursiveAction代表没有返回值的任务</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;多线程之前了解的有点乱，特此整理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;锁类型&quot;&gt;&lt;a href=&quot;#锁类型&quot; class=&quot;headerlink&quot; title=&quot;锁类型&quot;&gt;&lt;/a&gt;锁类型&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;公平性：&lt;/s
      
    
    </summary>
    
      <category term="Java" scheme="https://barry215.github.io/categories/Java/"/>
    
    
      <category term="java" scheme="https://barry215.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java集合深入详解</title>
    <link href="https://barry215.github.io/2017/03/26/java-collection/"/>
    <id>https://barry215.github.io/2017/03/26/java-collection/</id>
    <published>2017-03-26T07:11:09.000Z</published>
    <updated>2017-10-09T14:01:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前对于Java的集合类仅仅只是一笔带过，现在我打算仔细地介绍一遍</p></blockquote><p><img src="java-collection/collection.png" alt></p><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>ArrayList是<strong>基于数组</strong>实现的，是一个动态数组，其容量能自动增长，默认容量是10。当容量不足时，就设置新的容量为旧的容量的1.5倍加1，如果还不够就直接令新容量设置为传入的参数。容量增加的方法是用<code>System.arraycopy(oldArrays,old_start_index,newArrays,new_start_index,oldArrays.length)</code>方法把原来的元素拷贝进一个新数组。</p><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>ArrayList是<strong>非线程安全</strong>的，只能用在单线程环境下，多线程环境下可以考虑用<code>Collections.synchronizedList(List list)</code>函数返回一个线程安全的ArrayList类，也可以使用<code>concurrent</code>并发包下的<code>CopyOnWriteArrayList</code>类。</p><h4 id="不安全性"><a href="#不安全性" class="headerlink" title="不安全性"></a>不安全性</h4><p>ArrayList在添加一个元素的时候，它可能会有两步来完成：1. 在 Items[Size] 的位置存放此元素；2. 增大 Size 的值。在单线程运行的情况下，如果 Size = 0，添加一个元素后，此元素在位置 0，而且 Size=1；而如果是在多线程情况下，比如有两个线程，线程 A 先将元素存放在位置 0。但是此时 CPU 调度线程A暂停，线程 B 得到运行的机会。线程B也向此 ArrayList 添加元素，因为此时 Size 仍然等于 0 （注意哦，我们假设的是添加一个元素是要两个步骤哦，而线程A仅仅完成了步骤1），所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，都增加 Size 的值。那好，我们来看看 ArrayList 的情况，元素实际上只有一个，存放在位置 0，而 Size 却等于 2。这就是“线程不安全”了</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>因为基于数组，有下标索引，所以便于遍历查找</p><h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><p>ArrayList不适合频繁插入或删除元素，因为这样会大量地移动元素<br>不是线程安全，如果两个线程同时插入，会导致size不一致情况</p><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p>ArrayList中允许元素为null</p><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><h4 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h4><p>写时<strong>加锁</strong>，当添加一个元素的时候，将原来的容器进行copy，复制出一个新的容器，然后在新的容器里面写，写完之后再将原容器的引用指向新的容器，而读的时候是读旧容器的数据，所以可以进行并发的读，但这是一种共享锁的策略。 </p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>CopyOnWriteArrayList适合使用在读操作远远大于写操作的场景里，比如缓存。</p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><h4 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h4><p>LinkedList是基于<strong>双向循环链表</strong>实现的，且头结点中不存放数据，除了可以当做链表来操作外，它还可以当做栈、队列和双端队列来使用。</p><p><img src="java-collection/LinkedList.png" alt></p><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//元素结点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取元素方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过一次二分法的遍历</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//源码中先将index与长度size的一半比较，如果index&lt;size/2，就只从位置0往后遍历到位置index处，而如果index&gt;size/2，就只从位置size往前遍历到位置index处。这样可以减少一部分不必要的遍历，从而提高一定的效率（实际上效率还是很低）。</span></span><br></pre></td></tr></table></figure><h4 id="线程安全-1"><a href="#线程安全-1" class="headerlink" title="线程安全"></a>线程安全</h4><p>LinkedList是<strong>非线程安全</strong>的，只在单线程下适合使用。</p><h4 id="不安全性-1"><a href="#不安全性-1" class="headerlink" title="不安全性"></a>不安全性</h4><p>进队列操作</p><ul><li>获取链表的链尾【断点】</li><li>插入元素</li><li>把链尾指向当前元素</li></ul><p>出队列操作</p><ul><li>获取头结点【断点】</li><li>获取头结点的下一个节结点</li><li>把头结点指针指向下一个节点</li><li>然后把之前的头结点置null，next指针也置null</li></ul><p>多线程下，进队列操作会出现元素覆盖的问题<br>出队列会出现头结点没有后续元素，其实是因为头结点被置null了</p><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><p>因为基于链表，所以方便增加和删除元素，也方便获取第一和最后元素</p><p>LinkedList实现了Queue接口，因此也可以作为栈、队列和双端队列来使用</p><h4 id="局限性-1"><a href="#局限性-1" class="headerlink" title="局限性"></a>局限性</h4><p>不适合遍历查找</p><h4 id="备注-1"><a href="#备注-1" class="headerlink" title="备注"></a>备注</h4><p>LinkedList实现了Serializable接口，因此它支持序列化，能够通过序列化传输，实现了Cloneable接口，能被克隆。</p><p>LinkedList中允许元素为null</p><h3 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h3><h4 id="实现原理-3"><a href="#实现原理-3" class="headerlink" title="实现原理"></a>实现原理</h4><p>ArrayDeque继承于AbstractCollection，底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即循环数组（circular array），也就是说数组的任何一点都可能被看作起点或者终点</p><h4 id="线程安全-2"><a href="#线程安全-2" class="headerlink" title="线程安全"></a>线程安全</h4><p>ArrayDeque是非线程安全的</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>Queue是一个接口，当需要使用栈和队列时首选ArrayDeque（双端队列）了，次选是LinkedList，不推荐使用Stack</p><p>下表列出了Deque与Queue相对应的接口：</p><table><thead><tr><th>Queue Method</th><th>Equivalent Deque Method</th><th>说明</th></tr></thead><tbody><tr><td><code>add(e)</code></td><td><code>addLast(e)</code></td><td>向队尾插入元素，失败则抛出异常</td></tr><tr><td><code>offer(e)</code></td><td><code>offerLast(e)</code></td><td>向队尾插入元素，失败则返回<code>false</code></td></tr><tr><td><code>remove()</code></td><td><code>removeFirst()</code></td><td>获取并删除队首元素，失败则抛出异常</td></tr><tr><td><code>poll()</code></td><td><code>pollFirst()</code></td><td>获取并删除队首元素，失败则返回<code>null</code></td></tr><tr><td><code>element()</code></td><td><code>getFirst()</code></td><td>获取但不删除队首元素，失败则抛出异常</td></tr><tr><td><code>peek()</code></td><td><code>peekFirst()</code></td><td>获取但不删除队首元素，失败则返回<code>null</code></td></tr></tbody></table><p>下表列出了Deque与Stack对应的接口：</p><table><thead><tr><th>Stack Method</th><th>Equivalent Deque Method</th><th>说明</th></tr></thead><tbody><tr><td><code>push(e)</code></td><td><code>addFirst(e)</code></td><td>向栈顶插入元素，失败则抛出异常</td></tr><tr><td>无</td><td><code>offerFirst(e)</code></td><td>向栈顶插入元素，失败则返回<code>false</code></td></tr><tr><td><code>pop()</code></td><td><code>removeFirst()</code></td><td>获取并删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td><code>pollFirst()</code></td><td>获取并删除栈顶元素，失败则返回<code>null</code></td></tr><tr><td><code>peek()</code></td><td><code>peekFirst()</code></td><td>获取但不删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td><code>peekFirst()</code></td><td>获取但不删除栈顶元素，失败则返回<code>null</code></td></tr></tbody></table><h4 id="备注-2"><a href="#备注-2" class="headerlink" title="备注"></a>备注</h4><p>ArrayDeque不允许放入<code>null</code>元素</p><h4 id="参考路径"><a href="#参考路径" class="headerlink" title="参考路径"></a>参考路径</h4><p><a href="https://zhuanlan.zhihu.com/p/24752167?refer=dreawer" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24752167?refer=dreawer</a></p><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><h4 id="实现原理-4"><a href="#实现原理-4" class="headerlink" title="实现原理"></a>实现原理</h4><p>Vector也是基于数组实现的，是一个动态数组，其容量能自动增长。总体上和ArrayList一样，只是很多方法都加入了synchronized同步语句，来保证线程安全</p><h4 id="线程安全-3"><a href="#线程安全-3" class="headerlink" title="线程安全"></a>线程安全</h4><p>Vector是<strong>线程安全</strong>的</p><h4 id="优势-2"><a href="#优势-2" class="headerlink" title="优势"></a>优势</h4><p>因为很多方法加了synchronized，所以可以用于多线程环境</p><p>和ArrayList一样便于遍历查找</p><h4 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h4><p>和ArrayList一样，不适合频繁插入或删除元素</p><h4 id="备注-3"><a href="#备注-3" class="headerlink" title="备注"></a>备注</h4><p>Vector中允许元素为nul</p><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><h4 id="实现原理-5"><a href="#实现原理-5" class="headerlink" title="实现原理"></a>实现原理</h4><p>HashSet是对HashMap的简单包装，对HashSet的函数调用都会转换成合适的HashMap方法</p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><h4 id="实现原理-6"><a href="#实现原理-6" class="headerlink" title="实现原理"></a>实现原理</h4><p>TreeSet是对TreeMap的简单包装，对TreeSet的函数调用都会转换成合适的TreeMap方法</p><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><h4 id="实现原理-7"><a href="#实现原理-7" class="headerlink" title="实现原理"></a>实现原理</h4><p>LinkedHashSet是对LinkedHashMap的简单包装，对LinkedHashSet的函数调用都会转换成合适的LinkedHashMap方法</p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h4 id="实现原理-8"><a href="#实现原理-8" class="headerlink" title="实现原理"></a>实现原理</h4><p>HashMap是基于数组和链表实现的，每一个元素是一个key-value对，其内部通过单链表解决冲突问题，容量不足（超过了阀值）时，创建原来HashMap两倍大小的数组。默认初始容量是16，默认加载因子为0.75 。</p><p>HashMap的key做hash算法，并将hash值映射到内存地址（数组索引），直接取得key对应的value</p><p>HashMap把新元素放在链表的队首</p><p><img src="java-collection/HashMap.png" alt></p><h4 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据结点</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line"><span class="keyword">final</span> K key;</span><br><span class="line">V value;</span><br><span class="line">Node&lt;K,V&gt; next;</span><br><span class="line">Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hash = hash;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.next = next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//储存元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果table为null，inflate 该table</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当key为null，调用putForNullKey方法，保存null与table第一个位置中，这是HashMap允许为null的原因</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="comment">// 根据key的hashcode进行计算hash值。</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 根据指定hash值在找到对应的table中的索引。 </span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 若 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素。</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="comment">// 判断该条链上是否有hash值相同的(key相同)</span></span><br><span class="line">        <span class="comment">// 若存在相同，则直接覆盖value，返回旧value</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果i索引处的Entry为null，表明此处还没有Entry。</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 将key、value添加到i索引处。</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当我们向HashMap中put元素的时候，先根据key的hashCode的值计算hash值，根据hash值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。addEntry(hash, key, value, i)方法根据计算出的hash值，将key-value对放在数组table的i索引处。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 如果 Map 中的 key-value 对的数量超过了极限</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span>!=table[bucketIndex]))&#123;</span><br><span class="line">        <span class="comment">// 把 table 对象的长度扩充到原来的2倍。 </span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据bucketIndex 获取对应的 Entry  </span></span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">// 将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry </span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 如果key = null时，返回null对应的value值。</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)  </span><br><span class="line">        <span class="keyword">return</span> getForNullKey(); </span><br><span class="line">    <span class="comment">// 根据key的hashcode值做hash获取对应的值</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.hashCode()); </span><br><span class="line">    <span class="comment">// 根据指定hash值在找到对应的table中的索引，并根据索引获取该处的Entry，通过循环不断遍历 e 元素的下一个元素。</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];  e != <span class="keyword">null</span>;  e = e.next) &#123;  </span><br><span class="line">        Object k;  </span><br><span class="line">        <span class="comment">// 判断e元素的hash与hash是否相等，如果相等并且e元素与key相等则返回e的原则的value</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))  </span><br><span class="line">            <span class="keyword">return</span> e.value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 如果指定hash值在找到对应的table中的索引，并根据索引获取该处的Entry的为null，则返回null。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//从HashMap中get元素时，首先计算key的hashCode，通过IndexFor(hash,table.length)找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。</span></span><br></pre></td></tr></table></figure><h4 id="线程安全-4"><a href="#线程安全-4" class="headerlink" title="线程安全"></a>线程安全</h4><p>HashMap是<strong>非线程安全</strong>的</p><blockquote><p>HashMap 在并发时可能出现的问题主要是两方面,首先如果多个线程同时使用put方法添加元素，而且假设正好存在两个 put 的 key 发生了碰撞(根据 hash 值计算的 bucket 一样)，那么根据 HashMap 的实现，这两个 key 会添加到数组的同一个位置，这样最终就会发生其中一个线程的 put 的数据被覆盖。第二就是如果多个线程同时检测到元素个数超过数组大小* loadFactor ，这样就会发生多个线程同时对 Node 数组进行扩容，都在重新计算元素位置以及复制数据，但是最终只有一个线程扩容后的数组会赋给 table，也就是说其他线程的都会丢失，并且各自线程 put 的数据也丢失。</p></blockquote><p>可以以下三种方法来实现线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; hashtable = <span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line">Map&lt;String, String&gt; synchronizedHashMap = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;String, String&gt;());</span><br><span class="line">Map&lt;String, String&gt; concurrentHashMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><h4 id="1-8实现"><a href="#1-8实现" class="headerlink" title="1.8实现"></a>1.8实现</h4><p>采用数组+链表+红黑树，如果链表长度超过8，则改为红黑树</p><ol><li>先判断当前位置有没有值，没有则新建node插入</li><li>如果有值，则判断是否为同一个key，若是则更新，如不是再判断是否是红黑树</li><li>若还不是同一个key，遍历链表更新节点或在链表最后插入新节点</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="备注-4"><a href="#备注-4" class="headerlink" title="备注"></a>备注</h4><p>key最好是不可变的final对象，因为如果key可变，那下次获取键值对的时候，key的hashcode会和之前的不一样，而导致无法取出，如果一定要用可变对象的话，那就要重写这个对象的hashcode方法</p><p>HashMap可以key和value均可以为null</p><h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><h4 id="实现原理-9"><a href="#实现原理-9" class="headerlink" title="实现原理"></a>实现原理</h4><p>HashMap和Hashtable采用的是相同的存储机制，因此两者的实现基本一致。</p><h4 id="与HashMap区别"><a href="#与HashMap区别" class="headerlink" title="与HashMap区别"></a>与HashMap区别</h4><ul><li>HashMap可以key和value均可以为null，而HashTable则不可以。Hashtable不允许null的值，Hashtable的key为null的时候，HashTable调用put方法时，直接抛出NullPointerException。其它细微的差别还有，比如初始化Entry数组的大小等等。</li><li>Hashtable是线程安全的，内部的方法基本都是synchronized。HashMap则不是线程安全的。</li><li>Hashtable中的hash数组默认是11，增加方式old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。</li><li>哈希值的使用不同，HashTable直接使用对象的hashCode，而HashMap重新实现哈hash方法</li><li>HashMap继承的是AbstractMap，Hashtable继承的是Dictionary</li></ul><h4 id="线程安全-5"><a href="#线程安全-5" class="headerlink" title="线程安全"></a>线程安全</h4><p>Hashtable是<strong>线程安全</strong>的，因为方法上加了synchronized</p><h4 id="局限-1"><a href="#局限-1" class="headerlink" title="局限"></a>局限</h4><p>因为加了synchronized同步锁，获得的是对象锁，所以没有得到锁的其他线程会一直等待，影响效率</p><h4 id="备注-5"><a href="#备注-5" class="headerlink" title="备注"></a>备注</h4><p>Hashtable不能有null值</p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><h4 id="实现原理-10"><a href="#实现原理-10" class="headerlink" title="实现原理"></a>实现原理</h4><h5 id="1-7实现"><a href="#1-7实现" class="headerlink" title="1.7实现"></a>1.7实现</h5><p>ConcurrentHashMap是使用了分段锁技术来保证线程安全的，底层采用数组+链表+红黑树的存储结构。分段锁技术：它相当于把一个数组分成好几段，每一段是一个 segment ，里面包含了一小段的hash table。segment继承了ReentrantLock，所以有自己的锁。当一个线程占用锁来访问其中一段数据的时候，其他段的数据也能被其他线程访问。但是如果有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。这里的按顺序是为了避免死锁。</p><blockquote><p>在ConcurrentHashMap内部，段数组是final的，并且其成员变量实际上也是final的，但是，仅仅是将数组声明为final的并不保证数组成员也是final的，这需要实现上的保证。这可以确保不会出现死锁，因为获得锁的顺序是固定的。</p><p>如果不是final，则有可能一段数据里包含了另一段数据的引用</p></blockquote><p><img src="java-collection/ConcurrentHashMap.png" alt></p><blockquote><p><strong>Segment继承ReentrantLock用来充当锁的角色</strong>，每个 Segment 对象守护每个散列映射表的若干个桶。</p><p>HashEntry 用来封装映射表的键 / 值对；</p><p>每个桶是由若干个 HashEntry 对象链接起来的链表。</p></blockquote><h4 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;  </span><br><span class="line">     <span class="keyword">final</span> K key;  </span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">int</span> hash;  </span><br><span class="line">     <span class="keyword">volatile</span> V value;    <span class="comment">//为了确保读操作能够看到最新的值，将value设置成volatile，这避免了加锁</span></span><br><span class="line">     <span class="keyword">final</span> HashEntry&lt;K,V&gt; next;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-8实现-1"><a href="#1-8实现-1" class="headerlink" title="1.8实现"></a>1.8实现</h5><p>1.8中放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现，底层依然采用数组+链表+红黑树的存储结构。当一个链表中的元素达到8个时，会调用treeifyBin()方法把链表结构转化成红黑树结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="java-collection/ConcurrentHashMap2.png" alt></p><h4 id="put实现"><a href="#put实现" class="headerlink" title="put实现"></a>put实现</h4><p>当执行put方法插入数据时，根据key的hash值，在Node数组中找到相应的位置，实现如下：</p><p>1、如果相应位置的Node还未初始化，则通过CAS插入相应的数据；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>, <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">        <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    binCount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">        K ek;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((ek = e.key) == key ||</span><br><span class="line">             (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">            oldVal = e.val;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                e.val = value;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;K,V&gt; pred = e;</span><br><span class="line">        <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">    Node&lt;K,V&gt; p;</span><br><span class="line">    binCount = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        oldVal = p.val;</span><br><span class="line">        <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">            p.val = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">        treeifyBin(tab, i);</span><br><span class="line">    <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount；</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p><strong>与Hashtable的区别</strong></p><p>Hashtable的synchronized是针对整张Hash表的，即每次锁住整张表让线程独占</p><p>ConcurrentHashMap分段锁是针对一部分数据的，segment数组里的每个元素单独加锁</p><p><strong>与Collections.synchronizedMap()的区别</strong></p><p>Collections.synchronizedMap()和Hashtable一样，实现上在调用map所有方法时，都对整个map进行同步，而ConcurrentHashMap的实现却更加精细，它对map中的所有桶加了锁。</p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><h4 id="实现原理-11"><a href="#实现原理-11" class="headerlink" title="实现原理"></a>实现原理</h4><p>TreeMap实现了SortedMap接口，底层通过红黑树实现，也就是说会按照key的大小顺序对Map中的元素进行排序，key大小的评判可以通过其本身的自然顺序，也可以通过构造时传入的比较器（Comparator）</p><p><code>get(Object key)</code>方法根据指定的<code>key</code>值返回对应的<code>value</code>，该方法调用了<code>getEntry(Object key)</code>得到相应的<code>entry</code>，然后返回<code>entry.value</code>。因此<code>getEntry()</code>是算法的核心。算法思想是根据<code>key</code>的自然顺序（或者比较器顺序）对二叉查找树进行查找，直到找到满足<code>k.compareTo(p.key) == 0</code>的<code>entry</code>。</p><p><code>put(K key, V value)</code>方法是将指定的<code>key</code>, <code>value</code>对添加到<code>map</code>里。该方法首先会对<code>map</code>做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>getEntry()</code>方法；如果没有找到则会在红黑树中插入新的<code>entry</code>，如果插入之后破坏了红黑树的约束条件，还需要进行调整（旋转，改变某些节点的颜色）。</p><h4 id="线程安全-6"><a href="#线程安全-6" class="headerlink" title="线程安全"></a>线程安全</h4><p>TreeMap是<strong>非线程安全</strong>的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SortedMap m = Collections.synchronizedSortedMap(<span class="keyword">new</span> TreeMap(...));</span><br></pre></td></tr></table></figure><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p><img src="java-collection/red-black-tree.png" alt></p><p><strong>红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一倍</strong>。具体来说，红黑树是满足如下条件的二叉查找树（binary search tree）：</p><ol><li>每个节点要么是红色，要么是黑色。</li><li>根节点必须是黑色</li><li>红色节点不能连续（也即是，红色节点的孩子和父亲都不能是红色）。</li><li>对于每个节点，从该点至<code>null</code>（树尾端）的任何路径，都含有相同个数的黑色节点。</li><li>每个空叶子节点必须是黑色的；</li></ol><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><h4 id="实现原理-12"><a href="#实现原理-12" class="headerlink" title="实现原理"></a>实现原理</h4><p>LinkedHashMap是HashMap的直接子类，二者唯一的区别是LinkedHashMap在HashMap的基础上，采用双向链表的形式将所有entry连接起来，这样是为保证元素的迭代顺序跟插入顺序相同。</p><p><img src="java-collection/LinkedHashMap.png" alt></p><h4 id="优势-3"><a href="#优势-3" class="headerlink" title="优势"></a>优势</h4><p>迭代LinkedHashMap时不需要像HashMap那样遍历整个table，而只需要直接遍历header指向的双向链表即可</p><p>该双向链表的迭代顺序就是entry的插入顺序</p><h4 id="备注-6"><a href="#备注-6" class="headerlink" title="备注"></a>备注</h4><p>LinkedHashMap允许null值</p><p>本文参考：</p><p><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/0-Introduction.md" target="_blank" rel="noopener">https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/0-Introduction.md</a></p><p><a href="http://www.jianshu.com/u/90ab66c248e6" target="_blank" rel="noopener">http://www.jianshu.com/u/90ab66c248e6</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;之前对于Java的集合类仅仅只是一笔带过，现在我打算仔细地介绍一遍&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;java-collection/collection.png&quot; alt&gt;&lt;/p&gt;
&lt;h3 id=&quot;ArrayList&quot;
      
    
    </summary>
    
      <category term="Java" scheme="https://barry215.github.io/categories/Java/"/>
    
    
      <category term="java" scheme="https://barry215.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Spring IOC&amp;&amp;AOP</title>
    <link href="https://barry215.github.io/2017/03/22/spring-review/"/>
    <id>https://barry215.github.io/2017/03/22/spring-review/</id>
    <published>2017-03-22T07:23:51.000Z</published>
    <updated>2017-08-09T12:57:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><h4 id="Spring-IOC-Inverse-of-Control"><a href="#Spring-IOC-Inverse-of-Control" class="headerlink" title="Spring IOC (Inverse of Control)"></a>Spring IOC (Inverse of Control)</h4><p>思想：</p><p>IOC意思是控制反转，控制权由对象本身转向容器，由容器根据配置文件去创建实例并创建各个实例之间的依赖关系</p><p>这个容器叫做bean工厂；在Spring中，bean工厂创建的各个实例称作bean </p><p>原理：</p><p>利用java反射，就是在Spring运行时，bean工厂根据Spring的xml配置文件或扫描指定包下注解来动态地生成一个实例，并且调用对象里的方法的</p><p>Spring支持三种依赖注入方式，分别是属性（Setter方法）注入，接口注入和构造注入。</p><p>一般不采用接口注入，因为注入对象还必须实现某个接口，比较麻烦。</p><p><a href="http://www.paymoon.com:8001/index.php/2017/01/06/why-spring-ioc-mechanism-is-not-new-but-reflection/" target="_blank" rel="noopener">http://www.paymoon.com:8001/index.php/2017/01/06/why-spring-ioc-mechanism-is-not-new-but-reflection/</a></p><h4 id="SpringMVC运行原理"><a href="#SpringMVC运行原理" class="headerlink" title="SpringMVC运行原理"></a>SpringMVC运行原理</h4><ol><li>客户端请求提交到DispatcherServlet</li><li>由DispatcherServlet控制器查询HandlerMapping，找到并分发到指定的Controller中。</li><li>Controller调用业务逻辑处理后，返回ModelAndView</li><li>DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图</li><li>视图负责将结果显示到客户端</li></ol><p><img src="spring-review/SpringMVC.jpg" alt></p><p><a href="http://www.cnblogs.com/xiaoxing/p/5836835.html" target="_blank" rel="noopener">http://www.cnblogs.com/xiaoxing/p/5836835.html</a></p><h4 id="Resource跟-Autowired比较"><a href="#Resource跟-Autowired比较" class="headerlink" title="@Resource跟@Autowired比较"></a>@Resource跟@Autowired比较</h4><p>上面介绍中Controller中注入userService或者 Service层里面注入dao都是用@Resource标签，其实也可以使用@Autowired来替代，但是建议使用@Resource。下面说说这2者的区别：</p><ol><li><p>@Autowired和@Resource都可以用来装配bean，都可以写在字段上，或者方法上。</p></li><li><p>@Autowired属于Spring的；@Resource为JSR-250标准的注释，属于J2EE的。</p></li><li><p>@Autowired默认按类型装配，默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，例如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"baseDao"</span>)</span><br><span class="line"><span class="keyword">private</span> BaseDao baseDao;</span><br></pre></td></tr></table></figure></li><li><p>@Resource，默认按照名称进行装配，名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取字段名进行安装名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span>(name=<span class="string">"baseDao"</span>)</span><br><span class="line"><span class="keyword">private</span> BaseDao baseDao;</span><br></pre></td></tr></table></figure><ol start="5"><li>之所以推荐使用@Resource，因为这个注解是属于J2EE的，减少了与spring的耦合。这样代码看起就比较优雅。</li></ol></li></ol><p><a href="http://www.jianshu.com/p/135693f589c4" target="_blank" rel="noopener">http://www.jianshu.com/p/135693f589c4</a></p><h4 id="SpringAOP原理"><a href="#SpringAOP原理" class="headerlink" title="SpringAOP原理"></a>SpringAOP原理</h4><p>AOP是通过动态代理来实现的，有两种常用的技术，一是<code>JDK的动态代理</code>，二是<code>CGLIB</code>，而无论是前者还是后者，都是生成动态生成类的字节码来实现的。<code>JDK的动态代理只能处理接口实现的方法</code>，而CGLIB则没有这个限制。因为字节码是动态生成的，所以可以在生成的字节码当中，在目标方法前后插入定义好的方法的调用。</p><p>切面（Aspect）：一个关注点的模块化，这个关注点可能会横切多个对象。 在Spring  AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @Aspect 注解（@AspectJ风格）来实现</p><p>连接点（Joinpoint）： 在程序执行过程中某个特定的点，比如某方法调用的时候或者处理异常的时候。在Spring AOP中，一个连接点 总是  代表一个方法的执行。通过声明一个org.aspectj.lang.JoinPoint类型的参数可以使通知（Advice）的主体部分获得连接点信息。</p><p>通知（Advice）：在切面的某个特定的连接点（Joinpoint）上执行的动作。通知有各种类型，其中包括“around”、“before”和“after”等通知。通知的类型将在后面部分进行讨论。许多AOP框架，包括Spring，都是以拦截器做通知模型，并维护一个以连接点为中心的拦截器链。</p><p>切入点（Pointcut）：匹配连接点（Joinpoint）的断言。通知和一个切入点表达式关联，并在满足这个切入点的连接点上运行（例如，当执行某个特定名称的方法时）。切入点表达式如何和连接点匹配是AOP的核心：Spring缺省使用AspectJ切入点语法。</p><p>引入（Introduction）： （也被称为内部类型声明（inter-type declaration））。声明额外的方法或者某个类型的字段。  Spring允许引入新的接口（以及一个对应的实现）到任何被代理的对象。例如，你可以使用一个引入来使bean实现 IsModified  接口，以便简化缓存机制。</p><p>织入（Weaving）：  把切面（aspect）连接到其它的应用程序类型或者对象上，并创建一个被通知（advised）的对象。这些可以在编译时（例如使用AspectJ编译器），类加载时和运行时完成。  Spring和其他纯Java AOP框架一样，在运行时完成织入。</p><p>通知的类型：</p><p>前置通知（Before advice）： 在某连接点（join  point）之前执行的通知，但这个通知不能阻止连接点前的执行（除非它抛出一个异常）。</p><p>返回后通知（After returning advice）： 在某连接点（join  point）正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。</p><p>抛出异常后通知（After throwing advice）： 在方法抛出异常退出时执行的通知。</p><p>后通知（After (finally) advice）： 当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。</p><p>环绕通知（Around Advice）： 包围一个连接点（join  point）的通知，如方法调用。这是最强大的一种通知类型。环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它们自己的返回值或抛出异常来结束执行。</p><p>原接口：很多种方法定义</p><p>委托类：实现接口的方法</p><p>代理类：引用委托类实现方法的同时，额外做一些事情</p><h5 id="AOP速学路径"><a href="#AOP速学路径" class="headerlink" title="AOP速学路径"></a>AOP速学路径</h5><p><a href="https://segmentfault.com/a/1190000007469982" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007469982</a></p><h4 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h4><p>使用java反射机制，在运行期时，插入自定义的方法调用</p><p>具体是通过Proxy和InvocationHandler这个<strong>接口</strong>来实现的，InvocationHandler里有invoke(Object proxy, Method method, Object[] args)这个方法，它可以有委托类方法和参数引用，所以可以在invoke方法中围绕着委托类的方法做一些前置、后置操作</p><p>Proxy会用newProxyInstance(ClassLoader,interfaces,InvocationHandlerImpl)生成<strong>动态代理类</strong>，这个代理类会实现委托类的接口，当执行代理类的方法时，实际上是执行InvocationHandler的invoke方法，所以就实现了之前我们的前置、后置操作</p><h5 id="动态代理速学路径"><a href="#动态代理速学路径" class="headerlink" title="动态代理速学路径"></a>动态代理速学路径</h5><p><a href="https://segmentfault.com/a/1190000007089902" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007089902</a></p><p><a href="http://blog.csdn.net/qqHJQS/article/details/53402493" target="_blank" rel="noopener">http://blog.csdn.net/qqHJQS/article/details/53402493</a></p><h4 id="CGLIB代理"><a href="#CGLIB代理" class="headerlink" title="CGLIB代理"></a>CGLIB代理</h4><p>cglib是用asm框架生成的字节码文件，而且生成的<strong>动态代理类</strong>是<strong>委托类</strong>的子类，所以委托类不能是final</p><p>利用MethodInterceptor接口的intercept方法，可以在这个方法里调用invokeSuper来操作委托类方法，同样就可以围绕着委托类的方法做一些前置、后置操作</p><p>速学路径：</p><p><a href="http://www.deanwangpro.com/2017/02/08/aop-in-java/" target="_blank" rel="noopener">http://www.deanwangpro.com/2017/02/08/aop-in-java/</a></p><p><strong><a href="http://blog.csdn.net/panyongcsd/article/details/53204719" target="_blank" rel="noopener">http://blog.csdn.net/panyongcsd/article/details/53204719</a></strong></p><p><a href="http://www.importnew.com/20732.html" target="_blank" rel="noopener">http://www.importnew.com/20732.html</a></p><p><a href="http://www.jianshu.com/p/d35e46f27187" target="_blank" rel="noopener">http://www.jianshu.com/p/d35e46f27187</a></p><h4 id="Spring-AOP应用场景"><a href="#Spring-AOP应用场景" class="headerlink" title="Spring AOP应用场景"></a>Spring AOP应用场景</h4><p>性能检测，访问控制，日志管理，事务</p><h4 id="Spring-Bean的作用域区别"><a href="#Spring-Bean的作用域区别" class="headerlink" title="Spring Bean的作用域区别"></a>Spring Bean的作用域区别</h4><p>Spring容器中的bean可以分为5个范围。所有范围的名称都是自说明的，但是为了避免混淆，还是让我们来解释一下：</p><ol><li>singleton：这种bean范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个bean的实例，单例的模式由bean factory自身来维护。</li><li>prototype：原形范围与单例范围相反，为每一个bean请求提供一个实例。</li><li>request：在请求bean范围内会每一个来自客户端的网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。</li><li>Session：与请求范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。</li><li>global-session：global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。</li></ol><p>全局作用域与Servlet中的session作用域效果相同。</p><h4 id="Spring中的单例Beans是线程安全的吗"><a href="#Spring中的单例Beans是线程安全的吗" class="headerlink" title="Spring中的单例Beans是线程安全的吗"></a>Spring中的单例Beans是线程安全的吗</h4><p>不是，Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的Spring bean并没有可变的状态(比如Service类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。如果你的bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。Spring原理上使用ThreadLocal来保证单例安全的。</p><p>最浅显的解决办法就是将单态bean的作用域由<strong>“singleton</strong>”变更为“<strong>prototype</strong>”。<br>当然，scope的值不止这两种，还包括了request,session 等。但用的最多的还是singleton单态，prototype多态。<br>singleton表示该bean全局只有一个实例，Spring中bean的scope默认也是singleton.<br>prototype表示该bean在每次被注入的时候，都要重新创建一个实例，这种情况适用于有状态的Bean.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Spring&quot;&gt;&lt;a href=&quot;#Spring&quot; class=&quot;headerlink&quot; title=&quot;Spring&quot;&gt;&lt;/a&gt;Spring&lt;/h3&gt;&lt;h4 id=&quot;Spring-IOC-Inverse-of-Control&quot;&gt;&lt;a href=&quot;#Spring-I
      
    
    </summary>
    
      <category term="Spring" scheme="https://barry215.github.io/categories/Spring/"/>
    
    
      <category term="java" scheme="https://barry215.github.io/tags/java/"/>
    
      <category term="spring" scheme="https://barry215.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>查找和排序算法大杂烩</title>
    <link href="https://barry215.github.io/2017/03/11/algorithm-review/"/>
    <id>https://barry215.github.io/2017/03/11/algorithm-review/</id>
    <published>2017-03-11T01:45:30.000Z</published>
    <updated>2017-08-03T15:30:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>很多算法都一知半解，就是现在，一个个击破它们吧！</p></blockquote><h2 id="链表算法"><a href="#链表算法" class="headerlink" title="链表算法"></a>链表算法</h2><h3 id="反转单链"><a href="#反转单链" class="headerlink" title="反转单链"></a>反转单链</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单链表的转置,循环方法</span></span><br><span class="line">Node* reverseByLoop(Node *head)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == NULL || head-&gt;next == NULL)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    Node *pre = NULL;</span><br><span class="line">    Node *next = NULL;</span><br><span class="line">    <span class="keyword">while</span>(head != NULL)   <span class="comment">//总体来说就是进来一个，指向新链表一次，后面的链表由next保存</span></span><br><span class="line">    &#123;</span><br><span class="line">        next = head-&gt;next;<span class="comment">//保存之后的链表</span></span><br><span class="line">        head-&gt;next = pre; <span class="comment">//使当前的点指向之前生成的新链表</span></span><br><span class="line">        pre = head;       <span class="comment">//新链表指向当前点形成更新的链表</span></span><br><span class="line">        head = next;      <span class="comment">//当前元素变成之前的next的第一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表倒数第k个节点"><a href="#链表倒数第k个节点" class="headerlink" title="链表倒数第k个节点"></a>链表倒数第k个节点</h3><blockquote><p>设置两个指针 p1、p2，首先 p1 和 p2 都指向 head，然后 p2 向前走 k 步，这样 p1 和 p2 之间就间隔 k 个节点，最后 p1 和 p2 同时向前移动，直至 p2 走到链表末尾</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  ListNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">    <span class="keyword">this</span>.val = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>||k&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode pre=head;</span><br><span class="line">    ListNode last=head;       </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(pre.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        pre=pre.next;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pre.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      pre = pre.next;</span><br><span class="line">      last=last.next;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>速学路径</p><p><a href="http://hanhailong.com/2016/02/25/Java%E5%8F%8D%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8%E5%AE%9E%E6%88%98/" target="_blank" rel="noopener">Java反转单链表实战</a></p><p><a href="http://wuchong.me/blog/2014/03/25/interview-link-questions/" target="_blank" rel="noopener">逆序、求倒数第K个节点，判断是否有环</a></p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>数组方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackArray</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;<span class="comment">//用数组实现</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top; <span class="comment">//栈顶指针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> size = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StackArray</span><span class="params">()</span></span>&#123;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        top = -<span class="number">1</span>; <span class="comment">//栈空的时候 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//压栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> element)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(top == size-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StackOverflowError();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            array[++top] = element;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//弹栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(top == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[top--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(top == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链表方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedStack</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Stack</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//不用容器或者数组等数据结构存储节点</span></span><br><span class="line">    <span class="comment">//Node定义一个节点类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">U</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> U item; <span class="comment">//存储的data</span></span><br><span class="line">        <span class="keyword">private</span> Node&lt;U&gt; next; <span class="comment">//类似指针</span></span><br><span class="line">        Node()&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node(U item, Node&lt;U&gt; next)&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> item == <span class="keyword">null</span> &amp;&amp; next == <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; top ; <span class="comment">//栈顶指针</span></span><br><span class="line">    LinkedStack()&#123;</span><br><span class="line">        top = <span class="keyword">new</span> Node&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//弹栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.isEmpty() == <span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        &#125;</span><br><span class="line">        T result = top.item;</span><br><span class="line">        <span class="keyword">if</span>(!top.end())</span><br><span class="line">        &#123;</span><br><span class="line">            top = top.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//压栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T element)</span></span>&#123;</span><br><span class="line">        top = <span class="keyword">new</span> Node&lt;T&gt;(element, top);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  top.end();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.isEmpty() == <span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        &#125;</span><br><span class="line">        T result = top.item;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考路径</p><p><a href="https://segmentfault.com/a/1190000002516799" target="_blank" rel="noopener">Stack的三种实现（数组，容器，链表）</a></p><h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><h3 id="字符串逆转"><a href="#字符串逆转" class="headerlink" title="字符串逆转"></a>字符串逆转</h3><p>数组方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">strReverseWithArray2</span><span class="params">(String string)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(string==<span class="keyword">null</span>||string.length()==<span class="number">0</span>)<span class="keyword">return</span> string;</span><br><span class="line">       <span class="keyword">int</span> length = string.length();</span><br><span class="line">       <span class="keyword">char</span> [] array = string.toCharArray();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length/<span class="number">2</span>;i++)&#123;</span><br><span class="line">           array[i] = string.charAt(length-<span class="number">1</span>-i);</span><br><span class="line">           array[length-<span class="number">1</span>-i] = string.charAt(i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> String(array);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>栈方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">strReverseWithStack</span><span class="params">(String string)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(string==<span class="keyword">null</span>||string.length()==<span class="number">0</span>)<span class="keyword">return</span> string;</span><br><span class="line">       Stack&lt;Character&gt; stringStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       <span class="keyword">char</span> [] array = string.toCharArray();</span><br><span class="line">       <span class="keyword">for</span>(Character c:array)&#123;</span><br><span class="line">           stringStack.push(c);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> length = string.length();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">           array[i] = stringStack.pop();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> String(array);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>参考路径</p><p><a href="http://www.cnblogs.com/JohnTsai/p/5606719.html" target="_blank" rel="noopener">http://www.cnblogs.com/JohnTsai/p/5606719.html</a></p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>二叉树遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序递归遍历</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrderRe</span><span class="params">(Node node,List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(list==<span class="keyword">null</span>)&#123;</span><br><span class="line">        list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        inOrderRe(node.left,list);</span><br><span class="line">    &#125;</span><br><span class="line">    list.add(node.data);</span><br><span class="line">    <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        inOrderRe(node.right,list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="comment">//根节点不为空</span></span><br><span class="line">        root = node;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node current = root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.data &lt;= current.data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                current.left = node;</span><br><span class="line">                size++;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                current.right = node;</span><br><span class="line">                size++;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h3><p>搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// while循环</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end = arr.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> mid;</span><br><span class="line"><span class="keyword">while</span>(start &lt;= end)&#123;</span><br><span class="line">mid = (start + end) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (val &lt; arr[mid]) &#123;</span><br><span class="line">end = mid - <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (val &gt; arr[mid]) &#123;</span><br><span class="line">start = mid + <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归版本</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> val,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (val &lt; arr[mid]) &#123;</span><br><span class="line">binary_search(arr,val,start,mid-<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (val &gt; arr[mid]) &#123;</span><br><span class="line">binary_search(arr,val,mid+<span class="number">1</span>,end);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><ol><li>若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>任意节点的左、右子树也分别为二叉查找树；</li><li>没有键值相等的节点。</li></ol><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>升序是从小到大</p><p>降序是从大到小</p><p>速学路径</p><p><a href="http://www.jianshu.com/p/bbb7c838880f" target="_blank" rel="noopener">http://www.jianshu.com/p/bbb7c838880f</a></p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>说白了就是循环一遍，每个元素都按大小插到前面的序列里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] list)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = list.length;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">int</span> j =  <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = list[i];</span><br><span class="line">        <span class="comment">//假如temp比前面的值小，则将前面的值后移</span></span><br><span class="line">        <span class="keyword">for</span>(j = i ; j &gt; <span class="number">0</span> &amp;&amp; temp &lt; list[j-<span class="number">1</span>] ; j --)</span><br><span class="line">        &#123;</span><br><span class="line">        list[j] = list[j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        list[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>有间隔的直接插入排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="comment">//每次将步长缩短为原来的一半</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> increment = data.length / <span class="number">2</span>; increment &gt; <span class="number">0</span>; increment /= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = increment; i &lt; data.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = data[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &gt;= increment; j -= increment)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(temp &lt; data[j - increment])<span class="comment">//如想从小到大排只需修改这里</span></span><br><span class="line">                &#123;</span><br><span class="line">                    data[j] = data[j - increment];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            data[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆是一颗完全二叉树，除了最底层之外，每一层都是满的。</p><p>它有最大堆和最小堆之分</p><p>堆中每个父节点的元素值都<strong>大于等于</strong>其孩子结点的堆就是一个最大堆</p><p>那么相反，每个父节点都<strong>小于等于</strong>其孩子结点的堆就是一个最小堆</p><p>堆排序的时间复杂度为O(n*logn)</p><p>他的排序方法就是先形成一个堆</p><p>父节点和两个子节点进行比较，把最大的那个换到父节点上，然后那两个子节点就递归这个比较和交换</p><p>然后开始排序了</p><p>把堆顶的元素拿下，并且把最小的元素换到堆顶，然后形成一个新堆，然后循环这样的操作，取出来的元素就有序了</p><blockquote><p><strong>满二叉树</strong>：除了叶结点外<strong>每一个结点都有左右子叶</strong>且叶结点都处在最底层的二叉树；</p><p><strong>完全二叉树</strong>：只有最下面的两层结点度小于2，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树；</p><p>堆是一种完全二叉树或者近似完全二叉树</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arrayLength=a.length;</span><br><span class="line">    <span class="comment">//循环建堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arrayLength-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//建堆</span></span><br><span class="line">        buildMaxHeap(a,arrayLength-<span class="number">1</span>-i);</span><br><span class="line">        <span class="comment">//交换堆顶和最后一个元素</span></span><br><span class="line">        swap(a,<span class="number">0</span>,arrayLength-<span class="number">1</span>-i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对data数组从0到lastIndex建大顶堆</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> lastIndex)</span></span>&#123;</span><br><span class="line">    <span class="comment">//从lastIndex处节点（最后一个节点）的父节点开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=(lastIndex-<span class="number">1</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="comment">//k保存正在判断的节点</span></span><br><span class="line">        <span class="keyword">int</span> k=i;</span><br><span class="line">        <span class="comment">//如果当前k节点的子节点存在</span></span><br><span class="line">        <span class="keyword">while</span>(k*<span class="number">2</span>+<span class="number">1</span>&lt;=lastIndex)&#123;</span><br><span class="line">            <span class="comment">//k节点的左子节点的索引</span></span><br><span class="line">            <span class="keyword">int</span> biggerIndex=<span class="number">2</span>*k+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//如果biggerIndex小于lastIndex，即biggerIndex+1代表的k节点的右子节点存在</span></span><br><span class="line">            <span class="keyword">if</span>(biggerIndex&lt;lastIndex)&#123;</span><br><span class="line">                <span class="comment">//若果右子节点的值较大</span></span><br><span class="line">                <span class="keyword">if</span>(data[biggerIndex]&lt;data[biggerIndex+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="comment">//biggerIndex总是记录较大子节点的索引</span></span><br><span class="line">                    biggerIndex++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果k节点的值小于其较大的子节点的值</span></span><br><span class="line">            <span class="keyword">if</span>(data[k]&lt;data[biggerIndex])&#123;</span><br><span class="line">                <span class="comment">//交换他们</span></span><br><span class="line">                swap(data,k,biggerIndex);</span><br><span class="line">                <span class="comment">//将biggerIndex赋予k，开始while循环的下一次循环，重新保证k节点的值大于其左右子节点的值</span></span><br><span class="line">                k=biggerIndex;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=data[i];</span><br><span class="line">    data[i]=data[j];</span><br><span class="line">    data[j]=tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>将两个已经排序的序列合并成一个序列的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] gb_sort(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="comment">// 左边</span></span><br><span class="line">        gb_sort(nums, low, mid);</span><br><span class="line">        <span class="comment">// 右边</span></span><br><span class="line">        gb_sort(nums, mid + <span class="number">1</span>, high);</span><br><span class="line">        <span class="comment">// 左右归并</span></span><br><span class="line">        merge(nums, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = low;<span class="comment">// 左指针</span></span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;<span class="comment">// 右指针</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 把较小的数先移到新数组中</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; nums[j]) &#123;</span><br><span class="line">            temp[k++] = nums[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把左边剩余的数移入数组</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        temp[k++] = nums[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把右边边剩余的数移入数组</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">        temp[k++] = nums[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把新数组中的数覆盖nums数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k2 = <span class="number">0</span>; k2 &lt; temp.length; k2++) &#123;</span><br><span class="line">        nums[k2 + low] = temp[k2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>空间复杂度</strong></p><p>平均时间复杂度是logn，所以根据遍历次数，推出空间复杂度也是logn</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><blockquote><p>从需要排序的数里面随便找出一个，然后，把<strong>比这个数小的放在这个数左边，比这个数大的放在这个数右边，一样大的和这个数放在一起</strong>，最后，<strong>左右两边各自重复上述过程</strong>，直到左边或右边只剩下一个数（或零个数）无法继续为止。</p></blockquote><p>取出第一个元素为基准，然后有两个指针，一个指向第二个元素，一个指向最后一个元素，先从最后一个进行比较，如果比基准大的话，就向前移向下一个，如果元素比基准小的话，就把那个元素替换到前面那个空位，然后前面的指针开始比较，如果比基准小，就移向向后下一个，如果比基准大，就替换到后面的那个空位。然后又变成后指针开始移动比较。这样的比较替换后，除去基准的那个元素，再分成前后两组，然后进行这个过程，直到前后两个指针重合，排序也就结束了。</p><p>快速排序不稳定，它的时间复杂度最好时为O(n<em>logn)，最差情况是O(n\</em>n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key = arr[start];</span><br><span class="line">    <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end &amp;&amp; key &lt;= arr[end])&#123;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[start] = arr[end];</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end &amp;&amp; key &gt;= arr[start])&#123;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[end] = arr[start];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[start] = key;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; end)&#123;</span><br><span class="line">        <span class="keyword">int</span> middle = partition(arr,start,end);</span><br><span class="line">        sort(arr,<span class="number">0</span>,middle-<span class="number">1</span>);</span><br><span class="line">        sort(arr,middle+<span class="number">1</span>,end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化</strong></p><p>三值取中法： 待排序序列的前(第一个位置)、中(中间位置)、后(最后一个位置)三个记录中的中间值(按大小排序)作为枢轴</p><p><strong>空间复杂度</strong></p><p>就空间复杂度来说，主要是递归造成的栈空间的使用，最好情况，递归的深度为log2n，其空间复杂度也就为O(logn)，最坏情况，需要进行n‐1递归调用，其空间复杂度为O(n)，平均情况，空间复杂度也为O(logn)。</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ol><li>比较相邻的元素。 如果第一个比第二个大，就交换他们两个。</li><li>从开始第一对到结尾的最后一对，每对相邻元素都作同样的工作，。 这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> swaped;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        swaped = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> f = <span class="number">0</span>;f&lt;arr.length-i-<span class="number">1</span>;f++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[f] &gt; arr[f+<span class="number">1</span>])&#123;</span><br><span class="line">                temp = arr[f];</span><br><span class="line">                arr[f] = arr[f+<span class="number">1</span>];</span><br><span class="line">                arr[f+<span class="number">1</span>] = temp;</span><br><span class="line">                swaped = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!swaped)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>首先在序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max_index;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        max_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> f = <span class="number">0</span>;f&lt;arr.length-i;f++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[f] &gt; arr[max_index])&#123;</span><br><span class="line">                max_index = f;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[arr.length-i-<span class="number">1</span>];</span><br><span class="line">        arr[arr.length-i-<span class="number">1</span>] = arr[max_index];</span><br><span class="line">        arr[max_index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">radix_sort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] &gt; max)&#123;</span><br><span class="line">            max = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (max&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        max /= <span class="number">10</span>;</span><br><span class="line">        time++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> max_sd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] tempArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][array.length];</span><br><span class="line">    <span class="keyword">int</span>[] order = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">while</span> (m&lt;time)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sd = (array[i] / n) % <span class="number">10</span>;</span><br><span class="line">            tempArr[sd][order[sd]] = array[i];</span><br><span class="line">            order[sd]++;</span><br><span class="line">            <span class="keyword">if</span> (sd&gt;max_sd)&#123;</span><br><span class="line">                max_sd = sd;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;order[i] != <span class="number">0</span> &amp;&amp; j&lt;order[i];j++)&#123;</span><br><span class="line">                array[k++] = tempArr[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            order[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n *= <span class="number">10</span>;</span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        m++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>Algorithm</th><th>Average</th><th>Best</th><th>Worst</th><th>extra space</th><th>stable</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(N^2)</td><td>O(N)</td><td>O(N^2)</td><td>O(1)</td><td>稳定</td></tr><tr><td>直接插入排序</td><td>O(N^2)</td><td>O(N)</td><td>O(N^2)</td><td>O(1)</td><td>稳定</td></tr><tr><td>希尔排序</td><td>O(N^1.3)</td><td>O(N)</td><td>O(N^2)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>简单选择排序</td><td>O(N^2)</td><td>O(N^2)</td><td>O(N^2)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>快速排序</td><td>O(NlogN)</td><td>O(NlogN)</td><td>O(N^2)</td><td>O(logN)~O(N^2)</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(NlogN)</td><td>O(NlogN)</td><td>O(NlogN)</td><td>O(N)</td><td>稳定</td></tr><tr><td>堆排序</td><td>O(NlogN)</td><td>O(NlogN)</td><td>O(NlogN)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>计数排序</td><td>O(d*(N+K))</td><td>O(d*(N+K))</td><td>O(d*(N+K))</td><td>O(N+K)</td><td>稳定</td></tr></tbody></table><h3 id="排序方法的选择"><a href="#排序方法的选择" class="headerlink" title="排序方法的选择"></a>排序方法的选择</h3><ol><li>若n较小(如n≤50)，可采用直接插入或直接选择排序。</li></ol><p>　当记录规模较小时，直接插入排序较好；否则因为直接选择移动的记录数少于直接插人，应选直接选择排序为宜。</p><ol start="2"><li>若文件初始状态基本有序(指正序)，则应选用直接插人、冒泡或随机的快速排序为宜；</li><li>若n较大，则应采用时间复杂度为O(nlgn)的排序方法：快速排序、堆排序或归并排序。</li></ol><p>快速排序是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；<br>堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况。这两种排序都是不稳定的;<br>若要求排序稳定，则可选用归并排序。</p><blockquote><p>但本章介绍的从单个记录起进行两两归并的排序算法并不值得提倡，通常可以将它和直接插入排序结合在一起使用。先利用直接插入排序求得较长的有序子文件，然后再两两归并之。因为直接插入排序是稳定 的，所以改进后的归并排序仍是稳定的。</p></blockquote><p>参考资料：</p><p><a href="https://segmentfault.com/a/1190000004994003?f=tt&amp;hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#articleHeader22" target="_blank" rel="noopener">排序总结</a></p><p><a href="https://segmentfault.com/a/1190000002595152" target="_blank" rel="noopener">常用排序算法总结(性能+代码)</a></p><p><a href="https://segmentfault.com/a/1190000009069319" target="_blank" rel="noopener">Java常用的八种排序算法与代码实现精解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;很多算法都一知半解，就是现在，一个个击破它们吧！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;链表算法&quot;&gt;&lt;a href=&quot;#链表算法&quot; class=&quot;headerlink&quot; title=&quot;链表算法&quot;&gt;&lt;/a&gt;链表算法&lt;/h2&gt;&lt;h3 id
      
    
    </summary>
    
      <category term="Algorithm" scheme="https://barry215.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="https://barry215.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>网络知识复习</title>
    <link href="https://barry215.github.io/2017/03/09/network-review/"/>
    <id>https://barry215.github.io/2017/03/09/network-review/</id>
    <published>2017-03-09T13:56:50.000Z</published>
    <updated>2017-08-03T16:10:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TCP，HTTP和Socket区别"><a href="#TCP，HTTP和Socket区别" class="headerlink" title="TCP，HTTP和Socket区别"></a>TCP，HTTP和Socket区别</h3><ul><li>tcp是传输协议，http是超文本传输协议</li><li>tcp是传输层协议，http是应用层协议</li><li>http连接是基于tcp的三次握手的</li><li>Socket连接过程分为三个步骤：服务器监听，客户端请求，连接确认</li><li>Socket可以支持不同的传输层协议（TCP或UDP）</li><li>Socket是对TCP/IP协议的封装</li></ul><h3 id="网页访问过程"><a href="#网页访问过程" class="headerlink" title="网页访问过程"></a>网页访问过程</h3><p>DNS域名解析 –&gt; 发起TCP的三次握手 –&gt; 建立TCP连接后发起http请求 –&gt; 服务器响应http请求，浏览器得到html代码 –&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） –&gt; 浏览器对页面进行渲染呈现给用户</p><h3 id="GET和POST区别"><a href="#GET和POST区别" class="headerlink" title="GET和POST区别"></a>GET和POST区别</h3><h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><p>特点：</p><ul><li>GET是放在浏览器地址栏上请求的，对用户可见</li><li>GET语义是从指定的服务器中获取数据</li><li>GET请求有长度限制</li><li>GET请求能够被缓存</li><li>GET请求不安全</li></ul><h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><p>特点：</p><ul><li>POST请求对用户不可见</li><li>POST语义是提交数据给指定的服务器处理 </li><li>POST请求没有长度限制</li><li>POST请求不能被缓存</li><li>POST请求比GET请求安全</li></ul><h4 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h4><table><thead><tr><th>区别</th><th>GET</th><th>POST</th></tr></thead><tbody><tr><td><strong>点击返回/刷新按钮</strong></td><td>没有影响</td><td>数据会重新发送（浏览器将会提示用户“数据被从新提交”）</td></tr><tr><td><strong>添加书签</strong></td><td>可以</td><td>不可以</td></tr><tr><td><strong>缓存</strong></td><td>可以</td><td>不可以</td></tr><tr><td><strong>编码类型(Encoding type)</strong></td><td>application/x-www-form-urlencoded</td><td>application/x-www-form-urlencoded or multipart/form-data. 请为二进制数据使用multipart编码</td></tr><tr><td><strong>历史记录</strong></td><td>有</td><td>没有</td></tr><tr><td><strong>长度限制</strong></td><td>有</td><td>没有</td></tr><tr><td><strong>数据类型限制</strong></td><td>只允许ASCII字符类型</td><td>没有限制。允许二进制数据</td></tr><tr><td><strong>安全性</strong></td><td>查询字符串会显示在地址栏的URL中，不安全，请不要使用GET请求提交敏感数据</td><td>因为数据不会显示在地址栏中，也不会缓存下来或保存在浏览记录中，所以看POST求情比GET请求安全，但也不是最安全的方式。如需要传送敏感数据，请使用加密方式传输</td></tr><tr><td><strong>可见性</strong></td><td>查询字符串显示在地址栏的URL中，可见</td><td>查询字符串不会显示在地址栏中，不可见</td></tr></tbody></table><h4 id="其他HTTP请求方式"><a href="#其他HTTP请求方式" class="headerlink" title="其他HTTP请求方式"></a>其他HTTP请求方式</h4><table><thead><tr><th><strong>方式</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>HEAD</td><td>与GET请求类似，不同在与服务器只返回HTTP头部信息，没有页面内容</td></tr><tr><td>PUT</td><td>上传指定URL的描述</td></tr><tr><td>DELETE</td><td>删除指定资源</td></tr><tr><td>OPTIONS</td><td>返回服务器支持的HTTP方法</td></tr><tr><td>CONNECT</td><td>转换为透明TCP/IP隧道的连接请求</td></tr></tbody></table><h3 id="TCP三次握手四次挥手"><a href="#TCP三次握手四次挥手" class="headerlink" title="TCP三次握手四次挥手"></a>TCP三次握手四次挥手</h3><p>简单形容的话，建立连接时的三次握手：</p><ol><li>客户端 —&gt; 服务器，客户端请求连接</li><li>服务器 —&gt; 客户端，服务器确认连接信息</li><li>客户端 —&gt; 服务器，客户端确认连接信息，开始连接</li></ol><p>断开连接时的四次握手：</p><ol><li>A —&gt; B，A请求断开连接</li><li>B —&gt; A，B确认请求并准备断开连接</li><li>B —&gt; A，B关闭连接并通知A</li><li>A —&gt; B，A确认关闭</li></ol><p><strong>三次握手：</strong></p><p><img src="network-review/tcp3.jpeg" alt></p><p><strong>第一次（syn=1，seq=x）：</strong></p><p>客户端向服务器发送syn=1，seq=client_isn的数据包，客户端进入SYN_SEND状态</p><p><strong>第二次（syn=1，ack=1，seq=y，ack_num=x+1）：</strong></p><p>服务器收到请求包之后，syn=1，ack=1，seq=server_isn，ack_num=client_isn+1的数据包，服务器进人SYN_RCVD状态</p><p><strong>第三次（ack=1，ack_num=y+1）：</strong></p><p>客户端接收到回复后，检查收到的ack_num是否是之前发出去的seq+1以及ack是否为1，如果都对，就再发送syn=0，ack=1，ack_num=server_isn+1，发送后客户端进入ESTABLISHED状态，服务器收到后进入ESTABLISHED状态</p><blockquote><p>client_isn和server_isn是 随机ISN 序列号</p><p>ack和syn是标志位</p></blockquote><p><strong>四次挥手：</strong></p><p><img src="network-review/tcp4.jpeg" alt></p><p><strong>第一次挥手（fin=1，seq=x）：</strong></p><p>假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。发送完毕后，客户端进入 FIN_WAIT_1 状态</p><p><strong>第二次挥手（ack=1，ack_num=x+1）：</strong></p><p>服务器端确认客户端的 FIN包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。</p><p><strong>第三次挥手（fin=1，seq=y）：</strong></p><p>服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN置为1。</p><p>发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。</p><p><strong>第四次挥手（ack=1，ack_num=y+1）：</strong></p><p>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 <code>ACK</code>包。</p><p>服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。</p><p>客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED状态。</p><h4 id="三次握手四次握手原因"><a href="#三次握手四次握手原因" class="headerlink" title="三次握手四次握手原因"></a>三次握手四次握手原因</h4><p>这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。</p><p><strong>为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？</strong></p><p>这是因为虽然双方都同意关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SEND状态到ESTABLISH状态那样）；但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文会一定被对方收到，因此对方处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。</p><p>速学路径：</p><p><a href="http://www.jianshu.com/p/092705233d37" target="_blank" rel="noopener">http://www.jianshu.com/p/092705233d37</a></p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>滑动窗口是接受数据端使用的窗口大小，用来告知发送端接收端的缓存大小，以此可以控制发送端发送数据的大小，从而达到流量控制的目的。</p><h3 id="拥塞窗口"><a href="#拥塞窗口" class="headerlink" title="拥塞窗口"></a>拥塞窗口</h3><p>那么对于数据的发送端就是拥塞窗口了，拥塞窗口不代表缓存，拥塞窗口指某一源端数据流在一个RTT内可以最多发送的数据包数</p><h3 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h3><ul><li>TCP是面向连接的，UDP是无连接的</li><li>TCP有<strong>顺序控制</strong>和<strong>重发控制</strong>，还有流控制(流量控制)，<strong>拥塞控制</strong>，UDP不保证消息送达</li><li>TCP通过3次“握手”来保证数据发送的安全性，不会丢失数据包</li><li>UDP每一次发送数据都需要绑定IP和端口号。相当于发送邮件，只管是否发送成功，不保证对方是否接收到数据</li><li>TCP连接是点对点的，UDP支持多对多通信</li><li>UDP适用于实时性比较高的，比如视频，广播，TCP适合传输文件</li></ul><h3 id="HTML状态码"><a href="#HTML状态码" class="headerlink" title="HTML状态码"></a>HTML状态码</h3><p>​    (1)<br>​    常见错误代码：200，304，400，404，500</p><p>​    (2)<br>​    1xx：临时响应，服务器端响应成功，<br>​      等待请求者进一步操作</p><p>​    (3)<br>​    2xx：响应成功</p><p>​    202接受请求，未处理</p><p>​    204处理了请求，但没有返回任何内容</p><p>​    (4)<br>​    3xx重定向，要完成响应，服务器需要进一步处理</p><p>​    301网页已被永久移动到新位置</p><p>​    302临时移动到新位置</p><p>​    305要求只能使用代理才能访问</p><p>​    (5)<br>​    4xx请求错误</p><p>​    400不理解请求语法</p><p>​    401要求身份验证，先登陆才能请求</p><p>​    403禁止访问，服务器拒绝请求</p><p>​    405请求中的方法被禁用</p><p>​    408请求超时</p><p>​    (6)<br>​    5xx服务器在处理请求时内部发生错误，来自服务器本身的错误</p><p>​    501服务器不具备完成该请求的功能</p><p>​    502服务器作为网关或代理，从上游服务器收到无效响应</p><p>​    504网关超时</p><p>​    505  HTTP版本不支持</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;TCP，HTTP和Socket区别&quot;&gt;&lt;a href=&quot;#TCP，HTTP和Socket区别&quot; class=&quot;headerlink&quot; title=&quot;TCP，HTTP和Socket区别&quot;&gt;&lt;/a&gt;TCP，HTTP和Socket区别&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;tcp是
      
    
    </summary>
    
      <category term="Network" scheme="https://barry215.github.io/categories/Network/"/>
    
    
      <category term="http" scheme="https://barry215.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>Maven自动部署War</title>
    <link href="https://barry215.github.io/2017/03/03/maven-product/"/>
    <id>https://barry215.github.io/2017/03/03/maven-product/</id>
    <published>2017-03-03T07:47:04.000Z</published>
    <updated>2017-04-11T09:42:06.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>昨天的重装环境也是为了实验自动化部署，踩了好多坑，但还是做到了，也许这就是不看英文文档的苦吧</p></blockquote><h2 id="大致思路"><a href="#大致思路" class="headerlink" title="大致思路"></a>大致思路</h2><p>网上找了一些教程，我大概懂了这个部署的流程，首先在远程tomcat的<code>tomcat-users.xml</code>里添加管理员，然后在maven的<code>settings.xml</code>里设置访问tomcat的账号密码，最后在项目的<code>pom.xml</code>设置远程服务器的地址，输入命令就自动部署了</p><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>登录服务器，在tomcat的<code>../tomcat/conf/tomcat-users.xml</code>添加如下代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"admin-gui"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"admin-script"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"manager-gui"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"manager-script"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"manager-jmx"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"manager-status"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">username</span>=<span class="string">"admin"</span> <span class="attr">password</span>=<span class="string">"123456"</span> <span class="attr">roles</span>=<span class="string">"manager-gui,manager-script,manager-jmx,manager-status,admin-script,admin-gui"</span>/&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>其实这个就是一个大坑，Tomcat会提示你，很多教程也会告诉你Tomcat8以后</p><p>Users with the manager-gui role should not be granted either the manager-script or manager-jmx roles.</p><p>也就是manager-gui，manager-script，manager-jmx 不能一起被授权</p><p>结果听话的我，就一直只填一个角色，然后一直不成功，服务器提示401未授权错误</p></blockquote><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>在maven的<code>settings.xml</code>里设置访问tomcat的账号密码</p><p>这个文件的位置也是在<code>../maven/conf/settings.xml</code>，当然这是自己安装的maven目录下，如果是IDEA自带的maven3，可以设置在<code>~/.m2/settings.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>productionServer<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>在项目的<code>pom.xml</code>设置远程服务器的地址</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>MavenDemo<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">server</span>&gt;</span>productionServer<span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://122.45.66.201/manager/text<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">path</span>&gt;</span>/MavenDemo<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这里的这个插件<code>tomcat7-maven-plugin</code>是Tomcat 8*也适用的</p><p>地址必须是IP+<code>/manager/text</code></p><p>path里的是访问地址，也是项目在webapps里的位置</p></blockquote><h2 id="一些坑"><a href="#一些坑" class="headerlink" title="一些坑"></a>一些坑</h2><p>项目的jdk和服务器的jdk版本要一样</p><p>除了这个之外，我们还需要注意如果你用的是Tomcat 8.5，我们还要再做一个配置</p><p>在<code>conf/Catalina/localhost/manager.xml</code>里写入（如果没有就创建）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">privileged</span>=<span class="string">"true"</span> <span class="attr">antiResourceLocking</span>=<span class="string">"false"</span> <span class="attr">docBase</span>=<span class="string">"$&#123;catalina.home&#125;/webapps/manager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.RemoteAddrValve"</span> <span class="attr">allow</span>=<span class="string">"^.*$"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>因为Tomcat 8.5之后对安全访问增强了，不仅仅需要配置管理帐号还需要配置允许远程访问管理员账户</p><p>修改后直接生效无须重启<br>在官方文档中提到：每个web应用应该有自己的安全管理文件（manager.xml）如果没有使用默认值 也就是不能远程访问，所以如果需要远程访问就需要创建<code>manager.xml</code>来指定允许远程访问规则</p></blockquote><p>后来应用到实际项目的时候，你会发现上传的大小受限制了，所以要改Nginx的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen <span class="number">80</span>;</span><br><span class="line">        server_name XX.com;</span><br><span class="line">        location /&#123;</span><br><span class="line">           proxy_pass http:<span class="comment">//192.168.0.12:8080;</span></span><br><span class="line">          client_max_body_size <span class="number">500</span>M; <span class="comment">//添加这一句</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你还使用了mybatis的自动生成工具<code>org.mybatis.generator</code>，请一定要注释掉它</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>可以用IDEA的右侧maven可视化插件按钮，点击<code>tomcat7:redeploy</code></p><p>如果你安装过maven，也可以使用命令：<code>mvn tomcat7:redeploy</code></p><p>这里不用deploy，因为据说会出错，所以就用redeploy好了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;昨天的重装环境也是为了实验自动化部署，踩了好多坑，但还是做到了，也许这就是不看英文文档的苦吧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;大致思路&quot;&gt;&lt;a href=&quot;#大致思路&quot; class=&quot;headerlink&quot; title=&quot;大致思
      
    
    </summary>
    
      <category term="Maven" scheme="https://barry215.github.io/categories/Maven/"/>
    
    
      <category term="maven" scheme="https://barry215.github.io/tags/maven/"/>
    
      <category term="javaweb" scheme="https://barry215.github.io/tags/javaweb/"/>
    
      <category term="tomcat" scheme="https://barry215.github.io/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Centos从头配置javaweb环境</title>
    <link href="https://barry215.github.io/2017/03/01/centos-java-production/"/>
    <id>https://barry215.github.io/2017/03/01/centos-java-production/</id>
    <published>2017-03-01T07:47:49.000Z</published>
    <updated>2017-03-02T09:21:03.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记性太差，还是得写个教程来总结一下配置javaweb的教程，这篇教程也是综合了网上的很多教程</p></blockquote><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>服务器：阿里云ESC Centos 7.3</p><p>本地: Mac OS X 10.10.5</p><h2 id="预先准备"><a href="#预先准备" class="headerlink" title="预先准备"></a>预先准备</h2><p>最近才发现阿里云是不建议升级服务器的内核和操作系统版本，估计腾讯云也是，当初手贱，不管三七二十一，都给升级了，虽然也没有发现什么不对，就一直将就着用了，系统版本也是最新的7.3，本来是7.2的</p><p>为了防止在软件更新时升级了内核及系统版本的情况，按照阿里云给出的<a href="https://help.aliyun.com/knowledge_detail/41199.html" target="_blank" rel="noopener">帮助文档</a>，我们做如下修改</p><p>打开yum.conf文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/yum.conf</span><br></pre></td></tr></table></figure><p>添加代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exclude=kernel*</span><br><span class="line">exclude=centos-release*</span><br></pre></td></tr></table></figure><p>这样就防止升级了，如果还是不懂可以，参考<a href="https://help.aliyun.com/knowledge_detail/41199.html" target="_blank" rel="noopener">帮助文档</a></p><p>接着我们可以开始升级软件包了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y update</span><br></pre></td></tr></table></figure><blockquote><p>-y 参数是在执行过程中，遇到的交互默认选择 yes</p></blockquote><h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><p>访问Oracle官网下载jdk，因为Oracle搞了cookie验证，所以wget不方便</p><p>下载地址-<a href="http://www.oracle.com/technetwork/cn/java/javase/downloads/jdk8-downloads-2133151-zhs.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/cn/java/javase/downloads/jdk8-downloads-2133151-zhs.html</a></p><p>安装jdk之前一定要把之前的版本卸载掉</p><p>查看之前已经安装的jdk rpm</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep jdk</span><br></pre></td></tr></table></figure><p>查到包名之后，我们就可以卸载了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e 包名</span><br></pre></td></tr></table></figure><p>下载完安装包之后，我们用scp命令传到服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp ~/Downloads/jdk-8u111-linux-x64.rpm root@maijinta.top:/usr/local/src</span><br></pre></td></tr></table></figure><p>因为我已经添加信任，所以就不用输密码了</p><p>如果一定要用wget的方法，用服务器直接下载的话，我提供下面的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate --no-cookies --header &quot;Cookie: oraclelicense=accept-securebackup-cookie&quot; http://download.oracle.com/otn-pub/java/jdk/8u111-b14/jdk-8u111-linux-x64.rpm</span><br><span class="line"># 或者</span><br><span class="line">wget --no-cookies --no-check-certificate --header &quot;Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie&quot; http://download.oracle.com/otn-pub/java/jdk/8u111-b14/jdk-8u111-linux-x64.rpm</span><br></pre></td></tr></table></figure><p>下面就开始安装rpm包了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh jdk-8u111-linux-x64.rpm</span><br></pre></td></tr></table></figure><p>安装好以后，在/etc/profile文件中配置环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br></pre></td></tr></table></figure><p>加入下面的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/default</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/jre/lib:$JAVA_HOME/lib:$JAVA_HOME/lib/tools.jar</span><br></pre></td></tr></table></figure><p>查看版本号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version 或 javac -version</span><br></pre></td></tr></table></figure><p>查看环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH</span><br><span class="line">#输出了/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/usr/java/default/bin</span><br></pre></td></tr></table></figure><h2 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h2><p>我下载的是tomcat 8.5，下载地址是-<a href="http://tomcat.apache.org/download-80.cgi" target="_blank" rel="noopener">http://tomcat.apache.org/download-80.cgi</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://apache.fayea.com/tomcat/tomcat-8/v8.5.11/bin/apache-tomcat-8.5.11.tar.gz</span><br></pre></td></tr></table></figure><p>解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf apache-tomcat-8.5.11.tar.gz</span><br></pre></td></tr></table></figure><p>转移文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv apache-tomcat-8.5.11 /usr/local/tomcat</span><br></pre></td></tr></table></figure><p>运行Tomcat</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd bin</span><br><span class="line">./startup.sh</span><br></pre></td></tr></table></figure><p>停止Tomcat</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./shutdown.sh</span><br></pre></td></tr></table></figure><h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><p>下载安装rpm</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src</span><br><span class="line">wget http://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm</span><br><span class="line">rpm -ivh mysql57-community-release-el7-9.noarch.rpm</span><br></pre></td></tr></table></figure><p>安装mysql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install mysql-community-server</span><br></pre></td></tr></table></figure><p>安装mysql要好长一段时间，结果中途断网了，真悲剧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/var/run/yum.pid 已被锁定，PID 为 8095 的另一个程序正在运行。</span><br><span class="line">Another app is currently holding the yum lock; waiting for it to exit...</span><br><span class="line">  另一个应用程序是：yum</span><br><span class="line">    内存： 88 M RSS （480 MB VSZ）</span><br><span class="line">    已启动： Wed Mar  1 18:56:02 2017 - 1:48:09之前</span><br><span class="line">    状态  ：睡眠中，进程ID：8095</span><br></pre></td></tr></table></figure><p>只能删除该进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /var/run/yum.pid</span><br></pre></td></tr></table></figure><p>清理之前下的缓存后重新下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum install mysql-community-server</span><br></pre></td></tr></table></figure><p>下面的过程和之前的文章一样-<a href="https://barry215.github.io/2017/02/21/mysql-install/">Centos7 mysql 安装篇</a></p><h2 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h2><p>  先查看yum可以安装的版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum info nginx</span><br></pre></td></tr></table></figure><p>我的是1.10.2，所以就打算用他的了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx</span><br></pre></td></tr></table></figure><p>因为这样安装不用自己去装依赖，安装完也可以用命令去查看版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -v</span><br></pre></td></tr></table></figure><p>开启服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx</span><br></pre></td></tr></table></figure><p>查看状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status nginx</span><br></pre></td></tr></table></figure><p>当然也可以更换软件源，首先新建一个repo，例如 nginx.repo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.repos.d/nginx.repo</span><br></pre></td></tr></table></figure><p>编辑内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[nginx]</span><br><span class="line">name=nginx repo</span><br><span class="line">baseurl=http://nginx.org/packages/mainline/centos/7/$basearch/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure><p>这里配置的是mainline version，如果想用稳定版，将baseurl中的mainline删除即可</p><h3 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h3><p>用yum安装的nginx，配置文件在<code>/etc/nginx/nginx.conf</code>这里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><p>添加监听端口，因为tomcat是8080端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        #listen       [::]:80 default_server;</span><br><span class="line">        server_name  www.maijinta.top;</span><br><span class="line">        root         /usr/share/nginx/html;</span><br><span class="line"></span><br><span class="line">        # Load configuration files for the default server block.</span><br><span class="line">        include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_pass http://127.0.0.1:8080;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 404 /404.html;</span><br><span class="line">            location = /40x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 500 502 503 504 /50x.html;</span><br><span class="line">            location = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后重启服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure><h2 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h2><p>目前稳定版是3.2.8，其实应该不管版本直接下stable版本就好了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-stable.tar.gz</span><br></pre></td></tr></table></figure><p>首先可以判断是否装了tcl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa tcl</span><br></pre></td></tr></table></figure><p>有版本号回复说明装了</p><p>也可以用<code>which tcl</code>或<code>whereis tcl</code></p><p>接下来就解压，并移到想要的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf redis-stable.tar.gz</span><br><span class="line">mv redis-stable /usr/local/</span><br></pre></td></tr></table></figure><p>进入redis目录，编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/redis-stable</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>然后编译检查</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make test</span><br><span class="line">#成功后会提示 \o/ All tests passed without errors!</span><br></pre></td></tr></table></figure><p>如果它提示缺什么，就装什么</p><p>编译检查很持续一段时间，结束后就可以安装了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure><p>安装完就执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure><p>看到这个图就说明成功了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">               _._</span><br><span class="line">          _.-``__ &apos;&apos;-._</span><br><span class="line">     _.-``    `.  `_.  &apos;&apos;-._           Redis 3.2.8 (00000000/0) 64 bit</span><br><span class="line"> .-`` .-```.  ```\/    _.,_ &apos;&apos;-._</span><br><span class="line">(    &apos;      ,       .-`  | `,    )     Running in standalone mode</span><br><span class="line">|`-._`-...-` __...-.``-._|&apos;` _.-&apos;|     Port: 6379</span><br><span class="line">|    `-._   `._    /     _.-&apos;    |     PID: 20631</span><br><span class="line"> `-._    `-._  `-./  _.-&apos;    _.-&apos;</span><br><span class="line">|`-._`-._    `-.__.-&apos;    _.-&apos;_.-&apos;|</span><br><span class="line">|    `-._`-._        _.-&apos;_.-&apos;    |           http://redis.io</span><br><span class="line"> `-._    `-._`-.__.-&apos;_.-&apos;    _.-&apos;</span><br><span class="line">|`-._`-._    `-.__.-&apos;    _.-&apos;_.-&apos;|</span><br><span class="line">|    `-._`-._        _.-&apos;_.-&apos;    |</span><br><span class="line"> `-._    `-._`-.__.-&apos;_.-&apos;    _.-&apos;</span><br><span class="line">     `-._    `-.__.-&apos;    _.-&apos;</span><br><span class="line">         `-._        _.-&apos;</span><br><span class="line">             `-.__.-&apos;</span><br></pre></td></tr></table></figure><p>设置redis 服务后台启动，在配置文件 redis.conf 中设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes #默认是no</span><br></pre></td></tr></table></figure><p>然后用这个配置启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure><p>查看进程，果然redis已经启动了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -aux #查看所有进程</span><br><span class="line">ps -ef|grep redis #只看redis</span><br></pre></td></tr></table></figure><p>用客户端测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br><span class="line">set name frank</span><br><span class="line">get name</span><br></pre></td></tr></table></figure><p>测试成功</p><p>关闭redis服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli shutdown</span><br><span class="line">pkill redis-server #杀死进程</span><br></pre></td></tr></table></figure><p>修改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim redis.conf</span><br><span class="line">#requirepass foobared  #在这里把注释去掉，换个密码，如requirepass 123456</span><br><span class="line">#bind 127.0.0.1  #加上注释，允许远程访问</span><br></pre></td></tr></table></figure><p>查看网络监听</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -nlt|grep 6379</span><br></pre></td></tr></table></figure><p>看到网络监听从<code>127.0.0.1:6379</code> 变成 <code>0 0.0.0.0:6379</code>，表示Redis已经允许远程登陆访问</p><p>修改<code>redis-cli</code>密码，默认是空</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">执行redis-cli #登录</span><br><span class="line">执行config get requirepass</span><br><span class="line">得到 1) &quot;requirepass&quot;</span><br><span class="line">2) &quot;&quot;             #由此可见是没密码的</span><br><span class="line">执行config set requirepass 123456 #设置密码</span><br><span class="line">需要重新登陆</span><br><span class="line">执行redis-cli -h 127.0.0.1 -p 6379 -a 123456或redis-cli -a 123456</span><br></pre></td></tr></table></figure><p>开机启动配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;/usr/local/redis-stable/redis-server /usr/local/redis-stable/redis.conf &amp;&quot; &gt;&gt; /etc/rc.local</span><br></pre></td></tr></table></figure><h2 id="安装vsftpd"><a href="#安装vsftpd" class="headerlink" title="安装vsftpd"></a>安装vsftpd</h2><p>直接yum安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install vsftpd</span><br></pre></td></tr></table></figure><p>启动vsftpd服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart vsftpd.service  # 重启服务</span><br><span class="line">systemctl start vsftpd.service    # 启动服务</span><br><span class="line">systemctl status vsftpd.service   # 服务状态查看</span><br></pre></td></tr></table></figure><p>修改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/vsftpd/vsftpd.conf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">anonymous_enable=NO        # 不允许匿名访问，禁用匿名登录</span><br><span class="line">chroot_local_user=YES      # 启用限定用户在其主目录下</span><br><span class="line">chroot_list_enable=YES</span><br><span class="line">chroot_list_file=/etc/vsftpd/chroot_list</span><br><span class="line">use_localtime=YES          # 使用本地时(自行添加)</span><br><span class="line">local_enable=YES           # 允许使用本地帐户进行FTP用户登录验证</span><br><span class="line">allow_writeable_chroot=YES # 如果启用了限定用户在其主目录下需要添加这个配置，解决报错 500 OOPS: vsftpd: refusing to run with writable root inside chroot()</span><br><span class="line">xferlog_enable=YES         # 启用上传和下载的日志功能，默认开启。</span><br><span class="line">local_umask=022            # 设置本地用户默认文件掩码022</span><br><span class="line"># FTP上本地的文件权限，默认是077，不过vsftpd安装后的配置文件里默认是022</span><br><span class="line">ascii_upload_enable=YES   #设定支持ASCII模式的上传和下载功能</span><br><span class="line">ascii_download_enable=YES</span><br></pre></td></tr></table></figure><blockquote><p>从2.3.5之后，vsftpd增强了安全检查，如果用户被限定在了其主目录下，则该用户的主目录不能再具有写权限了</p><p>所以要添加 allow_writeable_chroot=YES</p></blockquote><p>创建新用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#创建用户 ftpuser 指定 /var/ftp/public_root 目录</span><br><span class="line">useradd -d /var/ftp/public_root -g ftp -s /sbin/nologin ftpuser</span><br><span class="line"># 设置用户 ftpuser 的密码</span><br><span class="line">passwd ftpuser</span><br><span class="line"># 把 /home/vsftpd 的所有权给ftpuser.root</span><br><span class="line"># chown -R ftpuser.root /var/ftp/public_root 这步不用做，做了应该也没事</span><br></pre></td></tr></table></figure><blockquote><p>-s：禁止此用户登录SSH的权限</p><p>/sbin/nologin：不允许此用户登录系统，但可以登录FTP</p></blockquote><p>权限设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--更改目录所有者--&gt;</span><br><span class="line">chown ftpuser /var/ftp/public_root</span><br><span class="line">&lt;!--更改目录权限--&gt;</span><br><span class="line">chmod -R 755 /var/ftp/public_root</span><br></pre></td></tr></table></figure><p>设置开机重启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable vsftpd.service</span><br></pre></td></tr></table></figure><p>删除用户 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel ftpuser</span><br></pre></td></tr></table></figure><p>最后在Filezilla中创建新站点就可以用了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;记性太差，还是得写个教程来总结一下配置javaweb的教程，这篇教程也是综合了网上的很多教程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="Linux" scheme="https://barry215.github.io/categories/Linux/"/>
    
    
      <category term="java" scheme="https://barry215.github.io/tags/java/"/>
    
      <category term="tomcat" scheme="https://barry215.github.io/tags/tomcat/"/>
    
      <category term="centos" scheme="https://barry215.github.io/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>瓜皮翻身记之Https</title>
    <link href="https://barry215.github.io/2017/02/25/configureHttps/"/>
    <id>https://barry215.github.io/2017/02/25/configureHttps/</id>
    <published>2017-02-25T09:12:06.000Z</published>
    <updated>2017-02-25T09:21:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前装过腾讯云提供的免费ssl证书，但是没试成功。如果真就这样放弃Https，那就很瓜皮了，为了要做一个有灵性的后台，所以我最终还是找到了另外一个免费的SSL证书，哈哈，这就用起来很舒服了</p></blockquote><h2 id="证书提供"><a href="#证书提供" class="headerlink" title="证书提供"></a>证书提供</h2><p>去年的时候，国内 <code>WoSign</code> （沃通）还有免费的SSL证书，但是现在它已经被打压了</p><p>不过，<code>Let&#39;s Encrypt</code> 也正式对外颁发免费的<code>SSL</code>证书</p><blockquote><p><code>Let’s Encrypt</code> 是一个免费、自动化、开放的证书签发服务，由 <em>ISRG</em>（Internet Security Research Group，译：互联网安全研究小组) 这个非盈利组织维护。现在是 Linux 基金会 (Linux Foundation) 合作的项目。</p></blockquote><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>服务器：Centos 7.0</p><p>服务器软件：Nginx</p><h2 id="安装-Certbot"><a href="#安装-Certbot" class="headerlink" title="安装 Certbot"></a>安装 Certbot</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install certbot</span><br></pre></td></tr></table></figure><h2 id="初始化验证目录"><a href="#初始化验证目录" class="headerlink" title="初始化验证目录"></a>初始化验证目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /usr/share/nginx/certbot</span><br></pre></td></tr></table></figure><h2 id="绑定-Let’s-Encrypt-验证目录"><a href="#绑定-Let’s-Encrypt-验证目录" class="headerlink" title="绑定 Let’s Encrypt 验证目录"></a>绑定 Let’s Encrypt 验证目录</h2><p>进入Nginx配置目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx/conf</span><br></pre></td></tr></table></figure><p>配置nginx.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi nginx.conf</span><br></pre></td></tr></table></figure><p>只需要在 nginx 配置文件上的 server 层加上下面的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location ^~ /.well-known/acme-challenge/ &#123;</span><br><span class="line">    default_type &quot;text/plain&quot;;</span><br><span class="line">    root /usr/share/nginx/certbot;</span><br><span class="line">&#125;</span><br><span class="line">location = /.well-known/acme-challenge/ &#123;</span><br><span class="line">    return 404;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 进入sbin目录</span><br><span class="line">cd /usr/local/nginx/sbin</span><br><span class="line"># 重启服务器</span><br><span class="line">./nginx -s reload</span><br></pre></td></tr></table></figure><h2 id="使用-certbot颁发证书"><a href="#使用-certbot颁发证书" class="headerlink" title="使用 certbot颁发证书"></a>使用 certbot颁发证书</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo certbot certonly --webroot -w /usr/share/nginx/certbot -d 你的域名</span><br><span class="line">sudo certbot certonly --webroot -w /usr/share/nginx/certbot -d maijinta.cn  #我的是这个</span><br></pre></td></tr></table></figure><p>然后第一次使用的时候，Certbot 会让你填写一个邮箱，该邮箱作为证书的拥有者，用于后面证书更新</p><blockquote><p>重点是我也第一次看到命令行里还有图形界面的输入框，真是大开眼界</p></blockquote><p>还有就是同意 <code>Let&#39;s Encrypt</code> 的使用条款，没有异议的话选择 Agree就好了</p><p>完成颁发之后，就会看到 Congratulations之类的字样</p><h2 id="引入SSL证书并绑定443端口"><a href="#引入SSL证书并绑定443端口" class="headerlink" title="引入SSL证书并绑定443端口"></a>引入SSL证书并绑定443端口</h2><p>还是配置nginx.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        listen 443 ssl;</span><br><span class="line">        server_name  maijinta.cn www.maijinta.cn;</span><br><span class="line"></span><br><span class="line">        ssl_certificate /etc/letsencrypt/live/maijinta.cn/fullchain.pem;</span><br><span class="line">        ssl_certificate_key /etc/letsencrypt/live/maijinta.cn/privkey.pem;</span><br><span class="line">        ssl_trusted_certificate /etc/letsencrypt/live/maijinta.cn/chain.pem;</span><br><span class="line"></span><br><span class="line">        ssl_session_cache shared:SSL:10m;</span><br><span class="line">        ssl_session_timeout 20m;</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line">        ssl_ciphers ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-RC4-SHA:!ECDHE-RSA-RC4-SHA:ECDH-ECDSA-RC4-SHA:ECDH-RSA-RC4-SHA:ECDHE-RSA-AES256-SHA:!RC4-SHA:HIGH:!aNULL:!eNULL:!LOW:!3DES:!MD5:!EXP:!CBC:!EDH:!kEDH:!PSK:!SRP:!kECDH;</span><br><span class="line"></span><br><span class="line">        location ^~ /.well-known/acme-challenge/ &#123;</span><br><span class="line">                default_type &quot;text/plain&quot;;</span><br><span class="line">                root     /usr/share/nginx/certbot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location = /.well-known/acme-challenge/ &#123;</span><br><span class="line">             return 404;</span><br><span class="line">        &#125;</span><br><span class="line">        location / &#123;</span><br><span class="line">            #root   html; #before exit</span><br><span class="line">            #index  index.html index.htm; #before exit</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header Host $http_host;</span><br><span class="line">        proxy_set_header X-NginX-Proxy true;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_pass http://my_nodejs_upstream/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我的配置文件最终是这样的，加了一些ssl必要的配置，可以和之前的博文对比——<a href="https://barry215.github.io/2017/02/13/ConfigureCentos7/">从头配置NodeJs和PM2</a></p><p>配置之后就可以重启服务器了，但是重启之后我遇到了一个问题</p><p>nginx提示缺少<code>the &quot;ssl&quot; parameter requires ngx_http_ssl_module</code></p><p>估计是当初编译安装的时候没有加上<code>--with-http_ssl_module</code></p><p>所以要重新编译</p><h2 id="查看原来的配置参数"><a href="#查看原来的配置参数" class="headerlink" title="查看原来的配置参数"></a>查看原来的配置参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -V</span><br><span class="line">返回了configure arguments: --prefix=/usr/local/nginx --with-pcre=../pcre-8.40</span><br></pre></td></tr></table></figure><p>configure arguments:就是我原来的配置信息</p><h2 id="加入新参数，重新编译"><a href="#加入新参数，重新编译" class="headerlink" title="加入新参数，重新编译"></a>加入新参数，重新编译</h2><h3 id="进入nginx源码目录"><a href="#进入nginx源码目录" class="headerlink" title="进入nginx源码目录"></a>进入nginx源码目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd nginx-1.10.3</span><br></pre></td></tr></table></figure><h3 id="停止nginx进程"><a href="#停止nginx进程" class="headerlink" title="停止nginx进程"></a>停止nginx进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall -9 nginx</span><br></pre></td></tr></table></figure><h3 id="重新编译的代码和模块"><a href="#重新编译的代码和模块" class="headerlink" title="重新编译的代码和模块"></a>重新编译的代码和模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/nginx --with-pcre=../pcre-8.40 --with-http_ssl_module</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make #编译，注意：千万别make install，否则就覆盖安装了</span><br></pre></td></tr></table></figure><p>make完之后在<code>./nginx-1.10.3/objs</code>目录下就多了个nginx，这个就是新版本的程序了</p><h3 id="替换nginx二进制文件"><a href="#替换nginx二进制文件" class="headerlink" title="替换nginx二进制文件"></a>替换nginx二进制文件</h3><p>保持当前目录不变</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 先备份nginx</span><br><span class="line">cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak</span><br><span class="line"># 再覆盖，覆盖的时候最好是关掉nginx，不然可能是文件正在使用中，无法覆盖</span><br><span class="line">cp ./objs/nginx /usr/local/nginx/sbin/</span><br></pre></td></tr></table></figure><p>开启服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 进入sbin目录</span><br><span class="line">cd /usr/local/nginx/sbin</span><br><span class="line"># 开启服务器</span><br><span class="line">./nginx</span><br></pre></td></tr></table></figure><h2 id="设置自动更新证书"><a href="#设置自动更新证书" class="headerlink" title="设置自动更新证书"></a>设置自动更新证书</h2><p>因为 <code>Let&#39;s Encrypt</code> 的证书<strong>只有 3个月 有效期</strong></p><p>所以我们需要依靠 certbot 自动更新证书</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot renew --quiet</span><br></pre></td></tr></table></figure><blockquote><p>这样之后我们的HTTPS就完工了，快打开浏览器试一下吧！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;之前装过腾讯云提供的免费ssl证书，但是没试成功。如果真就这样放弃Https，那就很瓜皮了，为了要做一个有灵性的后台，所以我最终还是找到了另外一个免费的SSL证书，哈哈，这就用起来很舒服了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;证书提
      
    
    </summary>
    
      <category term="Nginx" scheme="https://barry215.github.io/categories/Nginx/"/>
    
    
      <category term="https" scheme="https://barry215.github.io/tags/https/"/>
    
      <category term="linux" scheme="https://barry215.github.io/tags/linux/"/>
    
      <category term="nginx" scheme="https://barry215.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>阿里巴巴java手册首记</title>
    <link href="https://barry215.github.io/2017/02/25/java-manual/"/>
    <id>https://barry215.github.io/2017/02/25/java-manual/</id>
    <published>2017-02-25T02:46:12.000Z</published>
    <updated>2017-02-25T03:29:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>主要记一下平时不注意的点</p></blockquote><h2 id="java篇"><a href="#java篇" class="headerlink" title="java篇"></a>java篇</h2><ol><li><p>pojo中的成员变量必须是包装类属性</p></li><li><p>pojo中都要有toString方法</p></li><li><p>pojo 类中布尔类型的变量，都不要加 is</p></li><li><p>方法参数中的可变参数(…)要放在其他参数的最后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Varargs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(String arg : args) &#123;</span><br><span class="line">            System.out.println(arg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test();<span class="comment">//0个参数</span></span><br><span class="line">        test(<span class="string">"a"</span>);<span class="comment">//1个参数</span></span><br><span class="line">        test(<span class="string">"a"</span>,<span class="string">"b"</span>);<span class="comment">//多个参数</span></span><br><span class="line">        test(<span class="keyword">new</span> String[] &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;);<span class="comment">//直接传递数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>long b = 4L; 符号标记要大写，因为字体<code>l</code>和<code>1</code>很像</p></li><li><p>method(“a”, “b”, “c”);方法参数书写格式要注意逗号后空一格</p></li><li><p>代码格式中缩进要4 个空格，不要2个空格</p></li><li><p>在pojo的方法中应遵守下面的规范</p><ol><li>获取单个对象的方法用get做前缀</li><li>获取多个对象的方法用list做前缀</li><li>获取统计值的方法用count做前缀</li><li>插入的方法用save(推荐)或insert做前缀</li><li>删除的方法用remove(推荐)或delete做前缀</li><li>修改的方法用update做前缀</li></ol></li><li><p>数据传输对象取名：xxxDTO，之前我没写DTO后缀，下次记住</p></li><li><p>用设计模式时，需要把类名给体现出来，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderFactory</span></span>;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginProxy</span></span>; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceObserver</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>使用常量的equals方法，可以防止空指针问题：<code>&quot;1&quot;.equals(temp)</code></p></li><li><p>不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator方式,如果并发操作,需要对 Iterator 对象加锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = a.iterator(); </span><br><span class="line">while(it.hasNext())&#123;</span><br><span class="line">String temp = it.next(); </span><br><span class="line">if(删除元素的条件)&#123;</span><br><span class="line">it.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在做抽象接口中，可以利用泛型把抽象更深化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Info&lt;T&gt; &#123;</span><br><span class="line">public T getVar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历，前面这种是一遍循环，后面两遍</p></li><li><p>线程资源必须通过线程池提供,不允许在应用中自行显式创建线程</p></li><li><p>SimpleDateFormat 是线程不安全的类,一般不要定义为static变量,如果定义为static,必须加锁,或者使用 DateUtils 工具类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static final ThreadLocal&lt;DateFormat&gt; df = new ThreadLocal&lt;DateFormat&gt;() &#123; </span><br><span class="line">@Override</span><br><span class="line">protected DateFormat initialValue() &#123;</span><br><span class="line">return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>并发修改同一记录时,避免更新丢失,要么在应用层加锁,要么在缓存加锁,要么在数据库层使用乐观锁,使用 version 作为更新依据</p></li><li>Math.random() 这个方法返回是 double 类型,注意取值的范围 0≤x&lt;1(能够 取到零值,注意除零异常),如果想获取整数类型的随机数,不要将 x 放大 10 的若干倍然后 取整,直接使用 Random 对象的 nextInt 或者 nextLong 方法</li><li>获取当前毫秒数 System.currentTimeMillis(); 而不是 new Date().getTime();</li><li>异常不要用来做流程控制,条件控制,因为异常的处理效率比条件分支低</li><li>不能在 finally 块中使用 return,finally 块中的 return 返回后方法结束执行,不 会再执行 try 块中的 return 语句</li></ol><h2 id="mysql篇"><a href="#mysql篇" class="headerlink" title="mysql篇"></a>mysql篇</h2><ol><li>表达是与否概念的字段,必须使用 is_xxx 的方式命名,数据类型是 unsigned tinyint ( 1表示是,0表示否),此规则同样适用于odps建表</li><li>唯一索引名为 <code>uk_字段名</code>；普通索引名则为 <code>idx_字段名</code></li><li>表名、字段名必须使用小写字母或数字;禁止出现数字开头,禁止两个下划线中间只出现数字</li><li>小数类型为 decimal,禁止使用 float 和 double</li><li>如果存储的字符串长度几乎相等,使用 char 定长字符串类型</li><li>varchar 是可变长字符串,不预先分配存储空间,长度不要超过 5000,如果存储长度大于此值,定义字段类型为 text,独立出来一张表,用主键来对应,避免影响其它字段索 引效率</li><li>不要使用 count(列名)或 count(常量)来替代 count(*),count(*)就是 SQL92 定义 的标准统计行数的语法,跟数据库无关,跟 NULL 和非 NULL 无关</li><li>不得使用外键与级联,一切外键概念必须在应用层解决</li><li>禁止使用存储过程,存储过程难以调试和扩展,更没有移植性(不用学存储过程好开心)</li><li><code>in</code> 操作能避免则避免,若实在避免不了,需要仔细评估<code>in</code> 后边的集合元素数量,控制在 1000 个之内</li><li>pojo 类的 boolean 属性不能加 is,而数据库字段必须加 is_,要求在 resultMap 中 进行字段与属性之间的映射</li></ol><blockquote><p>其实我还有一些没记下，因为完全没接触过。。尴尬，还是要继续学习</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;主要记一下平时不注意的点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;java篇&quot;&gt;&lt;a href=&quot;#java篇&quot; class=&quot;headerlink&quot; title=&quot;java篇&quot;&gt;&lt;/a&gt;java篇&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;po
      
    
    </summary>
    
      <category term="Java" scheme="https://barry215.github.io/categories/Java/"/>
    
    
      <category term="mysql" scheme="https://barry215.github.io/tags/mysql/"/>
    
      <category term="java" scheme="https://barry215.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Centos7 mysql 安装篇</title>
    <link href="https://barry215.github.io/2017/02/21/mysql-install/"/>
    <id>https://barry215.github.io/2017/02/21/mysql-install/</id>
    <published>2017-02-21T13:44:20.000Z</published>
    <updated>2017-03-01T16:45:21.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写这篇的目的，纯属记笔记哈，因为那些流程和命令要背住，还是。。有点难度的</p></blockquote><h2 id="安装RPM包"><a href="#安装RPM包" class="headerlink" title="安装RPM包"></a>安装RPM包</h2><p>官网地址：<a href="https://dev.mysql.com/downloads/repo/yum/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/repo/yum/</a></p><p>找到最新版本的mysql rpm包，我选择的是<code>mysql57-community-release-el7-9.noarch.rpm</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget http://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm</span><br><span class="line">rpm -ivh mysql57-community-release-el7-9.noarch.rpm</span><br><span class="line"><span class="meta">#</span><span class="bash"> 貌似也能直接这样</span></span><br><span class="line">rpm -Uvh http://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm</span><br></pre></td></tr></table></figure><h2 id="可选-重新生成缓存"><a href="#可选-重新生成缓存" class="headerlink" title="[可选]重新生成缓存"></a>[可选]重新生成缓存</h2><p>当时我是做了，但是做后感觉不做也应该没事</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure><h2 id="yum安装mysql服务端"><a href="#yum安装mysql服务端" class="headerlink" title="yum安装mysql服务端"></a>yum安装mysql服务端</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y mysql-server</span><br></pre></td></tr></table></figure><p>这样之后就已经装好mysql服务端程序了，印象里因为网络的问题下载了很久</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看mysql版本</span></span><br><span class="line">mysql --version</span><br></pre></td></tr></table></figure><h2 id="开启mysql服务"><a href="#开启mysql服务" class="headerlink" title="开启mysql服务"></a>开启mysql服务</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service mysqld start </span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">systemctl start mysqld</span><br></pre></td></tr></table></figure><h2 id="配置mysql"><a href="#配置mysql" class="headerlink" title="配置mysql"></a>配置mysql</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable mysqld # 设置为开机启动项</span><br><span class="line">systemctl daemon-reload # 重新载入 systemd,扫描新的配置</span><br></pre></td></tr></table></figure><p>紧接着修改/etc/my.cnf配置文件，第一次的时候我是最后才配置下面的编码方式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mysqld] # 在这里添加下面的内容</span><br><span class="line">character_set_server=utf8</span><br><span class="line">init_connect='SET NAMES utf8'</span><br><span class="line"><span class="meta">#</span><span class="bash"> default-time_zone = <span class="string">'+8:00'</span>  <span class="comment">#修改时区，加了也没事</span></span></span><br></pre></td></tr></table></figure><p>然后重启数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h2><p>在log文件中找到数据库初始化的临时密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep 'temporary password' /var/log/mysqld.log</span><br></pre></td></tr></table></figure><p>拿到临时密码之后就可以修改密码了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 登录mysql，输入临时密码</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置新密码,密码因为默认规则要求有大小写和数字和特殊符号</span></span><br><span class="line">set password for 'root'@'localhost'=password('Abc&amp;123');</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建新用户</span></span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO 'frank'@'%' IDENTIFIED BY '123&amp;Abc' WITH GRANT OPTION;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 刷新</span></span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;写这篇的目的，纯属记笔记哈，因为那些流程和命令要背住，还是。。有点难度的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;安装RPM包&quot;&gt;&lt;a href=&quot;#安装RPM包&quot; class=&quot;headerlink&quot; title=&quot;安装RPM包&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="Linux" scheme="https://barry215.github.io/categories/Linux/"/>
    
    
      <category term="linux" scheme="https://barry215.github.io/tags/linux/"/>
    
      <category term="mysql" scheme="https://barry215.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>从头配置NodeJs和PM2</title>
    <link href="https://barry215.github.io/2017/02/13/ConfigureCentos7/"/>
    <id>https://barry215.github.io/2017/02/13/ConfigureCentos7/</id>
    <published>2017-02-13T05:53:33.000Z</published>
    <updated>2017-03-02T02:24:04.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>下面我来分享下配置Centos7的吐血经历，(╯﹏╰)蓝瘦香菇…</p></blockquote><h2 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h2><p><strong>本地：</strong> Mac OSX</p><p><strong>远端服务器：</strong>腾讯云ECS（1核CPU、1GB内存），系统版本为CentOS 7.0</p><p><strong>服务器用户：</strong>root （期待有人来攻击我的垃圾服务器）</p><p><strong>Github：</strong>github.com/Barry215</p><h2 id="安装目的"><a href="#安装目的" class="headerlink" title="安装目的"></a>安装目的</h2><p>本地代码开发测试后，更新到Github仓库，然后通过PM2部署远程服务器，服务器再部署Node的应用，最后使用Nginx进行反向代理</p><h2 id="远端安装Nodejs"><a href="#远端安装Nodejs" class="headerlink" title="远端安装Nodejs"></a>远端安装Nodejs</h2><p>我看网上大多都是通过下载压缩包来安装的，如果我没有在本地装过Node，也许我会去选择，但是因为在Mac上吃过这个坑（node版本更新太快，而且mac上用brew来安装据说有bug），所以还是打算先安装nvm，用nvm来安装Node。</p><h3 id="更新yum"><a href="#更新yum" class="headerlink" title="更新yum"></a>更新yum</h3><p>把yum更新到最新版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update -y  #y参数是让升级过程中都默认yes</span><br></pre></td></tr></table></figure><p>我们将使用最新源代码构建Node.js，要进行软件的安装，需要一组用来编译源代码的开发工具：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y groupinstall "Development Tools"</span><br></pre></td></tr></table></figure><h3 id="安装Nvm"><a href="#安装Nvm" class="headerlink" title="安装Nvm"></a>安装Nvm</h3><p>用curl来安装nvm，但是这个命令有时效性，最新看<a href="https://github.com/creationix/nvm/" target="_blank" rel="noopener">https://github.com/creationix/nvm/</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bash</span><br></pre></td></tr></table></figure><p>在mac上这样就ok了，因为它会自动地在.bash_profile文件里写上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export NVM_DIR="$HOME/.nvm"</span><br><span class="line">[ -s "$NVM_DIR/nvm.sh" ] &amp;&amp; . "$NVM_DIR/nvm.sh" # This loads nvm</span><br></pre></td></tr></table></figure><p>但是亲身体验Centos发现要自己加上去，加完后记得<code>source .bash_profile</code>更新</p><p>当然不一定要写在.bash_profile上</p><p>官方说明（写在那四个文件上应该都有效，<a href="http://blog.csdn.net/chenchong08/article/details/7833242" target="_blank" rel="noopener">区别参考</a>）：</p><blockquote><p>The script clones the nvm repository to <code>~/.nvm</code> and adds the source line to your profile (<code>~/.bash_profile</code>, <code>~/.zshrc</code>, <code>~/.profile</code>, or <code>~/.bashrc</code>).</p></blockquote><p>然后，可以用一下 <code>nvm --version</code> 看一下安装好了没有</p><h3 id="安装Node"><a href="#安装Node" class="headerlink" title="安装Node"></a>安装Node</h3><p>因为nvm是从国外的官网获取资源，所以我们再加入淘宝团队的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node</span><br></pre></td></tr></table></figure><p>这个也是放在.bash_profile里，加完后记得<code>source .bash_profile</code>更新</p><p>下面我就开始安装Node</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install stable  #或者nvm install v7.5.0，选一个自己适用的版本</span><br></pre></td></tr></table></figure><p>执行命令 <code>node -v</code> 就可以看到现在使用的 <code>Node.js</code> 的版本号</p><p>执行命令 <code>npm -v</code> 就可以看到现在使用的 <code>NPM</code> 的版本号</p><h3 id="安装cnpm"><a href="#安装cnpm" class="headerlink" title="安装cnpm"></a>安装cnpm</h3><p>因为原版的 <code>npm</code> 在国内安装东西是很慢的，要解决慢就一定要用镜像</p><p><code>cnpm</code> 就是使用了淘宝的 <code>NPM</code> 镜像的 <code>npm</code></p><p>安装方法也很简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>只需要一步就可以安装好 <code>cnpm</code></p><p>运行 <code>cnpm -v</code> 可以看到安装好了的 <code>cnpm</code> 的版本</p><p>如果不使用PM2的话，用<code>scp</code>，<code>sftp</code>把代码传到服务器，可以直接运行NodeJs了</p><p>因为 Nodejs 是一个Web服务器，所以它本身就已经有自己的端口了，我设置的是3000</p><p>使用 <code>node app.js</code> 之类的手段可以让 Nodejs 服务器运行起来</p><h2 id="远端安装PM2"><a href="#远端安装PM2" class="headerlink" title="远端安装PM2"></a>远端安装PM2</h2><p>本地和远端都使用命令安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install pm2 -g</span><br></pre></td></tr></table></figure><p>安装成功后使用<code>pm2 -v</code>参看版本</p><h3 id="Github与服务器建立信任"><a href="#Github与服务器建立信任" class="headerlink" title="Github与服务器建立信任"></a>Github与服务器建立信任</h3><p>如果之前github上已经放过服务器的key了，那就不用下面的操作了</p><p>如果没有，那就</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen #生成公钥和密钥</span><br><span class="line">vi ~/.ssh/id_rsa.pub #去复制公钥里的内容</span><br></pre></td></tr></table></figure><p>然后在github上的setting里的SSH keys加入id_rsa.pub的内容就行了</p><h3 id="本地创建项目"><a href="#本地创建项目" class="headerlink" title="本地创建项目"></a>本地创建项目</h3><p>在github上创建一个新的项目，接着将本地项目与github远程仓库建立连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/Barry215/node_demo.git</span><br><span class="line">git push -u origin master #第一次提交好像要用-u，之后就不用了</span><br></pre></td></tr></table></figure><h3 id="本地配置pm2"><a href="#本地配置pm2" class="headerlink" title="本地配置pm2"></a>本地配置pm2</h3><p>在本地的项目目录下，输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 ecosystem</span><br></pre></td></tr></table></figure><p>会生成一个ecosystem.config.js(版本原因，也可能是ecosystem.json)文件</p><p>因为目前我们仅部署一个应用，因此，先把不必要的信息删除，即删除apps部分的第二项</p><p>同时把我们的目标文件改为你应用的入口文件，此处修改为Express.js的默认设置，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">script : &quot;./bin/www&quot;,</span><br></pre></td></tr></table></figure><p>apps部分就设置完毕了，然后再设置deploy部分。其中production用于生产环境，dev用于开发环境</p><p>我的配置结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"></span><br><span class="line">  apps : [</span><br><span class="line"><span class="comment">//由于我们此次只有一个项目,我们只配置一个app</span></span><br><span class="line">    &#123;</span><br><span class="line">      name : <span class="string">"node_demo"</span>, <span class="comment">//自己取一个名字</span></span><br><span class="line">      script : <span class="string">"./bin/www"</span>,</span><br><span class="line">      env: &#123;</span><br><span class="line">        COMMON_VARIABLE: <span class="string">"true"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      env_production : &#123;</span><br><span class="line">        NODE_ENV: <span class="string">"production"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  deploy : &#123;</span><br><span class="line">    <span class="comment">//生产环境部署配置</span></span><br><span class="line">    production : &#123;</span><br><span class="line">      <span class="comment">//登录远程服务器的用户名</span></span><br><span class="line">      user : <span class="string">"root"</span>,</span><br><span class="line">      <span class="comment">//远程服务器的IP或hostname，此处可以是数组同步部署多个服务器</span></span><br><span class="line">      host : <span class="string">"115.159.190.30"</span>,</span><br><span class="line">      <span class="comment">//远端名称及分支名</span></span><br><span class="line">      ref  : <span class="string">"origin/master"</span>,</span><br><span class="line">      <span class="comment">//git仓库地址</span></span><br><span class="line">      repo : <span class="string">"git@github.com:Barry215/node_demo.git"</span>,</span><br><span class="line">      <span class="comment">//远程服务器部署目录，需要填写user具备写入权限的目录</span></span><br><span class="line">      path : <span class="string">"/home/root/www/production"</span>,</span><br><span class="line">      <span class="comment">//部署后需要执行的命令</span></span><br><span class="line">      <span class="string">"post-deploy"</span> : <span class="string">"npm install &amp;&amp; pm2 startOrRestart ecosystem.config.js --env production"</span></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//因为我没有开发环境的分支，所以dev部分就不写了</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="免密登录服务器"><a href="#免密登录服务器" class="headerlink" title="免密登录服务器"></a>免密登录服务器</h3><p>因为pm2的部署是通过ssh进行的，因此需要开通本地到远程服务器的无密码登录</p><p>具体步骤看我的另一篇文章—<a href="https://barry215.github.io/2017/01/25/ssh-without-psd/">SSH免密登录服务器</a></p><h3 id="配置pm2"><a href="#配置pm2" class="headerlink" title="配置pm2"></a>配置pm2</h3><p>在本地应用目录下，执行pm2 deploy命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 deploy ecosystem.config.js production setup</span><br></pre></td></tr></table></figure><p>提示错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invalid or unexpected token</span><br></pre></td></tr></table></figure><p>仔细检查配置文件，看是否有写错，如果看不出可以放到vim里看</p><p>并且注意ecosystem.config.js版本的顶部会有<code>module.exports =</code></p><p>ecosystem.json版本的顶部直接是<code>{</code>开始的</p><p>又提示错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host key verification failed.</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line">Please make sure you have the correct access rights and the repository exists.</span><br><span class="line">  failed to clone</span><br><span class="line">Deploy failed</span><br></pre></td></tr></table></figure><p>此时主要是在远程服务器中，并未将<a href="http://github.com/" target="_blank" rel="noopener">http://github.com</a>加入known_hosts，在服务器端通过如下命令设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keyscan -t rsa github.com &gt;&gt; ~/.ssh/known_hosts</span><br></pre></td></tr></table></figure><p>在本地继续执行部署命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 deploy ecosystem.config.js production setup</span><br></pre></td></tr></table></figure><p>此时，如无其他问题，输出应提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  ○ setup complete</span><br><span class="line">--&gt; Success</span><br></pre></td></tr></table></figure><p>至此，pm2的本地部署设置完毕。</p><h3 id="pm2部署服务器"><a href="#pm2部署服务器" class="headerlink" title="pm2部署服务器"></a>pm2部署服务器</h3><p>pm2部署要求本地的项目必须将修改提交到github</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;update ecosystem&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>提交后，在本地应用目录，输入如下命令进行生产环境的部署：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 deploy ecosystem.config.js production</span><br></pre></td></tr></table></figure><p>如果看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Use `pm2 show &lt;id|name&gt;` to get more details about an app</span><br><span class="line">  ○ hook test</span><br><span class="line">  ○ successfully deployed origin/master</span><br><span class="line">--&gt; Success</span><br></pre></td></tr></table></figure><p>说明部署成功</p><p>在远程服务器查看端口情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -antp</span><br></pre></td></tr></table></figure><p>可以看到应用默认部署的3000端口已经开放了。通过浏览器打开：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://115.159.190.30:3000</span><br></pre></td></tr></table></figure><p>可以看到部署的Web应用可以访问了。（如果netstat -antp中可见3000端口可访问，可以检查下ECS的防火墙设置，确保3000端口对外开放）</p><h3 id="服务器设置pm2开机自启"><a href="#服务器设置pm2开机自启" class="headerlink" title="服务器设置pm2开机自启"></a>服务器设置pm2开机自启</h3><p>开启启动设置，此处是CentOS系统，其他系统替换最后一个选项（可选项：ubuntu, centos, redhat, gentoo, systemd, darwin, amazon）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 startup centos</span><br></pre></td></tr></table></figure><p>然后按照提示需要输入的命令进行输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo su -c &quot;env PATH=$PATH:/usr/bin pm2 startup centos -u root --hp /home/root&quot;</span><br></pre></td></tr></table></figure><p>保存pm2设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 save</span><br></pre></td></tr></table></figure><p>现在重新启动系统，测试是否可以开机启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><p>等系统重启后，通过浏览器检查系统是否自动启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://115.159.190.30:3000</span><br></pre></td></tr></table></figure><p>如果启动正常，说明设置成功！</p><h2 id="可选-更新git"><a href="#可选-更新git" class="headerlink" title="(可选)更新git"></a>(可选)更新git</h2><p>因为Centos 7 上的git版本是1.8，我嫌弃它，所以打算安装新的</p><p>卸载原有 git</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove git</span><br></pre></td></tr></table></figure><p>安装依赖文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel #最好都装</span><br><span class="line">yum install gcc perl-ExtUtils-MakeMaker #一定要安装</span><br></pre></td></tr></table></figure><p>切换到<code>/usr/local/src</code>目录下</p><p>下载最新版git</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.kernel.org/pub/software/scm/git/git-2.11.1.tar.gz</span><br></pre></td></tr></table></figure><p>解压并进入解压后的目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf git-2.11.1.tar.gz &amp;&amp; cd git-2.11.1</span><br></pre></td></tr></table></figure><p>编译安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">./configure #必须执行</span><br><span class="line"></span><br><span class="line">#二选一</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">或者(我试的好像是上面这种)</span><br><span class="line">make prefix=/usr/local/git all</span><br><span class="line">make prefix=/usr/local/git install</span><br></pre></td></tr></table></figure><p>下面这种需要加环境，上面这种跳过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/git/bin #把它放到.bash_profile里</span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure><p>查看环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure><p>查看版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure><h2 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h2><p>通过Nginx反向代理，可以让服务器上某端口，指向指定域名的80端口，这样访问就不需要加端口号了</p><h3 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc gcc-c++</span><br><span class="line">yum -y install openssl</span><br><span class="line">yum -y install zlib</span><br><span class="line">yum -y install pcre</span><br></pre></td></tr></table></figure><p>以上安装的是一些主要的依赖包，具体可根据自己情况或者报错信息提示安装或修改</p><p>我装了<code>zlib</code> <code>zlib-devel</code> <code>pcre-devel</code></p><h3 id="可选-安装pcre依赖"><a href="#可选-安装pcre依赖" class="headerlink" title="(可选)安装pcre依赖"></a>(可选)安装pcre依赖</h3><p>我先前不知道可以yum安装，所以是wget装的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.40.tar.gz </span><br><span class="line">./configure --prefix=/usr/local/pcre</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h3 id="下载Nginx"><a href="#下载Nginx" class="headerlink" title="下载Nginx"></a>下载Nginx</h3><blockquote><p>网上说可以配置yum去安装它，但是我没有尝试</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.10.3.tar.gz</span><br></pre></td></tr></table></figure><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf nginx-1.10.3.tar.gz</span><br></pre></td></tr></table></figure><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd nginx-1.10.3</span><br><span class="line">./configure --prefix=/usr/local/nginx --with-pcre=../pcre-8.40</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h3 id="启动Nginx"><a href="#启动Nginx" class="headerlink" title="启动Nginx"></a>启动Nginx</h3><p>进入Nginx的安装目录下，直接启动Nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx/sbin</span><br><span class="line">./nginx -h #查看帮助</span><br><span class="line">./nginx -t #判断配置文件是否正确</span><br><span class="line">./nginx  #重启是 ./nginx -s reload</span><br><span class="line"><span class="meta">#</span><span class="bash">也可以 killall -9 nginx 杀死进程再启动，也可以是<span class="built_in">kill</span> -9 nginx</span></span><br></pre></td></tr></table></figure><p>也可以使用脚本去启动，停止和重启Nginx—<a href="http://blog.csdn.net/w1014074794/article/details/51881050" target="_blank" rel="noopener">参考链接</a></p><h3 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h3><p>进入配置目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx/conf</span><br></pre></td></tr></table></figure><p>配置nginx.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi nginx.conf</span><br></pre></td></tr></table></figure><p>配置参考</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> user nobody;</span></span><br><span class="line">worker_processes 1;</span><br><span class="line">error_log /usr/local/nginx/logs/error.log;</span><br><span class="line">pid /run/nginx.pid;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Load dynamic modules. See /usr/share/nginx/README.dynamic.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> include /usr/share/nginx/modules/*.conf;</span></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">  upstream my_nodejs_upstream &#123;</span><br><span class="line">    server 127.0.0.1:3000;</span><br><span class="line">    keepalive 64;</span><br><span class="line">  &#125;</span><br><span class="line">  server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name   www.maijinta.cn;//你的域名</span><br><span class="line">    # access_log /usr/local/nginx/logs/access.log;</span><br><span class="line">    # error_log /usr/local/nginx/logs/error.log;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header Host $http_host;</span><br><span class="line">        proxy_set_header X-NginX-Proxy true;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_pass http://my_nodejs_upstream/;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重启Nginx"><a href="#重启Nginx" class="headerlink" title="重启Nginx"></a>重启Nginx</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./nginx -t #判断配置文件是否正确</span><br><span class="line">./nginx -s reload #重启Nginx</span><br></pre></td></tr></table></figure><p>这样之后，就可以用80端口访问我们的NodeJs应用了</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>往后就可以使用pm2来自动化部署Node.js了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 deploy ecosystem.config.js production</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;下面我来分享下配置Centos7的吐血经历，(╯﹏╰)蓝瘦香菇…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;环境介绍&quot;&gt;&lt;a href=&quot;#环境介绍&quot; class=&quot;headerlink&quot; title=&quot;环境介绍&quot;&gt;&lt;/a&gt;环境介绍&lt;/h
      
    
    </summary>
    
      <category term="Linux" scheme="https://barry215.github.io/categories/Linux/"/>
    
    
      <category term="linux" scheme="https://barry215.github.io/tags/linux/"/>
    
      <category term="nginx" scheme="https://barry215.github.io/tags/nginx/"/>
    
      <category term="git" scheme="https://barry215.github.io/tags/git/"/>
    
      <category term="node" scheme="https://barry215.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>《Web全栈工程师的自我修养》读书笔记</title>
    <link href="https://barry215.github.io/2017/01/25/review%20of%20Full-Stack%20Engineer/"/>
    <id>https://barry215.github.io/2017/01/25/review of Full-Stack Engineer/</id>
    <published>2017-01-25T09:48:20.000Z</published>
    <updated>2017-02-13T11:42:15.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="review of Full-Stack Engineer/book.jpg" alt></p><h3 id="全栈的梦想"><a href="#全栈的梦想" class="headerlink" title="全栈的梦想"></a>全栈的梦想</h3><p>一个雨晴的下午，在图书馆翻遍了所有计算机书架才淘到的书。</p><p>本来打算在图书馆看完，但是空调的热浪吹得头疼，索性还是带回家了，结果尼玛看了三天！</p><p>程序员毕竟都是有全栈工程师这样的梦想，我从安卓到后端再到前端，上下游堆积起来的知识坑越来越多，读了这本书以后，我才想起高中毕业那时的口号</p><blockquote><p> 先精后广，一专多长，做“T”型人才</p></blockquote><p>不过我的成长道路没有那样的美好，一开始谁知道要在哪里做精呢，都学了一遍，才慢慢敲开编程的大门，但是谁知道不会再改了呢。</p><p>但是，总而言之，如果明确了目标，我们还是要先精后广。</p><blockquote><p>先在一个特定的方向上有比较深入的钻研，然后再将学习目标渐渐推广开来</p></blockquote><p>作者对全栈工程师提出了三个要求：</p><ul><li>一专多长</li><li>关注商业目标</li><li>关注用户体验</li></ul><h3 id="作为学生"><a href="#作为学生" class="headerlink" title="作为学生"></a>作为学生</h3><p>作者给出的建议</p><ul><li>把握好校招时间段</li><li>毕业后选择大公司</li></ul><h3 id="作为野生程序员"><a href="#作为野生程序员" class="headerlink" title="作为野生程序员"></a>作为野生程序员</h3><p>作者想的称呼，很贴切</p><blockquote><p>没有计算机基础知识和相关教育经历，靠着计算机开发兴趣进入这个行业，虽然知识面比较广，但各方面都一知半解的开发者——野生程序员</p></blockquote><p>凭兴趣学习虽好，但是总会落下一些不常用，但是要紧的知识点</p><h3 id="作为工程师"><a href="#作为工程师" class="headerlink" title="作为工程师"></a>作为工程师</h3><p>作者推荐一定要有自己的<strong>作品集</strong>，并且注重<strong>声望</strong></p><blockquote><p>就像那个什么都懂的人。感觉他什么都能解决。身边是不是有这种人，可能你喜欢也可能你不喜欢，但是你一定不会排斥成为这样的人。很简单，就是“答应做的事情，全部都要完成，但是你也要学会正确的拒绝。”</p></blockquote><h3 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h3><ul><li>压缩源码和图片</li><li>选择合适的图片格式</li><li>合并静态资源</li><li>开启服务端的Gzip压缩</li><li>使用CDN</li><li>延长静态资源缓存时间</li><li>把CSS放在页面的头部，把JS放在底部</li></ul><h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><ul><li>Expires</li><li>Last-Modified</li><li>Cache-Control</li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="http://www.jianshu.com/p/7a24e0920255" target="_blank" rel="noopener">浏览器缓存</a></p><p><a href="http://www.jianshu.com/p/985b35774295" target="_blank" rel="noopener">浏览器缓存知识小结及应用</a></p><p><a href="http://www.jianshu.com/p/e34a2221a8ac" target="_blank" rel="noopener">浅谈Web缓存</a></p><h3 id="关于版本号"><a href="#关于版本号" class="headerlink" title="关于版本号"></a>关于版本号</h3><p>根据Semver的规范，版本号用小数点分隔为三个数字。</p><p>比如v3.2.1中3是主要版本号，2是次要版本号，1是补丁。</p><blockquote><p>主要版本号：有API变更导致不兼容旧版本的时候使用</p><p>次要版本号：新增功能，但是向前兼容的情况下使用</p><p>补丁：修复向前兼容的bug时使用</p></blockquote><h3 id="时间管理四象限"><a href="#时间管理四象限" class="headerlink" title="时间管理四象限"></a>时间管理四象限</h3><p>事情分为重要与不重要，紧急与不紧急，以此分为四象限</p><p>作者提出</p><ul><li>如果您平时没有做重要的事情，就会发现自己常常在做紧急的事情</li><li>常常做重要的事情，你会发现很少有紧急的事情</li></ul><p>作者还对此举了很多例子，反正我是信服了</p><h3 id="设计的四大基本理论"><a href="#设计的四大基本理论" class="headerlink" title="设计的四大基本理论"></a>设计的四大基本理论</h3><p>亲密</p><blockquote><p>关系亲密的元素要放在一起，关系疏远的元素则要分开。位置的亲密性直接表现出意义的相关性。</p></blockquote><p>对齐</p><blockquote><p>左对齐，右对齐，上对齐，下对齐</p></blockquote><p>重复</p><blockquote><p>视觉上使用重复的图形和元素、线条、颜色等。</p></blockquote><p>对比</p><blockquote><p>如果两个元素不一样，就让它完全不一样，产生视觉冲击力。</p></blockquote><h3 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h3><blockquote><p>这里写的四点，每点都很重要</p></blockquote><ul><li>在项目最开始做出合理的时间评估</li><li>根据人员的强项来安排任务</li><li>唤起团队对项目成功的渴望</li><li>保障沟通。理想沟通频率每周至少两次</li></ul><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>和上司汇报工作的时候要突出重点</p><p>讲PPT的时候，听众的注意力要么在PPT上，要么在你身上，所以如果PPT内容太多，大家会忽略你说的话</p><p>对于既没有能力也没有上进意愿的员工，尽早开除，这种员工就像是蛀虫，会腐蚀一个团队</p><p>妥协的结果不都是最好的结果</p><p>加班是一种不好的文化</p><h3 id="性格"><a href="#性格" class="headerlink" title="性格"></a>性格</h3><p>内向是世界上最好的性格</p><p>内向者有一种敏感度</p><ul><li>自我意识  自我情绪的感知</li><li>社会意识  周遭人的情绪感知</li><li>自我管理  自我情绪的控制</li><li>关系管理  朋友关系变化感知</li></ul><h3 id="留言"><a href="#留言" class="headerlink" title="留言"></a>留言</h3><p>作者最后留言</p><blockquote><p>最后感谢一下我的妻子，如果没有你的陪伴，我应该早就写完这本书了</p></blockquote><p>最后我也感谢一下作者，如果不是写得很好，我应该早就看完这本书了 23333</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;review of Full-Stack Engineer/book.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h3 id=&quot;全栈的梦想&quot;&gt;&lt;a href=&quot;#全栈的梦想&quot; class=&quot;headerlink&quot; title=&quot;全栈的梦想&quot;&gt;&lt;/a&gt;全栈的梦想&lt;/h3
      
    
    </summary>
    
      <category term="Book" scheme="https://barry215.github.io/categories/Book/"/>
    
    
      <category term="web" scheme="https://barry215.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>SSH免密登录服务器</title>
    <link href="https://barry215.github.io/2017/01/25/ssh-without-psd/"/>
    <id>https://barry215.github.io/2017/01/25/ssh-without-psd/</id>
    <published>2017-01-25T07:08:12.000Z</published>
    <updated>2017-03-01T04:25:08.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此教程仅适用于Mac</p></blockquote><h3 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h3><h4 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h4><p><code>ssh-keygen -t rsa</code></p><p>一路回车，各种提示按默认不要改，等待执行完毕。</p><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>在~/.ssh里生成了两个密钥文件：id_rsa（私钥） id_rsa.pub（公钥）</p><h4 id="放公钥到服务器"><a href="#放公钥到服务器" class="headerlink" title="放公钥到服务器"></a>放公钥到服务器</h4><p><code>scp ~/.ssh/id_rsa.pub 服务器用户名@IP或域名:~/.ssh/</code></p><p>然后需要输入密码，再进行传输</p><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><h4 id="加入验证"><a href="#加入验证" class="headerlink" title="加入验证"></a>加入验证</h4><p><code>cd ~/.ssh</code></p><p>把id_rsa.pub的内容加入到服务器端的默认验证文件authorized_keys</p><p><code>cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</code></p><blockquote><p>如果.ssh目录下没有authorized_keys文件，则新建一个</p><p><code>vi authorized_keys</code></p></blockquote><p>这样之后就可以免密登录了，如果要使用别名登录，可以继续配置</p><h3 id="本地-1"><a href="#本地-1" class="headerlink" title="本地"></a>本地</h3><h4 id="配置config文件"><a href="#配置config文件" class="headerlink" title="配置config文件"></a>配置config文件</h4><p><code>vi ~/.ssh/config</code></p><p>加入以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Host baidu #别名，域名缩写</span><br><span class="line"></span><br><span class="line">HostName baidu.com #完整的域名</span><br><span class="line"></span><br><span class="line">User root #登录该域名使用的账号名</span><br><span class="line"></span><br><span class="line">PreferredAuthentications publickey  #有些情况或许需要加入此句，优先验证类型ssh</span><br><span class="line"></span><br><span class="line">IdentityFile ~/.ssh/id_rsa #私钥文件的路径</span><br></pre></td></tr></table></figure><p>配置好像很简单。。完成之后<code>scp</code>和<code>sftp</code>都不需要输入密码了哟~</p><h4 id="使用命令缩写"><a href="#使用命令缩写" class="headerlink" title="使用命令缩写"></a>使用命令缩写</h4><p>可以去修改用户目录下的<code>.bash_profile</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.bash_profile</span><br></pre></td></tr></table></figure><p>比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias la=&quot;ls -a&quot;  #添加这一句就实现 la = ls -a的效果</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;此教程仅适用于Mac&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;本地&quot;&gt;&lt;a href=&quot;#本地&quot; class=&quot;headerlink&quot; title=&quot;本地&quot;&gt;&lt;/a&gt;本地&lt;/h3&gt;&lt;h4 id=&quot;生成密钥&quot;&gt;&lt;a href=&quot;#生成密钥
      
    
    </summary>
    
      <category term="Server" scheme="https://barry215.github.io/categories/Server/"/>
    
    
      <category term="linux" scheme="https://barry215.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>【转】解耦解的早，改需求没烦恼</title>
    <link href="https://barry215.github.io/2017/01/25/screen-record/"/>
    <id>https://barry215.github.io/2017/01/25/screen-record/</id>
    <published>2017-01-25T04:38:24.000Z</published>
    <updated>2017-01-25T04:50:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>世上本没有解耦，需求改的多了也便有了解耦。 —— 产品经理</p></blockquote><p>本例将通过一个计时控件，聊聊如何解耦~</p><p>本<code>TimerView</code>仅作为<code>demo</code>，不保证其健壮性，请勿在实际项目中使用。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><code>UI容器</code>与<code>计时逻辑</code>分离</li><li><code>UI容器</code>与<code>具体UI布局</code>分离</li></ul><h3 id="Let’s-Go"><a href="#Let’s-Go" class="headerlink" title="Let’s Go"></a>Let’s Go</h3><p>话说，小明在做一个电商项目，有个倒计时需求。</p><h3 id="需求1-0"><a href="#需求1-0" class="headerlink" title="需求1.0"></a>需求1.0</h3><p>要求”时、分、秒”数字显示。</p><p>这个简单，小明很快自定义了一个<code>TimerView</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerView</span> </span>&#123;</span><br><span class="line">    TextView tvHour, tvMinute, tvSecond;</span><br><span class="line">    TextView divider1, divider2;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="screen-record/dtv_default.gif" alt="需求1.0"></p><h3 id="需求2-0"><a href="#需求2-0" class="headerlink" title="需求2.0"></a>需求2.0</h3><p>界面太丑啦，加点颜色和背景吧~</p><p>这个也简单，小明很快加了一些自定义属性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerView</span> </span>&#123;</span><br><span class="line">    TextView tvHour, tvMinute, tvSecond;</span><br><span class="line">    TextView divider1, divider2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加 自定义属性</span></span><br><span class="line">    <span class="keyword">int</span> tvHourBgRes, tvMinuteBgRes, tvSecondBgRes;</span><br><span class="line">    <span class="keyword">int</span> tvHourColor, tvMinuteColor, tvSecondColor;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="screen-record/dtv_diy.gif" alt="需求2.0"></p><h3 id="需求3-0"><a href="#需求3-0" class="headerlink" title="需求3.0"></a>需求3.0</h3><p>这时，产品经理又跑了过来，你看我发现了啥~</p><p>发现一套火焰数字.jpg，好炫酷的说，帮忙改上去吧~</p><p><img src="screen-record/dtv_fire.gif" alt="需求3.0"></p><p>小明内心：你TM有病啊！！！</p><p>你发现了么，这下小明把自己带到沟里了。新需求要求显示<code>火焰数字图片</code>(ImageView)。<br><br>然而，由于<code>TimerView</code>由<code>TextView</code>构成，再怎么自定义属性也实现不了新需求(ImageView)了。<br><br>说的就是你呀：<a href="https://github.com/iwgang/CountdownView" target="_blank" rel="noopener">https://github.com/iwgang/CountdownView</a></p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>为啥会这样呢？因为一开始就设计紧耦合了。<br><br><code>TimerView</code>依赖了具体子类<code>TextView</code>，功能也就被局限在<code>TextView</code>了。<br><br>那我们只需这么调整一下，把<code>TextView</code>改成更抽象的<code>View</code>。<br><br>这样一来<code>tvHour</code>既可以是<code>TextView</code>，也可以是<code>ImageView</code>，或者某个<code>ViewGroup</code>，功能得以拓展：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerView</span> </span>&#123;</span><br><span class="line">    <span class="comment">//TextView tvHour, tvMinute, tvSecond;</span></span><br><span class="line">    View tvHour, tvMinute, tvSecond;</span><br><span class="line">    <span class="comment">//TextView divider1, divider2;</span></span><br><span class="line">    View divider1, divider2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自定义属性也不用了，因为无法确定 tvHour 这些究竟是啥子类。</span></span><br><span class="line">    <span class="comment">//int tvHourBgRes, tvMinuteBgRes, tvSecondBgRes;</span></span><br><span class="line">    <span class="comment">//int tvHourColor, tvMinuteColor, tvSecondColor;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这也体现了软件设计的一大原则：<strong>要依赖抽象(View)而不要依赖具体(TextView)。</strong></p><h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><p>还有一个问题：<code>tvHour</code>究竟是啥呢，这个得由用户决定。<br><br>通常我们会提供一系列<code>setXXX()</code>方法给用户进行设置。这个套路叫做<strong>依赖注入</strong>。<br><br>依赖注入是解耦的一种常见的方式。通常，当你有无法确定的一些东西，都应该抛给用户决定。<br><br>举个例子，<code>View</code>被点击时，设计者不知道你想干嘛，于是设计了<code>View.setOnClickListener()</code>。这是典型的依赖注入。</p><p>好了，<code>ImageView</code>可以支持了，然而对于界面更新<code>ImageView</code>和<code>TextView</code>肯定是不一样的。<br><br>该怎么更新又无法确定了，我们可以再次用<code>依赖注入</code>的方式解耦，把难题抛给用户。<br><br>因此，我设计了类似<code>Adapter</code>的东西，都在代码里，就不详细展开了。</p><h3 id="需求4-0"><a href="#需求4-0" class="headerlink" title="需求4.0"></a>需求4.0</h3><p>嗨呀~还不够啊，产品经理的脑洞总是很大的。</p><p>产品经理：我看到一个 svg 诶~</p><p>小明：算我倒霉。不过，我早就重构解耦过了。改需求, 小case~</p><p><img src="screen-record/gtv.gif" alt="需求4.0"></p><h3 id="需求5-0"><a href="#需求5-0" class="headerlink" title="需求5.0"></a>需求5.0</h3><p>产品经理：小明，你还活着那？我发现机械表更好看诶~</p><p>小明: <strong>**</strong>, 我改就是了</p><p><img src="screen-record/mtv.gif" alt="需求5.0"></p><h3 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h3><p><a href="https://github.com/lypeer/GoogleClock" target="_blank" rel="noopener">https://github.com/lypeer/GoogleClock</a></p><p><a href="https://github.com/gnehsuy/ClockView" target="_blank" rel="noopener">https://github.com/gnehsuy/ClockView</a></p><p>转自博客 - <a href="http://blog.csdn.net/a153614131/article/details/54579426" target="_blank" rel="noopener">http://blog.csdn.net/a153614131/article/details/54579426</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;世上本没有解耦，需求改的多了也便有了解耦。 —— 产品经理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本例将通过一个计时控件，聊聊如何解耦~&lt;/p&gt;
&lt;p&gt;本&lt;code&gt;TimerView&lt;/code&gt;仅作为&lt;code&gt;demo&lt;/code&gt;，不保
      
    
    </summary>
    
      <category term="Design Method" scheme="https://barry215.github.io/categories/Design-Method/"/>
    
    
      <category term="design method" scheme="https://barry215.github.io/tags/design-method/"/>
    
  </entry>
  
  <entry>
    <title>数据结构基础</title>
    <link href="https://barry215.github.io/2017/01/05/Data-Structure/"/>
    <id>https://barry215.github.io/2017/01/05/Data-Structure/</id>
    <published>2017-01-05T07:26:02.000Z</published>
    <updated>2018-03-09T12:10:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>总结一下数据结构的知识，以便之后忘记了可以翻阅，哈哈，就像是做了一次备份哇</p><h2 id="基本概念与术语"><a href="#基本概念与术语" class="headerlink" title="基本概念与术语"></a>基本概念与术语</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><blockquote><p>是对客观事物的符号表示，很笼统的概念，范围很大</p></blockquote><h3 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h3><blockquote><p>是性质相同的数据元素的集合，是数据的子集</p></blockquote><h3 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h3><blockquote><p>是组成数据的基本单位</p></blockquote><h3 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h3><blockquote><p>一个数据元素可以由若干个数据项组成</p><p>数据项是数据的不可分割的最小单位</p></blockquote><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><blockquote><p>是相互之间存在的一种或多种特定关系的数据元素的集合</p></blockquote><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><blockquote><p>是指数据对象中数据元素之间的相互关系</p></blockquote><ul><li>集合结构</li><li>线性结构</li><li>树形结构</li><li>图形结构或图状结构</li></ul><h4 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h4><blockquote><p>是指数据的逻辑结构在计算机中存储形式</p></blockquote><ul><li>顺序存储结构</li><li>链式存储结构</li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><blockquote><p>解决问题的方法</p></blockquote><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>有穷性</li><li>确定性</li><li>可行性</li><li>输入</li><li>输出</li></ul><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>记作 <code>T(n) = O(f(n))</code></p><blockquote><p>表示随着<strong>问题规模</strong>n的增大，算法执行时间的增长率和f(n)的增长率相同，也称作<strong>渐进时间复杂度</strong></p></blockquote><p>小贴士：</p><p>这里我们学到优化程序，不单单是降低时间复杂度，还可以从空间复杂度来解决，如果不考虑容量，可以用空间换效率</p><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ElemType data[MAXSIZE];</span><br><span class="line">  <span class="keyword">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><h3 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同typedef struct Node *LinkList;</span></span><br><span class="line"><span class="comment">//p = (LinkList) malloc (sizeof (Node))</span></span><br><span class="line"><span class="comment">//有系统生成一个Node型的结点，同时将该结点的起始位置赋给指针变量p</span></span><br></pre></td></tr></table></figure><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><blockquote><p>表中最后的一个结点的指针域指向头结点，整个链表形成一个环</p></blockquote><p>和线性链表基本一致，差别在于判断循环条件不是p或者p-&gt;next是否为空，而是它们是否等于头指针</p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><blockquote><p>就是不仅仅有指向后继的指针，还有增加了指向前驱的指针</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">DuNode</span> *<span class="title">prior</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">DuNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;DuNode,*DuLinkList;</span><br></pre></td></tr></table></figure><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><blockquote><p>后进先出 LIFO</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  SElemType *base;</span><br><span class="line">  SElemType *top;</span><br><span class="line">  <span class="keyword">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><p>栈可以在程序设计语言中实现递归（调用自己的行为叫做递归）</p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><blockquote><p>先进先出 FIFO</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  QElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  QueuePtr front;  <span class="comment">//队头指针</span></span><br><span class="line">  QueuePtr rear;   <span class="comment">//队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure><h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><p>特点</p><p>在非空队列中，头指针始终指向队列头元素，而尾指针始终指向队列尾元素的下一个位置，这样当front等于rear时，此队列不是还剩一个元素，而是空队列。</p><h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *ch;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;HString;</span><br></pre></td></tr></table></figure><h2 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h2><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><h4 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h4><p>第一层（括号）的数量</p><h4 id="深度"><a href="#深度" class="headerlink" title="深度"></a>深度</h4><p>层数（括号数）</p><p>速学路径</p><p><a href="http://www.zybang.com/question/17d8254f4028ac9695f79081f32542f4.html" target="_blank" rel="noopener">http://www.zybang.com/question/17d8254f4028ac9695f79081f32542f4.html</a></p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h3><h4 id="结点"><a href="#结点" class="headerlink" title="结点"></a>结点</h4><blockquote><p>树上的一个元素</p></blockquote><h4 id="度"><a href="#度" class="headerlink" title="度"></a>度</h4><blockquote><p> 结点拥有的子树数</p></blockquote><h4 id="叶子"><a href="#叶子" class="headerlink" title="叶子"></a>叶子</h4><blockquote><p>度为0的结点</p></blockquote><h4 id="孩子"><a href="#孩子" class="headerlink" title="孩子"></a>孩子</h4><blockquote><p>结点的子树</p></blockquote><h4 id="双亲"><a href="#双亲" class="headerlink" title="双亲"></a>双亲</h4><blockquote><p>子树的派生数称为双亲</p></blockquote><h4 id="兄弟"><a href="#兄弟" class="headerlink" title="兄弟"></a>兄弟</h4><blockquote><p>同一个双亲的孩子互称兄弟</p></blockquote><h4 id="深度-1"><a href="#深度-1" class="headerlink" title="深度"></a>深度</h4><blockquote><p>树中结点的最大层次称为树的深度</p></blockquote><h4 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h4><blockquote><p>几棵互不相交的树的集合</p></blockquote><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><blockquote><p>每个结点最多两棵子树的树</p></blockquote><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ul><li>在二叉树的第 i 层上最多有2^i-1^个结点</li><li>深度为 k 的二叉树最多有2^k^-1个结点</li><li>任何一棵二叉树，如果叶子结点数为n~0~，度为2的结点数为n~2~，则n~0~ = n~2~+1</li><li>具有n个结点的完全二叉树的深度为[log~2~n]+1</li></ul><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><h5 id="顺序存储结构-1"><a href="#顺序存储结构-1" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h5><p>根据完全二叉树的顺序，依次排列，形成顺序表</p><h5 id="链式存储结构-1"><a href="#链式存储结构-1" class="headerlink" title="链式存储结构"></a>链式存储结构</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  TElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchuld</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure><h4 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h4><blockquote><p>仅仅是根节点的输出顺序的前后</p></blockquote><ul><li>先序遍历</li><li>中序遍历</li><li>后序遍历</li></ul><h4 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h4><blockquote><p>相比二叉树，他增加了前驱和后继的元素，为了节约空间，数据位还是采用之前的左右子树，但是用tag来表示是两边的数据位是左孩子还是前驱，右孩子还是后继</p></blockquote><table><thead><tr><th>左数据位</th><th>标识</th><th>数据</th><th>标识</th><th>右数据位</th></tr></thead><tbody><tr><td>Lchild</td><td>LTag</td><td>data</td><td>RTag</td><td>Rchild</td></tr></tbody></table><p>如果tag为0，表示是孩子的数据，如果为1，表示是前驱或者后继</p><h5 id="线索化"><a href="#线索化" class="headerlink" title="线索化"></a>线索化</h5><p>一般用中序遍历二叉树，使其变成线索二叉树</p><p>速学路径</p><p><a href="http://blog.csdn.net/jiajiayouba/article/details/9224403" target="_blank" rel="noopener">http://blog.csdn.net/jiajiayouba/article/details/9224403</a></p><h3 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h3><h4 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h4><h5 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  PElemType data;</span><br><span class="line">  <span class="keyword">int</span> parent;  <span class="comment">//双亲位置域</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  PTNode nodes[SIZE];</span><br><span class="line">  <span class="keyword">int</span> r,n;   <span class="comment">//根的位置和结点数</span></span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure><h5 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>   //孩子结点</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> child;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*ChildPtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  TElemType data;</span><br><span class="line">  ChildPtr firstchild;   <span class="comment">//孩子链表头指针</span></span><br><span class="line">&#125;CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  CTBOX nodes[SIZE];</span><br><span class="line">  <span class="keyword">int</span> r,n;   <span class="comment">//根的位置和结点数</span></span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure><h5 id="兄弟表示法"><a href="#兄弟表示法" class="headerlink" title="兄弟表示法"></a>兄弟表示法</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">nextsibling</span>;</span></span><br><span class="line">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure><h4 id="树与二叉树的转换"><a href="#树与二叉树的转换" class="headerlink" title="树与二叉树的转换"></a>树与二叉树的转换</h4><p><img src="Data-Structure/erchashu.png" alt></p><h4 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h4><h5 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h5><blockquote><p>把树转化成二叉树</p></blockquote><ul><li>先根遍历（类似于二叉树的先序遍历）</li><li>后根遍历（类似于二叉树的中序遍历）</li></ul><h5 id="森林的遍历"><a href="#森林的遍历" class="headerlink" title="森林的遍历"></a>森林的遍历</h5><blockquote><p>把森林转化成二叉树</p></blockquote><ul><li>先序遍历森林（类似于二叉树的先序遍历）</li><li>中序遍历森林（类似于二叉树的中序遍历）</li></ul><h3 id="赫夫曼树"><a href="#赫夫曼树" class="headerlink" title="赫夫曼树"></a>赫夫曼树</h3><blockquote><p>转变二叉树来实现用较小的代价来访问到概率大的元素，又叫最优二叉树</p></blockquote><h4 id="生成最优树的方法"><a href="#生成最优树的方法" class="headerlink" title="生成最优树的方法"></a>生成最优树的方法</h4><p>现在有一堆概率数：A:5 , B:15 , C:40 , D:30 , E:10</p><p><img src="Data-Structure/hefumanshu.png" alt></p><p>如上图所示，选两个目前最小的数生成N~1~，保证右子树的权值大于左子树，然后这样循环，即可生成</p><p>上图二叉树的带权路径长度(叶子结点的路径之和)<br>$$<br>40x1+30x2+15x3+10x4+5x4=205<br>$$</p><h4 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a>赫夫曼编码</h4><p>如下图所示</p><p><img src="Data-Structure/hefumanbianma.png" alt></p><p>主要思想还是没变，把概率最大的字母用最少的二进制字符来表示，而且每个二进制字符组代表的字母不冲突。</p><p>速学路径</p><p><a href="http://www.jianshu.com/p/95fba425be44" target="_blank" rel="noopener">http://www.jianshu.com/p/95fba425be44</a></p><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="术语-1"><a href="#术语-1" class="headerlink" title="术语"></a>术语</h3><h4 id="G-V-E"><a href="#G-V-E" class="headerlink" title="G(V,E)"></a>G(V,E)</h4><blockquote><p>G表示一个图，V是图的顶点集合，E是图的边集合</p></blockquote><h4 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h4><blockquote><p>顶点之间的边没有方向</p></blockquote><h4 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h4><blockquote><p>顶点之间的边有方向，这种边称为有向边，也称为弧</p></blockquote><h5 id="入度"><a href="#入度" class="headerlink" title="入度"></a>入度</h5><blockquote><p>有向边指向顶点V的数量称为入度</p></blockquote><h5 id="出度"><a href="#出度" class="headerlink" title="出度"></a>出度</h5><blockquote><p>有向边离开顶点V的数量称为出度</p></blockquote><h4 id="简单图"><a href="#简单图" class="headerlink" title="简单图"></a>简单图</h4><blockquote><p>不存在顶点到自身的边，并且没有重复的边的图是简单图</p></blockquote><h4 id="网"><a href="#网" class="headerlink" title="网"></a>网</h4><blockquote><p>有权值的图叫做网</p></blockquote><h4 id="连通图"><a href="#连通图" class="headerlink" title="连通图"></a>连通图</h4><blockquote><p>图上任意两个顶点都连通，则为连通图</p></blockquote><h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p><img src="Data-Structure/linjiejuzheng.png" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EdgeType;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  VertexType vexs[MAXSIZE];         <span class="comment">//顶点数组</span></span><br><span class="line">  EdgeType arc[MAXSIZE][MAXSIZE];   <span class="comment">//二维数组，边表</span></span><br><span class="line">  <span class="keyword">int</span> numVertexes,numEdges;         <span class="comment">//顶点数和边数</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p><img src="Data-Structure/linjiebiao.png" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> adjvex;   <span class="comment">//储存该顶点的下标</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">nextarc</span>;</span>  <span class="comment">//指向下一个邻接点的指针</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  VertexType data;   <span class="comment">//顶点信息</span></span><br><span class="line">  ArcNode *firstarc;  <span class="comment">//指向第一个邻接点</span></span><br><span class="line">&#125;VNode,AdjList[MAX_VERTEX_NUM];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  AdjList vertices;</span><br><span class="line">  <span class="keyword">int</span> vexnum,arcnum;  <span class="comment">//顶点数和弧数</span></span><br><span class="line">&#125;ALGraph;</span><br></pre></td></tr></table></figure><h4 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h4><blockquote><p>邻接表是以出度为出发点，逆邻接表是以入度为出发点，那么十字链表就是结合它们两者</p></blockquote><h5 id="顶点结点"><a href="#顶点结点" class="headerlink" title="顶点结点"></a>顶点结点</h5><table><thead><tr><th>指向该顶点的入边表的第一个结点</th><th>数据</th><th>指向该顶点的出边表的第一个结点</th></tr></thead><tbody><tr><td>firstin</td><td>data</td><td>firstout</td></tr></tbody></table><h5 id="弧结点"><a href="#弧结点" class="headerlink" title="弧结点"></a>弧结点</h5><table><thead><tr><th>弧起点的下标</th><th>弧终点的下标</th><th>指向终点相同的下一条弧</th><th>指向起点相同的下一条弧</th><th>数据</th></tr></thead><tbody><tr><td>tailvex</td><td>headvex</td><td>hlink</td><td>tlink</td><td>data</td></tr></tbody></table><h4 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h4><blockquote><p>是无向图的另一种链式存储结构</p></blockquote><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><blockquote><p>一直递归地遍历第一个顶点的第一个邻接点，直到访问的顶点没有邻接点后，再对第一个顶点的第二个邻接点进行递归遍历，如此循环</p></blockquote><p><img src="Data-Structure/shendubianli.png" alt></p><h4 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h4><blockquote><p>以顶点为起始点，由近至远，依次访问和顶点路径想通且路径长度分别为1，2……的顶点</p></blockquote><p><img src="Data-Structure/guangdubianli.png" alt></p><p>速学路径</p><p><a href="http://blog.csdn.net/dreamzuora/article/details/51137132" target="_blank" rel="noopener">http://blog.csdn.net/dreamzuora/article/details/51137132</a></p><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><blockquote><p>把各个顶点连接起来的最小代价的树</p></blockquote><h4 id="普里姆（Prim）算法"><a href="#普里姆（Prim）算法" class="headerlink" title="普里姆（Prim）算法"></a>普里姆（Prim）算法</h4><blockquote><p>新建一个集合，放入一个顶点，然后选出和这个顶点连通的最短路径的那个顶点，也放进这个集合，然后选出和这两个顶点连通的最短路径的那个顶点，然后再把它放进集合，直到所有的顶点都在集合里了，那最小生成树也出来了</p></blockquote><h4 id="克鲁斯卡尔（Kruskal）算法"><a href="#克鲁斯卡尔（Kruskal）算法" class="headerlink" title="克鲁斯卡尔（Kruskal）算法"></a>克鲁斯卡尔（Kruskal）算法</h4><blockquote><p>将图中边按其权值由小到大的次序顺序选取，然后凑出来</p></blockquote><h4 id="速学路径"><a href="#速学路径" class="headerlink" title="速学路径"></a>速学路径</h4><p><a href="http://blog.csdn.net/weinierbian/article/details/8059129/" target="_blank" rel="noopener">http://blog.csdn.net/weinierbian/article/details/8059129/</a></p><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><blockquote><p>由AOV网构造拓扑序列的拓扑排序算法主要是循环执行以下两步，直到不存在入度为0的顶点为止。</p><p>(1) 选择一个入度为0的顶点并输出之；</p><p>(2) 从网中删除此顶点及所有出边。</p><p>循环结束后，若输出的顶点数小于网中的顶点数，则输出“有回路”信息，否则输出的顶点序列就是一种拓扑序列。</p></blockquote><h4 id="AOV网"><a href="#AOV网" class="headerlink" title="AOV网"></a>AOV网</h4><blockquote><p>在有向图中若以顶点表示活动，有向边表示活动之间的先后关系，这样的图简称为AOV网</p></blockquote><h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><blockquote><p>从源点到汇点的路径长度(各路径上持续时间之和)最长的路径叫关键路径</p></blockquote><h4 id="AOE网"><a href="#AOE网" class="headerlink" title="AOE网"></a>AOE网</h4><blockquote><p>用顶点表示事件，弧表示活动，弧上的权值表示活动持续的时间的有向图叫AOE网</p></blockquote><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><h4 id="迪杰斯特拉（Dijkstra）算法"><a href="#迪杰斯特拉（Dijkstra）算法" class="headerlink" title="迪杰斯特拉（Dijkstra）算法"></a>迪杰斯特拉（Dijkstra）算法</h4><blockquote><p>按路径长度递增的次序产生最短路径的算法</p></blockquote><p><img src="Data-Structure/dijiesitela.png" alt></p><p>速学路径</p><p><a href="http://blog.csdn.net/qq_34845121/article/details/62056089" target="_blank" rel="noopener">http://blog.csdn.net/qq_34845121/article/details/62056089</a></p><h4 id="弗洛伊德（Floyd）算法"><a href="#弗洛伊德（Floyd）算法" class="headerlink" title="弗洛伊德（Floyd）算法"></a>弗洛伊德（Floyd）算法</h4><p>速学链接</p><p><a href="http://blog.csdn.net/bjtu_dubing/article/details/50333027" target="_blank" rel="noopener">http://blog.csdn.net/bjtu_dubing/article/details/50333027</a></p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="术语-2"><a href="#术语-2" class="headerlink" title="术语"></a>术语</h3><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><blockquote><p>是数据元素中某个数据项的值，用它可以标识一个数据元素</p></blockquote><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><blockquote><p>从第一个或者最后一个记录开始，逐个与给定的值进行匹配</p></blockquote><h3 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h3><blockquote><p>搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。</p><p>时间复杂度为O(logn)</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// while循环</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> arr[], <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> khey)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid;</span><br><span class="line"><span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">mid = start + (end - start) / <span class="number">2</span>; <span class="comment">//直接平均可能會溢位，所以用此算法</span></span><br><span class="line"><span class="keyword">if</span> (arr[mid] &lt; khey)</span><br><span class="line">start = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; khey)</span><br><span class="line">end = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> mid; <span class="comment">//最後檢測相等是因為多數搜尋狀況不是大於要不就小於</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> arr[], <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> khey)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start &gt; end)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>; <span class="comment">//直接平均可能會溢位，所以用此算法</span></span><br><span class="line"><span class="keyword">if</span> (arr[mid] &gt; khey)</span><br><span class="line"><span class="keyword">return</span> binary_search(arr, start, mid - <span class="number">1</span>, khey);</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &lt; khey)</span><br><span class="line"><span class="keyword">return</span> binary_search(arr, mid + <span class="number">1</span>, end, khey);</span><br><span class="line"><span class="keyword">return</span> mid; <span class="comment">//最後檢測相等是因為多數搜尋狀況不是大於要不就小於</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>java实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">binarySearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(T[] x, T key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(x, <span class="number">0</span>, x.length- <span class="number">1</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用循环实现的二分查找</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(T[] x, T key, Comparator&lt;T&gt; comp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = x.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">//无符号向右移一位，左侧补0</span></span><br><span class="line"><span class="comment">//            int mid = (high + low)/2;</span></span><br><span class="line">            <span class="keyword">int</span> cmp = comp.compare(x[mid], key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                low= mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                high= mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用递归实现的二分查找</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>&lt;T extends Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(T[] x, <span class="keyword">int</span> low, <span class="keyword">int</span> high, T key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + ((high -low) &gt;&gt; <span class="number">1</span>); <span class="comment">//向右移一位，就是除以2</span></span><br><span class="line"><span class="comment">//            int mid = (high + low)/2;  //直接平均可能會溢位，所以用上面这种算法</span></span><br><span class="line">            <span class="keyword">if</span>(key.compareTo(x[mid])== <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(key.compareTo(x[mid])&lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> binarySearch(x,low, mid - <span class="number">1</span>, key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> binarySearch(x,mid + <span class="number">1</span>, high, key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Integer[] it = <span class="keyword">new</span> Integer[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> f = <span class="number">0</span>;f&lt;it.length;f++)&#123;</span><br><span class="line">            it[f] = f+<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(binarySearch(it, <span class="number">3</span>, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="binary-search-tree"><a href="#binary-search-tree" class="headerlink" title="binary search tree"></a>binary search tree</h3><blockquote><p> 中文翻译可为(排序二叉树,二叉搜索树,二叉查找树)</p><p> 左子树上的所有结点的值均小于它的根结点的值</p><p> 右子树上的所有结点的值均大于它的根结构的值</p><p> 它的左右子树也分别为二叉排序树</p></blockquote><p>把无序序列转成二叉排序树之后，用中序遍历的方法可以输出有序的顺序序列</p><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Node 二叉树上的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wait</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点的数据，这里我们用一个int表示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> data;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点的左孩子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点的右孩子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，data初始化节点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data=http:<span class="comment">//blog.csdn.net/lwxdjk/article/details/data;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认构造函数，data=0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BTree二叉排序树类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wait</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BTree</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 树的根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node root;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录树的节点个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认构造函数，树的根节点为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入一个新的节点node</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            root = node;</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node current = root;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.data &lt;= current.data) &#123;</span><br><span class="line">                <span class="comment">// 如果插入节点的值小于当前节点的值，说明应该插入到当前节点左子树，而此时如果左子树为空，就直接设置当前节点的左子树为插入节点。</span></span><br><span class="line">                <span class="keyword">if</span> (current.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    current.left = node;</span><br><span class="line">                    size++;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                current = current.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果插入节点的值大于当前节点的值，说明应该插入到当前节点右子树，而此时如果右子树为空，就直接设置当前节点的右子树为插入节点。</span></span><br><span class="line">                <span class="keyword">if</span> (current.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    current.right = node;</span><br><span class="line">                    size++;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                current = current.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入一个值为data的节点</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        insert(<span class="keyword">new</span> Node(data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据int数组里面的值建立一个二叉排序树</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> datas</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bulidTree</span><span class="params">(<span class="keyword">int</span>[] datas)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, len = datas.length; i &lt; len; i++) &#123;</span><br><span class="line">            insert(datas[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序遍历，递归方法实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 当前访问的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list 存储节点值的容器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrderRe</span><span class="params">(Node node,List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(list==<span class="keyword">null</span>)&#123;</span><br><span class="line">            list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            inOrderRe(node.left,list);</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(node.data);</span><br><span class="line">        <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            inOrderRe(node.right,list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序遍历二叉排序树  非递归的方法，深度优先和栈思想</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] inOrder() &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//使用stack存储遍历到的节点</span></span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">        Node node = root;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//一直往下遍历，知道到左孩子节点为空</span></span><br><span class="line">            <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左孩子节点为空之后，往后找，找到上一个节点.如果找到的上一个节点的右孩子节点为空，那么继续往上找，直到找到一个右孩子节点不为空的</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node = stack.pop();</span><br><span class="line">                res[i++] = node.data;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                node = stack.pop();</span><br><span class="line">                res[i++] = node.data;</span><br><span class="line">                <span class="comment">//找到了一个右孩子节点不为空的节点，就去遍历他的右孩子节点</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    node = node.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                node=<span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>速学路径</p><p><a href="https://www.nowcoder.com/questionTerminal/a738e13ce2aa4daeac9ef3b4238e4b2e?pos=7&amp;mutiTagIds=583&amp;orderByHotValue=1" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/a738e13ce2aa4daeac9ef3b4238e4b2e?pos=7&amp;mutiTagIds=583&amp;orderByHotValue=1</a></p><p><a href="http://www.itdadao.com/articles/c15a205949p0.html" target="_blank" rel="noopener">http://www.itdadao.com/articles/c15a205949p0.html</a></p><p><a href="https://segmentfault.com/a/1190000008949339" target="_blank" rel="noopener">数据结构二叉树 JAVA版</a></p><h3 id="B树-B-树-B-tree"><a href="#B树-B-树-B-tree" class="headerlink" title="B树(B-树,B-tree)"></a>B树(B-树,B-tree)</h3><blockquote><p>B树是多路平衡查找树，B树每个结点可以有n个元素和n+1个孩子，减少树的高度，所以可以降低内存读取外存的次数；( 对二叉查找树的改进。它的设计思想是，将相关数据尽量集中在一起，以便一次读取多个数据，减少硬盘操作次数）一般用于数据库系统中</p></blockquote><p><img src="Data-Structure/b-tree.jpeg" alt></p><h4 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h4><ul><li>根结点的儿子数为[2, M]</li><li>除根结点以外的非叶子节点的儿子数为[M/2, M]</li><li>每个结点存放至少M/2-1（取上整）和至多M-1个关键字</li><li>每个节点的关键字比它的子节点个数少 1 (叶结点除外)</li><li>所有的叶子结点都在同一个层级</li></ul><h4 id="速学路径-1"><a href="#速学路径-1" class="headerlink" title="速学路径"></a>速学路径</h4><p><a href="http://www.jianshu.com/p/ed76dbc0536d" target="_blank" rel="noopener">http://www.jianshu.com/p/ed76dbc0536d</a></p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><blockquote><p>B+树是B树的变种树，有n棵子树的节点中含有n个关键字，每个关键字不保存数据，只用来索引，数据都保存在叶子节点。是为文件系统而生的。</p></blockquote><p><img src="Data-Structure/b+tree.jpeg" alt></p><h4 id="为什么数据库索引采用B-树"><a href="#为什么数据库索引采用B-树" class="headerlink" title="为什么数据库索引采用B+树"></a>为什么数据库索引采用B+树</h4><p>因为从磁盘读到内存需要花很多时间，所以普通的搜索树的深度很深，会导致IO时间很长，所以用深度低的多路查找树。那为什么真实数据不放在内层节点呢，是要让磁盘块能放更多的数据项，同时数据项（索引字段）要小一点，这样可以减低树的高度。</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>重点：B树必须用中序遍历的方法按序扫库， 而B+树直接从叶子结点挨个扫一遍就完了</p><table><thead><tr><th>B 树</th><th>B+ 树</th><th></th></tr></thead><tbody><tr><td>关键字</td><td>关键字分布在整颗树中，只出现一次</td><td>所有关键字都出现在叶节点的链表中，且有序</td></tr><tr><td>搜索命中</td><td>可能在树中任意节点命中，搜索结束</td><td>只可能在叶节点中命中，查询路径稳定</td></tr><tr><td>非叶节点</td><td>非叶节点包含关键字，也包含数据</td><td>非叶节点相当于索引帮助搜索到叶节点，叶节点相当于存储关键字数据的数据层</td></tr><tr><td>叶节点</td><td></td><td>增加了链表指针，相当于存储关键字数据的数据层</td></tr></tbody></table><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="InnoDB和MyISAM的索引区别"><a href="#InnoDB和MyISAM的索引区别" class="headerlink" title="InnoDB和MyISAM的索引区别"></a>InnoDB和MyISAM的索引区别</h4><p>MyISAM索引文件和数据文件是分离的，索引文件仅保存数据的地址</p><p>InnoDB中，数据文件本身就是按B+Tree组织的一个索引结构，它的叶节点就保存了完整的数据</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol><li>大大加快数据的检索速度;</li><li>创建唯一性索引，保证数据库表中每一行数据的唯一性;</li><li>加速表和表之间的连接;</li><li>在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间。</li></ol><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol><li>索引需要占物理空间。</li><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度。</li></ol><p><img src="Data-Structure/mysql_diff.jpg" alt></p><h4 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h4><ul><li>如果是联合索引，则把=放在最前面，范围&lt;&gt;between放在最后，因为从左往右匹配</li><li>有了’AB’索引，就不用’A’索引了</li><li>索引列匹配的时候，索引不要参与计算</li><li>索引项尽量小</li><li>数据量小的表不要建索引</li><li>索引不是越多越好，因为数据的变更（增删改）都需要维护索引，而且更多的索引意味着也需要更多的空间</li><li>索引值太单一，比如性别，就不要建索引</li><li>更新非常频繁的数据也不要建索引</li></ul><h4 id="以下情况没有索引效果"><a href="#以下情况没有索引效果" class="headerlink" title="以下情况没有索引效果"></a>以下情况没有索引效果</h4><ul><li>Like “%xxx”，Like的参数不能以通配符开头</li><li>not in ， !=</li><li>对列进行函数运算的情况（如 where md5(password) = “xxxx”）</li><li>WHERE index=1 OR A=10</li><li>int类型的数据 不好做索引</li></ul><p>速学路径：</p><p><a href="http://www.cnblogs.com/zlcxbb/p/5757245.html" target="_blank" rel="noopener">http://www.cnblogs.com/zlcxbb/p/5757245.html</a></p><h3 id="平衡二叉树-AVL树"><a href="#平衡二叉树-AVL树" class="headerlink" title="平衡二叉树(AVL树)"></a>平衡二叉树(AVL树)</h3><blockquote><p>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树</p></blockquote><h4 id="平衡因子"><a href="#平衡因子" class="headerlink" title="平衡因子"></a>平衡因子</h4><p>将二叉树上结点的左子树深度减去右子树深度的值，也只能是-1，0，1</p><p>速学路径</p><p><a href="http://www.jianshu.com/p/db5529e91f4b" target="_blank" rel="noopener">http://www.jianshu.com/p/db5529e91f4b</a></p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p><img src="Data-Structure/red-black-tree.png" alt></p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>每个节点要么是红色，要么是黑色。</li><li>根节点必须是黑色</li><li>红色节点不能连续（也即是，红色节点的孩子和父亲都不能是红色）。</li><li>对于每个节点，从该点至<code>null</code>（树尾端）的任何路径，都含有相同个数的黑色节点。</li><li>每个空叶子节点必须是黑色的；</li></ol><p>速学路径</p><p><a href="http://www.jianshu.com/p/f4639d0cc887" target="_blank" rel="noopener">http://www.jianshu.com/p/f4639d0cc887</a></p><p><a href="http://www.importnew.com/21818.html" target="_blank" rel="noopener">http://www.importnew.com/21818.html</a></p><p><a href="http://www.importnew.com/21822.html" target="_blank" rel="noopener">http://www.importnew.com/21822.html</a></p><p><a href="http://www.jianshu.com/p/23b84ba9a498" target="_blank" rel="noopener">http://www.jianshu.com/p/23b84ba9a498</a></p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h4><p><a href="http://blog.csdn.net/shangruo/article/details/8491733" target="_blank" rel="noopener">http://blog.csdn.net/shangruo/article/details/8491733</a></p><h4 id="二次探测法"><a href="#二次探测法" class="headerlink" title="二次探测法"></a>二次探测法</h4><p><a href="http://blog.csdn.net/xyzbaihaiping/article/details/51607770" target="_blank" rel="noopener">http://blog.csdn.net/xyzbaihaiping/article/details/51607770</a></p><p><img src="Data-Structure/ercitance.png" alt></p><h2 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><blockquote><p>每步将一个待排序的记录，按其顺序码大小插入到前面已经排序的字序列的合适位置（从后向前找到合适位置后），直到全部插入排序完为止。</p></blockquote><p><img src="Data-Structure/charupaixu.png" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i,j;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=L-&gt;length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;r[i] &lt; L-&gt;r[i<span class="number">-1</span>])&#123;    <span class="comment">//如果前者大于后者</span></span><br><span class="line">      L-&gt;r[<span class="number">0</span>]=L-&gt;r[i];          <span class="comment">//把后者保存在暂存区r[0]里</span></span><br><span class="line">      <span class="keyword">for</span>(j=i<span class="number">-1</span>;L-&gt;r[j] &gt; L-&gt;r[<span class="number">0</span>];j--)&#123;</span><br><span class="line">        L-&gt;r[j+<span class="number">1</span>]=L-&gt;r[j];      <span class="comment">//后者放入前者的值，如果前者的前者比暂存区的大，则再次交换</span></span><br><span class="line">      &#125;</span><br><span class="line">      L-&gt;r[j+<span class="number">1</span>]=L-&gt;r[<span class="number">0</span>];        <span class="comment">//再把暂存区的值拿出来</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertsort</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>&#123;                </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; arr.length; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt; arr[i<span class="number">-1</span>])&#123;</span><br><span class="line"><span class="comment">//注意[0,i-1]都是有序的。如果待插入元素比arr[i-1]还大则无需再与[i-1]前面的元素进行比较了，反之则进入if语句</span></span><br><span class="line">                <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">                <span class="keyword">int</span> j;</span><br><span class="line">                <span class="keyword">for</span>(j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j --)&#123;                </span><br><span class="line">                        arr[j+<span class="number">1</span>] = arr[j];<span class="comment">//把比temp大或相等的元素全部往后移动一个位置            </span></span><br><span class="line">                &#125;</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;<span class="comment">//把待排序的元素temp插入腾出位置的(j+1)</span></span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>java实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] list)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = list.length;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">int</span> j =  <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = list[i];</span><br><span class="line">        <span class="comment">//假如temp比前面的值小，则将前面的值后移</span></span><br><span class="line">        <span class="keyword">for</span>(j = i ; j &gt; <span class="number">0</span> &amp;&amp; temp &lt; list[j-<span class="number">1</span>] ; j --)</span><br><span class="line">        &#123;</span><br><span class="line">        list[j] = list[j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        list[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为O[n^2^]</p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><blockquote><p>有间隔的直接插入排序</p></blockquote><p><img src="Data-Structure/xierpaixu.png" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(SQLite *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i,j;</span><br><span class="line">  <span class="keyword">int</span> increment = L-&gt;length;</span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">    increment = increment/<span class="number">3</span>+<span class="number">1</span>;        <span class="comment">//先确定间距</span></span><br><span class="line">    <span class="keyword">for</span>(i = increment+<span class="number">1</span>;i&lt;=L-&gt;length;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(L-&gt;r[i] &lt; L-&gt;r[i-increment])&#123;        <span class="comment">//比较相隔increment的两值大小</span></span><br><span class="line">        L-&gt;r[<span class="number">0</span>]=L-&gt;r[i];</span><br><span class="line">        <span class="keyword">for</span>(j=i-increment;j&gt;<span class="number">0</span>&amp;&amp;L-&gt;r[<span class="number">0</span>]&lt;L-&gt;r[j];j-=increment)&#123;   <span class="comment">//和直接插入法一个意思</span></span><br><span class="line">          L-&gt;r[j+increment]=L-&gt;r[j];</span><br><span class="line">        &#125;</span><br><span class="line">        L-&gt;r[j+increment]=L-&gt;r[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(increment&gt;<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>java实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="comment">//每次将步长缩短为原来的一半</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> increment = data.length / <span class="number">2</span>; increment &gt; <span class="number">0</span>; increment /= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = increment; i &lt; data.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = data[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &gt;= increment; j -= increment)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(temp &lt; data[j - increment])<span class="comment">//如想从小到大排只需修改这里</span></span><br><span class="line">                &#123;</span><br><span class="line">                    data[j] = data[j - increment];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            data[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当n无穷大的时候，可以减少到n(log~2~n)^2^</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><blockquote><p>选择一个基准，将比起大的数放在一边，小的数放到另一边。对这个数的两边再递归上述方法。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)  <span class="comment">/*如果左边索引大于或者等于右边的索引就代表已经整理完成一个组了*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = left;</span><br><span class="line">    <span class="keyword">int</span> j = right;</span><br><span class="line">    <span class="keyword">int</span> key = a[left];</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)    <span class="comment">/*控制在当组内寻找一遍*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; key &lt;= a[j])</span><br><span class="line">        <span class="comment">/*而寻找结束的条件就是，1，找到一个小于或者大于key的数（大于或小于取决于你想升</span></span><br><span class="line"><span class="comment">        序还是降序）2，没有符合条件1的，并且i与j的大小没有反转*/</span> </span><br><span class="line">        &#123;</span><br><span class="line">            j--;<span class="comment">/*向前寻找*/</span></span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        <span class="comment">/*找到一个这样的数后就把它赋给前面的被拿走的i的值（如果第一次循环且key是</span></span><br><span class="line"><span class="comment">        a[left]，那么就是给key）*/</span></span><br><span class="line">          </span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; key &gt;= a[i])</span><br><span class="line">        <span class="comment">/*这是i在当组内向前寻找，同上，不过注意与key的大小关系停止循环和上面相反，</span></span><br><span class="line"><span class="comment">        因为排序思想是把数往两边扔，所以左右两边的数大小与key的关系相反*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        a[j] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    a[i] = key;             <span class="comment">/*当在当组内找完一遍以后就把中间数key回归*/</span></span><br><span class="line">    sort(a, left, i - <span class="number">1</span>);   <span class="comment">/*最后用同样的方式对分出来的左边的小组进行同上的做法*/</span></span><br><span class="line">    sort(a, i + <span class="number">1</span>, right);  <span class="comment">/*用同样的方式对分出来的右边的小组进行同上的做法*/</span></span><br><span class="line">                            <span class="comment">/*当然最后可能会出现很多分左右，直到每一组的i = j 为止*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>java实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] list, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = start;</span><br><span class="line">    <span class="keyword">int</span> j = end;</span><br><span class="line">    <span class="keyword">int</span> key = list[start]; <span class="comment">//默认首位是key</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; key &lt;= list[j])</span><br><span class="line">        &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        list[i] = list[j];</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; key &gt;= list[i])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        list[j] = list[i];</span><br><span class="line">    &#125;</span><br><span class="line">    list[i] = key;</span><br><span class="line">    sort(list, start, i - <span class="number">1</span>);</span><br><span class="line">    sort(list, i + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好情况是O(nlogn)，最差情况是O(n^2^)且不稳定</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><blockquote><p>n-1次的循环比较，然后选出最小数的下标，然后进行交换</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(SQList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i,j,min;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;L-&gt;length;i++)&#123;</span><br><span class="line">    min = i;</span><br><span class="line">    <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;L-&gt;length;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(L-&gt;r[j] &lt; L-&gt;r[min])&#123;</span><br><span class="line">        min = j;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(i!=min)&#123;</span><br><span class="line">        swap(L,i,min);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>java写法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, min, temp, len = arr.length;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">min = i;</span><br><span class="line"><span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; j++)</span><br><span class="line"><span class="keyword">if</span> (arr[min] &gt; arr[j])</span><br><span class="line">min = j;</span><br><span class="line">temp = arr[min];</span><br><span class="line">arr[min] = arr[i];</span><br><span class="line">arr[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><blockquote><ol><li>比较相邻的元素。 如果第一个比第二个大，就交换他们两个。</li><li>从开始第一对到结尾的最后一对，每对相邻元素都作同样的工作，。 这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol></blockquote><p><strong>用C写一个冒泡排序</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble</span><span class="params">(<span class="keyword">int</span> r[n])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> exchange=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n &amp;&amp; exchange=<span class="number">1</span>; i++) <span class="comment">//如果为0，说明已经有序</span></span><br><span class="line">&#123;</span><br><span class="line">      exchange=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n-i;j++) </span><br><span class="line"><span class="keyword">if</span> (r[j]&gt;r[j+<span class="number">1</span>])&#123;   <span class="comment">//注意是从头开始比较</span></span><br><span class="line">temp=r[j+<span class="number">1</span>];</span><br><span class="line">r[j+<span class="number">1</span>]=r[j];</span><br><span class="line">r[j]=temp;</span><br><span class="line">exchange=<span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用Java写一个冒泡排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 排序器接口(策略模式: 将算法封装到具有共同接口的独立的类中使得它们可以相互替换)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>骆昊</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sorter</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 排序</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> list 待排序的数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] list)</span></span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 排序</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> list 待排序的数组</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> comp 比较两个对象的比较器</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] list, Comparator&lt;T&gt; comp)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>骆昊</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSorter</span> <span class="keyword">implements</span> <span class="title">Sorter</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> swapped = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, len = list.length; i &lt; len &amp;&amp; swapped; ++i) &#123;</span><br><span class="line">            swapped = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (list[j].compareTo(list[j + <span class="number">1</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    T temp = list[j];</span><br><span class="line">                    list[j] = list[j + <span class="number">1</span>];</span><br><span class="line">                    list[j + <span class="number">1</span>] = temp;</span><br><span class="line">                    swapped = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] list, Comparator&lt;T&gt; comp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> swapped = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, len = list.length; i &lt; len &amp;&amp; swapped; ++i) &#123;</span><br><span class="line">            swapped = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (comp.compare(list[j], list[j + <span class="number">1</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    T temp = list[j];</span><br><span class="line">                    list[j] = list[j + <span class="number">1</span>];</span><br><span class="line">                    list[j + <span class="number">1</span>] = temp;</span><br><span class="line">                    swapped = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><blockquote><p>大顶堆：每个结点的值都大于等于其左右孩子结点的值</p><p>小顶堆：每个结点的值都小于等于其左右孩子结点的值</p><p>将待排的序列构成一个大顶堆，然后取走堆顶（最大值），然后再调整大顶堆，再取走堆顶，如此往复</p><p>每次取走堆顶后，把堆顶替换成之前最后的那个元素，然后再重新排序</p></blockquote><p>最好和最差的情况都是O(nlogn)但不稳定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arrayLength=a.length;</span><br><span class="line">    <span class="comment">//循环建堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arrayLength-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//建堆</span></span><br><span class="line">        buildMaxHeap(a,arrayLength-<span class="number">1</span>-i);</span><br><span class="line">        <span class="comment">//交换堆顶和最后一个元素</span></span><br><span class="line">        swap(a,<span class="number">0</span>,arrayLength-<span class="number">1</span>-i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对data数组从0到lastIndex建大顶堆</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> lastIndex)</span></span>&#123;</span><br><span class="line">    <span class="comment">//从lastIndex处节点（最后一个节点）的父节点开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=(lastIndex-<span class="number">1</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="comment">//k保存正在判断的节点</span></span><br><span class="line">        <span class="keyword">int</span> k=i;</span><br><span class="line">        <span class="comment">//如果当前k节点的子节点存在</span></span><br><span class="line">        <span class="keyword">while</span>(k*<span class="number">2</span>+<span class="number">1</span>&lt;=lastIndex)&#123;</span><br><span class="line">            <span class="comment">//k节点的左子节点的索引</span></span><br><span class="line">            <span class="keyword">int</span> biggerIndex=<span class="number">2</span>*k+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//如果biggerIndex小于lastIndex，即biggerIndex+1代表的k节点的右子节点存在</span></span><br><span class="line">            <span class="keyword">if</span>(biggerIndex&lt;lastIndex)&#123;</span><br><span class="line">                <span class="comment">//若果右子节点的值较大</span></span><br><span class="line">                <span class="keyword">if</span>(data[biggerIndex]&lt;data[biggerIndex+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="comment">//biggerIndex总是记录较大子节点的索引</span></span><br><span class="line">                    biggerIndex++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果k节点的值小于其较大的子节点的值</span></span><br><span class="line">            <span class="keyword">if</span>(data[k]&lt;data[biggerIndex])&#123;</span><br><span class="line">                <span class="comment">//交换他们</span></span><br><span class="line">                swap(data,k,biggerIndex);</span><br><span class="line">                <span class="comment">//将biggerIndex赋予k，开始while循环的下一次循环，重新保证k节点的值大于其左右子节点的值</span></span><br><span class="line">                k=biggerIndex;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=data[i];</span><br><span class="line">    data[i]=data[j];</span><br><span class="line">    data[j]=tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>速学路径</p><p><a href="http://blog.csdn.net/xiaoxiaoxuewen/article/details/7570621/" target="_blank" rel="noopener">http://blog.csdn.net/xiaoxiaoxuewen/article/details/7570621/</a></p><p><a href="http://www.cnblogs.com/kkun/archive/2011/11/23/2260286.html" target="_blank" rel="noopener">http://www.cnblogs.com/kkun/archive/2011/11/23/2260286.html</a></p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><blockquote><p>把n个有序的子序列两两归并，直到归并成一个序列</p></blockquote><p>最好和最差的情况都是O(nlogn)但稳定</p><p><img src="Data-Structure/guibin.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] gb_sort(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="comment">// 左边</span></span><br><span class="line">        gb_sort(nums, low, mid);</span><br><span class="line">        <span class="comment">// 右边</span></span><br><span class="line">        gb_sort(nums, mid + <span class="number">1</span>, high);</span><br><span class="line">        <span class="comment">// 左右归并</span></span><br><span class="line">        merge(nums, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = low;<span class="comment">// 左指针</span></span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;<span class="comment">// 右指针</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 把较小的数先移到新数组中</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; nums[j]) &#123;</span><br><span class="line">            temp[k++] = nums[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把左边剩余的数移入数组</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        temp[k++] = nums[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把右边边剩余的数移入数组</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">        temp[k++] = nums[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把新数组中的数覆盖nums数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k2 = <span class="number">0</span>; k2 &lt; temp.length; k2++) &#123;</span><br><span class="line">        nums[k2 + low] = temp[k2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>速学路径</p><p><a href="http://blog.csdn.net/yinjiabin/article/details/8265827/" target="_blank" rel="noopener">http://blog.csdn.net/yinjiabin/article/details/8265827/</a></p><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><blockquote><p>从序列的个位开始排列，然后到十位开始排列，直到最高的位数</p></blockquote><p>最好和最坏的情况都是O(d(n+rd))</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">radix_sort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] &gt; max)&#123;</span><br><span class="line">            max = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (max&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        max /= <span class="number">10</span>;</span><br><span class="line">        time++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> max_sd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] tempArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][array.length];</span><br><span class="line">    <span class="keyword">int</span>[] order = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">while</span> (m&lt;time)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sd = (array[i] / n) % <span class="number">10</span>;</span><br><span class="line">            tempArr[sd][order[sd]] = array[i];</span><br><span class="line">            order[sd]++;</span><br><span class="line">            <span class="keyword">if</span> (sd&gt;max_sd)&#123;</span><br><span class="line">                max_sd = sd;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;order[i] != <span class="number">0</span> &amp;&amp; j&lt;order[i];j++)&#123;</span><br><span class="line">                array[k++] = tempArr[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            order[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n *= <span class="number">10</span>;</span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        m++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>速学路径</p><p><a href="http://blog.chinaunix.net/uid-26722078-id-3668671.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-26722078-id-3668671.html</a></p><p><a href="http://www.cnblogs.com/kkun/archive/2011/11/23/2260275.html" target="_blank" rel="noopener">http://www.cnblogs.com/kkun/archive/2011/11/23/2260275.html</a></p><h3 id="各类算法比较"><a href="#各类算法比较" class="headerlink" title="各类算法比较"></a>各类算法比较</h3><p><img src="Data-Structure/time_al.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;总结一下数据结构的知识，以便之后忘记了可以翻阅，哈哈，就像是做了一次备份哇&lt;/p&gt;
&lt;h2 id=&quot;基本概念与术语&quot;&gt;&lt;a href=&quot;#基本概念与术语&quot; class=&quot;headerlink&quot; title=&quot;基本概念与术语&quot;&gt;&lt;/a&gt;基本概念与术语&lt;/h2&gt;&lt;h3 id=&quot;
      
    
    </summary>
    
      <category term="Algorithm" scheme="https://barry215.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="https://barry215.github.io/tags/algorithm/"/>
    
      <category term="data_structure" scheme="https://barry215.github.io/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>【转】Web开发的历史与未来</title>
    <link href="https://barry215.github.io/2016/11/15/Web%20history%20and%20future/"/>
    <id>https://barry215.github.io/2016/11/15/Web history and future/</id>
    <published>2016-11-15T08:12:18.000Z</published>
    <updated>2017-01-25T04:50:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网页的历史"><a href="#网页的历史" class="headerlink" title="网页的历史"></a>网页的历史</h2><h3 id="first"><a href="#first" class="headerlink" title="first"></a>first</h3><ul><li>1990下半年，第一个浏览器(World Wide Web,同时也是WYSIWYG编辑器)、第一个web server, 第一版http协议（0.9,only one method）， by Tim Berners-Lee</li><li>第一个html格式：在第一个浏览器与第一个服务器之间，通过第一个http协议传输的文档的格式；事实 上的html是跟随着浏览器实现的演化而不断演化的</li><li>html标准：mid-1993,fisrt html draft 诞生；1994 html2.0正式发布；用于协调各浏览器厂商的实现</li></ul><h3 id="浏览器、服务器、html及相关标准的演化"><a href="#浏览器、服务器、html及相关标准的演化" class="headerlink" title="浏览器、服务器、html及相关标准的演化"></a>浏览器、服务器、html及相关标准的演化</h3><ul><li><code>&lt;a&gt;</code> 链接 </li><li><code>&lt;img&gt;</code></li><li>form and form based file upload</li><li>frameset and iframe</li><li>table and table based layout</li><li>css</li><li>javascript</li><li>cookie</li><li>浏览器大战、web标准化、modern web standard design</li></ul><h3 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h3><ul><li>空前统一的标准化，微软的屈服</li><li>从文档到应用</li><li>从page到api</li></ul><h3 id="link"><a href="#link" class="headerlink" title="link"></a>link</h3><ul><li>浏览器的历史 <a href="https://en.wikipedia.org/wiki/History_of_the_web_browser" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/History_of_the_web_browser</a></li><li>first web browser <a href="https://en.wikipedia.org/wiki/WorldWideWeb" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/WorldWideWeb</a></li><li>first web server <a href="https://en.wikipedia.org/wiki/Web_server" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Web_server</a></li><li>first http protocol <a href="https://www.w3.org/Protocols/HTTP/AsImplemented.html" target="_blank" rel="noopener">https://www.w3.org/Protocols/HTTP/AsImplemented.html</a></li><li>http <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#History" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#History</a></li><li>html <a href="https://en.wikipedia.org/wiki/HTML#History" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/HTML#History</a></li><li>浏览器演变史 <a href="http://blog.csdn.net/vanessa219/article/details/4601045" target="_blank" rel="noopener">http://blog.csdn.net/vanessa219/article/details/4601045</a></li><li>形形色色的浏览器 <a href="http://liulanmi.com/" target="_blank" rel="noopener">http://liulanmi.com/</a></li></ul><h2 id="服务端页面生成"><a href="#服务端页面生成" class="headerlink" title="服务端页面生成"></a>服务端页面生成</h2><h3 id="网页文件"><a href="#网页文件" class="headerlink" title="网页文件"></a>网页文件</h3><p><img src="http://tmy-course.oss-cn-beijing.aliyuncs.com/web-history/Static-Page.png" alt="HTML"></p><p>编辑网页，存为文件，上传到服务器</p><h3 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h3><p><img src="http://tmy-course.oss-cn-beijing.aliyuncs.com/web-history/CGI.png" alt="CGI"></p><ul><li>CGI可以视作是访问WEB服务器的接口协议，利用进程间输入输出通信，和WebServer进行通信，从而动态（基于用户的请求）的生成页面<br>想想odbc与数据库的关系</li><li>任何编程语言都可以实现cgi：c语言、perl<br>编程复杂，因为这些语言并非为web而生</li></ul><h3 id="网络脚本语言"><a href="#网络脚本语言" class="headerlink" title="网络脚本语言"></a>网络脚本语言</h3><p><img src="http://tmy-course.oss-cn-beijing.aliyuncs.com/web-history/PHP.png" alt="PHP"></p><ul><li>php： 专门为web而生的语言（脚本类型），提供与web server进行互动的各种驱动与库</li><li>各大语言厂商相继提出各种P,即服务端页面编程机制或环境，如IIS+asp、Servlet+jsp，实际上即面向web开发的专门实现</li><li>大大简化了动态页面的生成和编程</li></ul><h3 id="SSH：Struts-spring-hibernate"><a href="#SSH：Struts-spring-hibernate" class="headerlink" title="SSH：Struts + spring + hibernate"></a>SSH：Struts + spring + hibernate</h3><p><img src="http://assets.tianmaying.com/md-image/600ed36961e2dbb3952809854b780b26.png" alt="SSH"></p><ul><li>Struts对请求Url进行解析，通过Command模式把请求指配到Action对象上；并提供若干Intecepter构造自己的stack;允许通过xml配置文件的方式对页面流转流程进行灵活定义</li><li>通过spring进行注入，解决依赖性、控制反转Ioc等问题</li><li>hibernate 解决数据库的存储与orm等编程的简化</li><li>jsp 解决页面生成</li></ul><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p><img src="http://tmy-course.oss-cn-beijing.aliyuncs.com/web-history/MVC.png" alt="RAILS"></p><ul><li>router: 解析url请求，分派到相应的controller</li><li>controller: 处理请求，调用model，验证业务逻辑及流程，生成view</li><li>model: 执行业务逻辑、访问数据库</li><li>view: 提供页面模板，动态绑定controller提供的数据，生成html页面</li><li>ruby on rails是代表性的MVC框架，大大简化了服务端的web页面的生成</li></ul><h2 id="客户端页面生成"><a href="#客户端页面生成" class="headerlink" title="客户端页面生成"></a>客户端页面生成</h2><h3 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h3><ul><li>客户端数据校验，譬如必填、数字文本类型</li><li>页面动态效果，譬如对话框、<code></code>、slide</li></ul><h3 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h3><p><img src="http://tmy-course.oss-cn-beijing.aliyuncs.com/web-history/AJAX.png" alt="AJAX"></p><ul><li>基于服务端状态（即公共状态）进行局部更新<br>异步编程，动态刷新基于json数据而非html，提升通信效率客户端页面生成，局部更新</li><li>jquery 为原生的javascript提供各种简化编程的库，譬如ajax、dom操作、动画等</li></ul><h3 id="前端MVC：Backbone-Angular-ember"><a href="#前端MVC：Backbone-Angular-ember" class="headerlink" title="前端MVC：Backbone/Angular/ember"></a>前端MVC：Backbone/Angular/ember</h3><p><img src="http://tmy-course.oss-cn-beijing.aliyuncs.com/web-history/Frontend-MVC.png" alt="FMVC"></p><ul><li>将mvc的设计模式引入到客户端,使js向结构化编程演进</li><li>大量功能前移到浏览器内完成，服务端逐渐简化为api server模式，即只生成json,html是在浏览器里动态生成。</li></ul><h3 id="SPA：单页应用"><a href="#SPA：单页应用" class="headerlink" title="SPA：单页应用"></a>SPA：单页应用</h3><p><img src="http://ww2.sinaimg.cn/large/63918611gw1e7ehv63rd4j20im0cjmxv.jpg" alt="SPA"></p><ul><li>后端：单个静态页面即首页 + json-based api server</li><li>前端：即首页里引入的各种js代码</li><li>优点：<br>反应迅速，交互体验好，适合ui操作密集型的应用，如游戏、在线设计类利于前后端的分离开发</li><li>缺点：SEO不友好；首屏问题</li></ul><h3 id="Real-Time-Web-APP"><a href="#Real-Time-Web-APP" class="headerlink" title="Real Time Web APP"></a>Real Time Web APP</h3><ul><li>服务端：推送(push not pull)</li><li>客户端：轮询、长连接、WEB socket</li><li>数据驱动+DOM绑定+双向更新</li></ul><h3 id="云编程"><a href="#云编程" class="headerlink" title="云编程"></a>云编程</h3><ul><li>云端编程：不是自行开发，而是使用类似leancloud.cn等云服务来提供各种api</li><li>多后端应用：既然前端与后端的通讯仅仅基于WEB API,则后端完全可以通过组合多个云服务来实现，譬如数据放couchDB，新闻放weibo、社交用微信、认证用oauth、搜索用google、各类业务诸如CMS、OA、CRM等等均有对应的云服务</li></ul><h4 id="link-1"><a href="#link-1" class="headerlink" title="link"></a>link</h4><ul><li><a href="http://www.tianmaying.com/tutorial/web-history" target="_blank" rel="noopener">http://www.tianmaying.com/tutorial/web-history</a></li><li><a href="http://blog.jobbole.com/45169/" target="_blank" rel="noopener">http://blog.jobbole.com/45169/</a></li><li><a href="http://www.zhihu.com/question/28207685" target="_blank" rel="noopener">http://www.zhihu.com/question/28207685</a></li><li><a href="http://todomvc.com/" target="_blank" rel="noopener">http://todomvc.com/</a></li></ul><h2 id="服务端组件生成"><a href="#服务端组件生成" class="headerlink" title="服务端组件生成"></a>服务端组件生成</h2><h3 id="Isomorphic-JavaScript"><a href="#Isomorphic-JavaScript" class="headerlink" title="Isomorphic JavaScript"></a>Isomorphic JavaScript</h3><ul><li>node.js: javascript的迅猛发展，v8+node.js的出现，宣布js进入服务端编程领域</li><li>ECMAScript6等新一代js语法标准，引入各类高级语言特性</li><li>出现express.js等类似传统服务端mvc的框架</li><li>Isomorphic javascript: 前端+后端全部使用javacript技术栈进行开发<br>共享业务逻辑共享页面模板共享各种代码</li></ul><h3 id="universal-JavaScript"><a href="#universal-JavaScript" class="headerlink" title="universal JavaScript"></a>universal JavaScript</h3><ul><li>为解决spa的首屏问题，出现动态加载js的技术<br>如lazo.js, Rendr.js</li><li>出现页面组件化技术<br>不同于页面模板，仅生成html，而是同时生成html+js，即可重用的前端组件代码</li><li>通过在服务端使用页面组件化技术（这对使用node.js的后端应用而言，不言而喻），可用来解决seo问题<br>如react.js，不但可以浏览器端生成页面组件，也可在服务端生成组件(html+js)，从而搜索引擎可读取html，浏览器可执行js，各取所需，皆大欢喜</li><li>传统的后端编程框架纷纷将v8引擎嵌入自身，从而也可以调用react.js来进行js组件的server render<br>另一种做法是，将自身直接编译成js，譬如ruby的opa库,又或者另起炉灶的typescript</li></ul><p><img src="http://www.capitalone.io/assets/posts/why-is-everyone-talking-about-isomorphic-javascript/Isomorphism-diagram.png" alt="universal javascript"></p><h3 id="前端vs后端"><a href="#前端vs后端" class="headerlink" title="前端vs后端"></a>前端vs后端</h3><ul><li>传统后端语言有成熟的编程模型与代码库</li><li>新型前端开发有html5支持的各种新特性和通讯效率</li><li>不要问我页面是在前端生成，还是在后端生成？答案是：在前端中做好前端，在后端中生成前端</li></ul><h4 id="links"><a href="#links" class="headerlink" title="links"></a>links</h4><ul><li><a href="http://www.capitalone.io/blog/why-is-everyone-talking-about-isomorphic-javascript/" target="_blank" rel="noopener">http://www.capitalone.io/blog/why-is-everyone-talking-about-isomorphic-javascript/</a></li><li><a href="https://medium.com/@mjackson/universal-javascript-4761051b7ae9" target="_blank" rel="noopener">https://medium.com/@mjackson/universal-javascript-4761051b7ae9</a></li><li><a href="http://isomorphic.net/" target="_blank" rel="noopener">http://isomorphic.net/</a></li></ul><h2 id="前端的跨界"><a href="#前端的跨界" class="headerlink" title="前端的跨界"></a>前端的跨界</h2><h3 id="WEB-is-open-WEB-is-best"><a href="#WEB-is-open-WEB-is-best" class="headerlink" title="WEB is open,WEB is best!"></a>WEB is open,WEB is best!</h3><ul><li>WEB应用开发催生了最灵活和最复杂的编程语言及设计模式、积累了最丰富和最广泛的开源代码、培育了最大和最活跃的开发人群和社区</li><li>将WEB技术运用到一切领域去！</li></ul><h3 id="WEB在后端：服务WEB化"><a href="#WEB在后端：服务WEB化" class="headerlink" title="WEB在后端：服务WEB化"></a>WEB在后端：服务WEB化</h3><ul><li>桌面应用后端的WEB化、云端化</li><li>各类传统服务云服务化，基于WEB API</li><li>移动应用的后端</li><li>物联网的后端</li><li>…</li></ul><h3 id="WEB在前端-界面WEB化"><a href="#WEB在前端-界面WEB化" class="headerlink" title="WEB在前端:界面WEB化"></a>WEB在前端:界面WEB化</h3><ul><li>reapp.io: 使用javascipt + react.js开发移动WEB app</li><li>react native: 使用react.js 生成原生的移动端UI，实现跨平台界面开发</li><li>electron.js： 使用js+chromium开发跨平台的桌面应用</li><li>机顶盒应用开发</li><li>WEB OS</li><li>物联网应用开发</li><li>….</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote><p>WEB已死；WEB永生！</p></blockquote><p>转自博客 - <a href="https://www.zybuluo.com/openxy/note/385728" target="_blank" rel="noopener">https://www.zybuluo.com/openxy/note/385728</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;网页的历史&quot;&gt;&lt;a href=&quot;#网页的历史&quot; class=&quot;headerlink&quot; title=&quot;网页的历史&quot;&gt;&lt;/a&gt;网页的历史&lt;/h2&gt;&lt;h3 id=&quot;first&quot;&gt;&lt;a href=&quot;#first&quot; class=&quot;headerlink&quot; title=&quot;fir
      
    
    </summary>
    
      <category term="Internet" scheme="https://barry215.github.io/categories/Internet/"/>
    
    
      <category term="http" scheme="https://barry215.github.io/tags/http/"/>
    
      <category term="javascript" scheme="https://barry215.github.io/tags/javascript/"/>
    
      <category term="ajax" scheme="https://barry215.github.io/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>Java web 基础</title>
    <link href="https://barry215.github.io/2016/11/13/Web-backstage/"/>
    <id>https://barry215.github.io/2016/11/13/Web-backstage/</id>
    <published>2016-11-13T06:34:05.000Z</published>
    <updated>2017-04-06T14:26:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTTP服务器"><a href="#HTTP服务器" class="headerlink" title="HTTP服务器"></a>HTTP服务器</h3><p>HTTP服务器本质上也是一种应用程序——它通常运行在服务器之上，绑定服务器的IP地址并监听某一个tcp端口来接收并处理HTTP请求，这样客户端（一般来说是IE, Firefox，Chrome这样的浏览器）就能够通过HTTP协议来获取服务器上的网页（HTML格式）、文档（PDF格式）、音频（MP4格式）、视频（MOV格式）等等资源。下图描述的就是这一过程：</p><p> <img src="Web-backstage/sever_client.png" alt></p><p>其实绝大多数编程语言所包含的类库中也都实现了简单的HTTP服务器方便开发者使用：</p><ul><li>HttpServer (Java HTTP Server )</li><li>Python SimpleHTTPServer</li></ul><p>使用这些类库能够非常容易的运行一个HTTP服务器，它们都能够通过绑定IP地址并监听tcp端口来提供HTTP服务。</p><h4 id="Apache服务器"><a href="#Apache服务器" class="headerlink" title="Apache服务器"></a>Apache服务器</h4><p>Apache HTTP Server能够将某一个文本文件的内容通过HTTP协议返回到客户端，但是这个文本文件的内容是固定的——也就是说无论何时、任何人访问它得到的内容都是完全相同的，这样的资源我们称之为静态资源。</p><h4 id="Tomcat服务器"><a href="#Tomcat服务器" class="headerlink" title="Tomcat服务器"></a>Tomcat服务器</h4><p>Apache Tomcat是Apache基金会下的另外一个项目，它运行在JVM之上，和HTTP服务器一样，绑定IP地址并监听TCP端口。与Apache HTTP Server相比，Tomcat能够动态的生成资源并返回到客户端。动态资源与静态资源相反，在不同的时间、不同的客户端访问得到的内容是不同的。它也是一个servlet容器，可以认为是apache的扩展，但是可以独立于apache运行。</p><p><img src="Web-backstage/webtomcat.png" alt></p><h5 id="职责"><a href="#职责" class="headerlink" title="职责"></a>职责</h5><p>管理Servlet程序的生命周期将URL映射到指定的Servlet进行处理与Servlet程序合作处理HTTP请求——根据HTTP请求生成HttpServletResponse对象并传递给Servlet进行处理，将Servlet中的HttpServletResponse对象生成的内容返回给浏览器<br>虽然Tomcat也可以认为是HTTP服务器</p><h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><p><img src="Web-backstage/tomcat.png" alt></p><h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><p>Nginx——Ngine X，是一款自由的、开源的、高性能HTTP服务器和反向代理服务器</p><h5 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h5><p>反向代理服务器作用在服务器端，它在服务器端接收客户端的请求，然后将请求分发给具体的服务器进行处理，然后再将服务器的相应结果反馈给客户端。正向代理就是我们用VPN来访问外网的时候一样。</p><p><img src="Web-backstage/daili.jpg" alt></p><p>正向代理中，proxy和client同属一个LAN，对server透明；<br>反向代理中，proxy和server同属一个LAN，对client透明。<br>实际上proxy在两种代理中做的事都是代为收发请求和响应，不过从结构上来看正好左右互换了下，所以把后出现的那种代理方式叫成了反向代理。</p><h5 id="Tomcat和Nginx配合"><a href="#Tomcat和Nginx配合" class="headerlink" title="Tomcat和Nginx配合"></a>Tomcat和Nginx配合</h5><p>动静态资源分离——运用Nginx的反向代理功能分发请求：所有动态资源的请求交给Tomcat，而静态资源的请求（例如图片、视频、CSS、JavaScript文件等）则直接由Nginx返回到浏览器，这样能大大减轻Tomcat的压力。负载均衡，当业务压力增大时，可能一个Tomcat的实例不足以处理，那么这时可以启动多个Tomcat实例进行水平扩展，而Nginx的负载均衡功能可以把请求通过算法分发到各个不同的实例进行处理</p><p><img src="Web-backstage/Nginx_Tomcat.png" alt></p><h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>很久之前，我们的网页都是静态的，就是我们所看到的页面在编写好之后总是唯一的。后来有人便提出动态页面的概念，相应的就提出了Servlet。可以根据客户端的请求来判断返回什么页面。</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>负责处理客户请求，当客户请求来到时，Servlet容器获取请求，然后调用某个Servlet，并把Servlet的执行结果返回给客户。</p><h4 id="Servlet-生命周期"><a href="#Servlet-生命周期" class="headerlink" title="Servlet 生命周期"></a>Servlet 生命周期</h4><ul><li>Servlet 通过调用 <strong>init ()</strong> 方法进行初始化</li><li>Servlet 调用 <strong>service()</strong> 方法来处理客户端的请求</li><li>Servlet 通过调用 <strong>destroy()</strong> 方法终止（结束）</li><li>最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的</li></ul><h5 id="init-方法"><a href="#init-方法" class="headerlink" title="init() 方法"></a>init() 方法</h5><p>init 方法被设计成只调用一次。它在第一次创建 Servlet 时被调用，在后续每次用户请求时不再调用。因此，它是用于一次性初始化。</p><p>当用户调用一个 Servlet 时，就会创建一个 Servlet 实例，每一个用户请求都会产生一个新的线程，适当的时候移交给 doGet 或 doPost 方法。init() 方法简单地创建或加载一些数据，这些数据将被用于 Servlet 的整个生命周期。</p><p>init 方法的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="service-方法"><a href="#service-方法" class="headerlink" title="service() 方法"></a>service() 方法</h5><p>service() 方法是执行实际任务的主要方法。Servlet 容器（即 Web 服务器）调用 service() 方法来处理来自客户端（浏览器）的请求，并把格式化的响应写回给客户端。</p><p>每次服务器接收到一个 Servlet 请求时，服务器会产生一个新的线程并调用服务。service() 方法检查 HTTP 请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用 doGet、doPost、doPut，doDelete 等方法。</p><p>下面是该方法的特征：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest request, ServletResponse response)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service() 方法由容器调用，service 方法在适当的时候调用 doGet、doPost、doPut、doDelete 等方法。所以，您不用对 service() 方法做任何动作，您只需要根据来自客户端的请求类型来重载 doGet() 或 doPost() 即可。</p><p>doGet() 和 doPost() 方法是每次服务请求中最常用的方法。下面是这两种方法的特征。</p><h5 id="doGet-方法"><a href="#doGet-方法" class="headerlink" title="doGet() 方法"></a>doGet() 方法</h5><p>GET 请求来自于一个 URL 的正常请求，或者来自于一个未指定 METHOD 的 HTML 表单，它由 doGet() 方法处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Servlet 代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="doPost-方法"><a href="#doPost-方法" class="headerlink" title="doPost() 方法"></a>doPost() 方法</h5><p>POST 请求来自于一个特别指定了 METHOD 为 POST 的 HTML 表单，它由 doPost() 方法处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Servlet 代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="destroy-方法"><a href="#destroy-方法" class="headerlink" title="destroy() 方法"></a>destroy() 方法</h5><p>destroy() 方法只会被调用一次，在 Servlet 生命周期结束时被调用。destroy() 方法可以让您的 Servlet 关闭数据库连接、停止后台线程、把 Cookie 列表或点击计数器写入到磁盘，并执行其他类似的清理活动。</p><p>在调用 destroy() 方法之后，servlet 对象被标记为垃圾回收。destroy 方法定义如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 终止化代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h5><ol><li>web client发送一个request请求。</li><li>Servlet容器接收我们这个请求，把web client的请求的信息封装成一个HttpServletRequest对象，以及HttpServletResponse对象。</li><li>Servlet容器把我们的HttpServletRequest对象，以及HttpServletResponse对象封装成一个参数传递给我们的httpservlet的service()方法。</li><li>在service()里面我们通过读取我们的httpServletRequst里面的信息进行一些操作，然后写入一些信息进入我们的HttpServletResponse对象中。</li><li>我们的servlet容器把我们的HttpServletResponse返回给我们的webclint。</li></ol><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p><strong>XML配置</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>package.TestServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/UrlTest<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注解配置</strong></p><p>Servlet 3.0提供了注解(annotation)，使得不再需要在web.xml文件中进行Servlet的部署描述</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(name=<span class="string">"Servlet3Demo"</span>,urlPatterns=<span class="string">"/Servlet3Demo"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>注解WebServlet用来描述一个Servlet</p><p>name描述Servlet的名字(可选) </p><p>urlPatterns定义访问的URL</p></blockquote><h3 id="Jsp"><a href="#Jsp" class="headerlink" title="Jsp"></a>Jsp</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>JSP动态网页技术，是可以把Java语言嵌入到HTML页面上。</p><p>那时候Servlet是个大忙人，它既要处理显示效果，又要处理数据，又要处理页面跳转，耦合度高，不方便代码维护，为了解决这个问题，SUN公司联合其他公司制定了JSP动态网页技术标准。事实上jsp是一个特殊的Servlet实例，它跟其他Servlet一样被Servlet容器执行，在这之前它需要先被jsp容器转换成Servlet，这个过程是在服务器端产生的，在第一次编译之后该Servlet实例便常驻内存。</p><h4 id="jsp的运行机制"><a href="#jsp的运行机制" class="headerlink" title="jsp的运行机制"></a>jsp的运行机制</h4><ol><li>jsp容器判断URL中对应的Servlet实例是否存在Servlet队列，实则执行第五步，否则执行第二步。</li><li>jsp容器将jsp文件转换成Servlet源程序(.java)。</li><li>jsp容器将Servlet源程序编译成字节码文件(.class)。</li><li>Servlet容器加载字节码，创建该Servlet实例(该实例实际是返回给客户端的显示效果),此时会调用<code>jspInit()</code>进行初始化。</li><li>jsp容器将响应返回到到客户端。</li></ol><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>注释有以下两种：</p><ul><li>HTML注释：<code>&lt;!-- 注释内容 --&gt;</code>，这种方法注释在查看HTML源代码时可以被显示</li><li>jsp注释：<code>&lt;%-- 注释内容 --%&gt;</code>，通过这种方法注释用户是看不到的</li></ul><h4 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h4><blockquote><p> 通知jsp引擎的消息</p></blockquote><p>作用：设置jsp程序的属性以及由该jsp生成的serverlet里的属性</p><p>常用的编译指令有:</p><ul><li>page:该指令是针对当前页面的指令</li><li>include :用于指定如何包含另一个页面</li><li>taglib:用于定义和访问自定义标签</li></ul><h4 id="page-指令"><a href="#page-指令" class="headerlink" title="page 指令"></a>page 指令</h4><p>page指令主要用于定义当前jsp的全局指令，包括当前jsp所使用的脚本语言类型，需要导入Java包的列表等等,一般情况下page编译指令位于页面的最上方，一个页面可以有多个编译配置指令。</p><h5 id="JSP-的page模版"><a href="#JSP-的page模版" class="headerlink" title="JSP 的page模版"></a>JSP 的page模版</h5><p>最常用的是<code>import</code>，<code>contentType</code>，<code>pageEncoding</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">contentType</span>=<span class="string">"text/html;charset=UTF-8"</span> <span class="attr">pageEncoding</span>=<span class="string">"UTF-8"</span> %&gt;</span></span><br></pre></td></tr></table></figure><h5 id="指令解释"><a href="#指令解释" class="headerlink" title="指令解释"></a>指令解释</h5><ul><li><p>language：</p><p>声明当前JSP页面使用的脚本语言的种类。目前该属性的值只能为java，默认值也为java，所以通常无须设置。</p></li></ul><ul><li><p>import：</p><p>用来导入包。默认导入的包有：java.lang.<em>, javax.servlet.</em>, javax.servlet.http.<em>, javax,.servlet.jsp.</em>.</p><p>导入多个包时用一个import指令，各个包之间用“,”隔开。</p></li></ul><ul><li><p>contentType：</p><p>告知客户端，服务器对此次请求响应的正文格式(MIME类型)和编码字符集。默认为contentType=”text/html;charset=UTF-8ISO-8859-1”。如设置为：contentType=”text/html;charset=UTF-8”，就是告诉客户端，服务器响应的正文文件格式为text/html，这样客户端就会用默认的浏览器方式打开文件，而不用别的应用程序。charset=UTF-8告知客户端浏览器，服务器返回的文件编码格式为UTF-8，浏览器将按照UTF-8格式进行解码并且以UTF-8字符集进行页面显示。contentType的作用本质上相当于模拟了一个Http协议的消息头。contentType虽然写在JSP文件中，但是因为JSP文件其实并不能直接响应客户端请求，它必须编译成对应的Servlet以后才能响应请求。所以本质上这个contentType是针对Servlet的设置，即Servlet告诉客户端，我返回的文件(以流的形式,response.getWriter())的MIME类型为text/html,文件的编码字符集为UTF-8。</p></li></ul><ul><li><p>pageEncoding：</p><p>设定JSP源文件保存时所使用的编码。因为JSP文件要想响应客户端的请求，它就必须先被编译成一个Servlet，而Servlet是一个Java类，Java类在内存中是以Unicode进行编码的，如果JSP引擎(将JSP翻译成对应的Servlet)不知道JSP的编码格式，就无法进行解码，然后将其转换成内存中的Unicode编码。注意区分contentType的charset和pageEncoding，charset是响应时Servlet(JSP已经编译成了Servlet)告诉客户端浏览器”我“是以这种字符编码的，”你“也要以这种字符解码并显示，整个过程涉及服务器和客户端两方面，而pageEncoding是服务器端JSP文件告诉JSP引擎要以何种编码进行解码，即此时JSP还没被编译成Servlet，它是被编译成Servlet的前提准备工作，整个过程都发生在服务器端，与客户端无关。</p></li></ul><ul><li><p>session：</p><p>设定这个JSP页面是否支持session机制，默认为true，所以一般不需要设置，保持默认值即可。</p></li></ul><ul><li><p>errorPage：</p><p>指定错误处理页面的地址。如果本页面产生了异常或者错误，而该JSP页面没有对应的处理代码，此时就会自动调用该属性所指向的JSP页面。</p></li></ul><ul><li><p>isErrorPage：</p><p>和errorPage属性配合使用。设置本JSP页面是否为错误处理页面。</p></li></ul><ul><li><p>buffer：</p><p>指定输出缓冲区的大小。JSP的隐含对象out(JSP有九大隐含对象或者说内置对象)用于缓存JSP(其实是Servlet)对客户端浏览器的输出，默认值为8KB，可以设置为none，也可以设置为其他的值，单位为KB。</p></li></ul><ul><li><p>autoFlush：</p><p>当输出缓冲区即将溢出时，是否需要强制输出缓冲区的内容。设置为true时可以正常输出，设置为false时，则会在buffer溢出时产生一个异常。默认为true。</p></li></ul><ul><li><p>isELIgnored：</p><p>如果设定为真，那么JSP中的EL表达式被当成字符串处理。</p><p>比如下面这个表达式${2000/20}在isELIgnored＝”true”时输出为${2000/20}，而isELIgnored＝”false”时输出为100.0。默认为false。</p></li></ul><h4 id="include-指令"><a href="#include-指令" class="headerlink" title="include 指令"></a>include 指令</h4><p>include是jsp的静态包含指令，使用此指令可将一个外部文件包含到jsp程序中。外部文件可以是html文件也可以是jsp文件。</p><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ol><li>假如是jsp文件，在导入进来之前会先解析jsp文件中的语句。</li><li>在include指令中包含页面和被包含页面同一类型的参数不能被定义两次。</li></ol><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p><code>&lt;%@ include file = &quot;path&quot;%&gt;</code></p><p>该指令只有一个属性file，该指令用于指向要加载的文件的相对地址</p><h4 id="taglib-指令"><a href="#taglib-指令" class="headerlink" title="taglib 指令"></a>taglib 指令</h4><p>taglib指令是用来引用标签库并设置标签库前缀，说白了就是自定义自己的jsp标记。</p><h5 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h5><p><code>&lt;%@ taglib uri=&quot;标签库地址&quot; prefix = &quot;标签库前缀&quot; %&gt;</code></p><h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> prefix=<span class="string">"c"</span>%&gt;</span><br></pre></td></tr></table></figure><h5 id="使用标记方式"><a href="#使用标记方式" class="headerlink" title="使用标记方式"></a>使用标记方式</h5><p><code>&lt;标签库前缀:标签名 参数&gt;</code></p><h4 id="jsp-脚本元素"><a href="#jsp-脚本元素" class="headerlink" title="jsp 脚本元素"></a>jsp 脚本元素</h4><p>jsp脚本元素有以下三种：</p><ol><li>jsp声明语句</li><li>jsp表达式</li><li>jsp Scriptlets</li></ol><h5 id="jsp声明语句"><a href="#jsp声明语句" class="headerlink" title="jsp声明语句"></a>jsp声明语句</h5><p>jsp声明语句用于声明变量和方法，在jsp声明语句中声明的变量和方法对作为servlet的成员变量，在整个页面都有效。格式如下：<br><code>&lt;%! 声明变量或方法 %&gt;</code></p><h5 id="jsp表达式"><a href="#jsp表达式" class="headerlink" title="jsp表达式"></a>jsp表达式</h5><p>jsp表达式要求该表达式存在一个确定的值，该值会被显示在HTML页面上。格式如下：<br><code>&lt;%= 表达式 %&gt;</code></p><h5 id="jsp-Scriptlets"><a href="#jsp-Scriptlets" class="headerlink" title="jsp Scriptlets"></a>jsp Scriptlets</h5><p>jsp Scriptlets是一段java代码段。当需要对页面输出内容进行一些复杂的操作的时候就需要用到jsp Scriptlets，在jsp Scriptlets声明的变量在调用的时候分配内存，调用结束内存释放。jsp Scriptlets格式如下：<br><code>&lt;% java代码片段 %&gt;</code></p><h4 id="jsp-动作标签"><a href="#jsp-动作标签" class="headerlink" title="jsp 动作标签"></a>jsp 动作标签</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p><strong>编译指令</strong>是通知servlet引擎处理消息，只在jsp被转化成servlet的时候起作用。<br><strong>动作指令</strong>是在jsp被客户端请求时动态执行的。也就是说：每次客户端请求时都有可能被执行一次。</p><p>动作元素只有一种语法，它符合XML标准：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:action_name attribute=<span class="string">"value"</span> /&gt;</span><br></pre></td></tr></table></figure><p>jsp动作标签有以下几种(不全)：</p><ul><li><code>&lt;jsp:include&gt;</code></li><li><code>&lt;jsp:forward&gt;</code></li><li><code>&lt;jsp:param&gt;</code></li><li><code>&lt;jsp:plugin&gt;</code></li><li><code>&lt;jsp:useBean&gt;</code></li><li><code>&lt;jsp:setProperty&gt;</code></li><li><code>&lt;jsp:getProperty&gt;</code></li></ul><h5 id="jsp-include"><a href="#jsp-include" class="headerlink" title="jsp:include"></a>jsp:include</h5><p>包含标签，但它和包含指令不一样。</p><p><strong>区别</strong></p><p><strong>包含指令</strong>是将包含页面整合进jsp页面中再编译。</p><p><strong>包含标签</strong>包含的文件和原来的jsp文件是两个独立的文件，在运行时单独对包含文件进行编译，把结果发送到客户端。只有在运行jsp页面的时候才会加载这些包含文件。</p><p><strong>格式</strong><br><code>&lt;jsp:include page=&quot;被包含的页面&quot; flush=&quot;true|false&quot;&gt;&lt;/jsp:include&gt;</code> </p><ol><li>page:是被包含的文件的相对地址。 </li><li>flush:指定当缓冲区满时，是否将其清空。默认值为false。</li></ol><h5 id="jsp-forward"><a href="#jsp-forward" class="headerlink" title="jsp:forward"></a>jsp:forward</h5><p>转发标签，当代码运行到该标签会在服务器内重新链接到指定的地址，之后的代码不被执行。</p><p><strong>格式</strong></p><p><code>&lt;jsp:forward page=&quot;转发的地址&quot;&gt;&lt;/jsp:forward&gt;</code></p><h5 id="jsp-param"><a href="#jsp-param" class="headerlink" title="jsp:param"></a>jsp:param</h5><p>传递参数的标签。它是以”名-值”对的形式来表示参数的。</p><p><strong>格式</strong><br><code>&lt;jsp:param name=&quot;参数名&quot; value=&quot;参数值&quot;&gt;</code></p><p><strong>举例</strong></p><p>向<code>&lt;jsp:include&gt;</code>包含的文件传递参数</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:include page=<span class="string">"page name"</span> flush=<span class="string">"false"</span>&gt; </span><br><span class="line">  &lt;jsp:param name="parameter name" value="parameter value"&gt;&lt;/jsp:param&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/jsp:include&gt;</span><br></pre></td></tr></table></figure><p>向<code>&lt;jsp:forward&gt;</code>页面传递参数</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:forward page=<span class="string">"forward target"</span>&gt; </span><br><span class="line">  &lt;jsp:param name="parameter name" value="parameter value"&gt;&lt;/jsp:param&gt; </span><br><span class="line">  ...</span><br><span class="line">&lt;/jsp:forward&gt;</span><br></pre></td></tr></table></figure><p><strong>获取</strong></p><p>index.jsp</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;jsp:forward page=<span class="string">"login.jsp"</span>&gt;</span><br><span class="line">    &lt;jsp:param name=<span class="string">"userName"</span> value=<span class="string">"icarus"</span>/&gt;</span><br><span class="line">    &lt;jsp:param name=<span class="string">"password"</span> value=<span class="string">"123456"</span>/&gt;</span><br><span class="line">&lt;/jsp:forward&gt;</span><br></pre></td></tr></table></figure><p>login.jsp</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Login&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%--登陆页面--%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    String userName=request.getParameter(<span class="string">"userName"</span>);</span><br><span class="line">    String password=request.getParameter(<span class="string">"password"</span>);</span><br><span class="line">    out.println(userName);</span><br><span class="line">    out.print(<span class="string">"&lt;br/&gt;"</span>);</span><br><span class="line">    out.println(password);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h5 id="jsp-plugin"><a href="#jsp-plugin" class="headerlink" title="jsp:plugin"></a>jsp:plugin</h5><p>可以将服务器端的javaBean或Applet下载到本地客户端执行。语法格式如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:plugin type=<span class="string">"bean|applet"</span> code=<span class="string">"classFileName"</span> codeBase=<span class="string">"classFileURL"</span>&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/jsp:plugin&gt;</span><br></pre></td></tr></table></figure><ul><li>type：指定插件类型。是Bean还是Applet。</li><li>code：指定执行的类名。必须以扩展名”.class”结尾。</li><li>codeBase：指定被执行的java类所在目录。此外<code></code><br>相关的参数还有很多，这里只是举例必不可少的三个。</li></ul><h5 id="jsp-useBean"><a href="#jsp-useBean" class="headerlink" title="jsp:useBean"></a>jsp:useBean</h5><p>用来装载一个将在jsp页面中使用的javaBean。</p><p><strong>JavaBean</strong>是特殊的Java类，使用Java语言书写，并且遵守JavaBean API规范。</p><p>接下来给出的是JavaBean与其它Java类相比而言独一无二的特征：</p><ul><li>提供一个默认的无参构造函数。</li><li>需要被序列化并且实现了Serializable接口。<ul><li>Serializable接口是启用其序列化功能的接口。</li><li>序列化的目的是将数据分解成字节流，以便存储在文件中或在网络上传输</li></ul></li><li>可能有一系列可读写属性。</li><li>可能有一系列的”getter”或”setter”方法。</li></ul><p>语法格式如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:useBean id="beanInstanceName"class="package.class"scope="page|request|session|application"&gt;&lt;/jsp:useBean&gt;</span><br></pre></td></tr></table></figure><ul><li>id：指定javaBean的实例名。</li><li>class：指定javaBean的全限类名。</li><li>scope：指定javaBean的作用域。 <ul><li>page：指定javaBean实例只在本页面有限。 </li><li>request：指定JavaBean实例仅在本次请求有效。 </li><li>session：指定javaBean实例在本次会话有效。 </li><li>application：指定javaBean实例在本应用内一直有效。</li></ul></li></ul><h5 id="jsp-setProperty"><a href="#jsp-setProperty" class="headerlink" title="jsp:setProperty"></a>jsp:setProperty</h5><p>用于设置Bean内属性的值，它通过调用Bean的setter方法设置属性值。</p><p><strong>语法</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:setProperty name="beanInstanceName" property="propertyName" value="propertyValue"&gt;&lt;/jsp:setProperty&gt;</span><br></pre></td></tr></table></figure><h5 id="jsp-getProperty"><a href="#jsp-getProperty" class="headerlink" title="jsp:getProperty"></a>jsp:getProperty</h5><p>用于获取bean的属性值。语法格式如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:getProperty name="beanInstanceName" property="propertyName"&gt;&lt;/jsp:getProperty&gt;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><blockquote><p>bean中可以没有属性的声明，但必须有setter和getter方法，因为<code>&lt;jsp:setProperty&gt;</code>和<code>&lt;jsp:getProperty&gt;</code>是通过调用bean实例中的setter方法和getter方法实现取值和赋值工作的。</p></blockquote><p><strong>举例</strong></p><p>javaBean，User类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String userName,String password)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName=userName;</span><br><span class="line">        <span class="keyword">this</span>.password=password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>register.jsp</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;register&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;form action=<span class="string">"do_register.jsp"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">    用户名：&lt;input type=<span class="string">"text"</span> name=<span class="string">"userName"</span>/&gt;</span><br><span class="line">    密码：&lt;input type=<span class="string">"password"</span> name=<span class="string">"password"</span>/&gt;</span><br><span class="line">    &lt;input type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>do_register.jsp</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;do_register&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;jsp:useBean id=<span class="string">"user"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.frank.User"</span>/&gt; </span><br><span class="line">  </span><br><span class="line">&lt;jsp:setProperty name=<span class="string">"user"</span> property=<span class="string">"userName"</span>/&gt;</span><br><span class="line">&lt;jsp:setProperty name=<span class="string">"user"</span> property=<span class="string">"password"</span>/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;p&gt;用户名: </span><br><span class="line">   &lt;jsp:getProperty name=<span class="string">"user"</span> property=<span class="string">"userName"</span>/&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;p&gt;密码: </span><br><span class="line">   &lt;jsp:getProperty name=<span class="string">"user"</span> property=<span class="string">"password"</span>/&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="jsp-的四个作用域"><a href="#jsp-的四个作用域" class="headerlink" title="jsp 的四个作用域"></a>jsp 的四个作用域</h4><ul><li>page</li><li>request</li><li>session</li><li>application</li></ul><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><ol><li>page指当前页面有效。在一个jsp页面里有效</li><li>request 指在一次请求的全过程中有效，即从http请求到服务器处理结束，返回响应的整个过程，存放在HttpServletRequest对象中。在这个过程中可以使用forward方式跳转多个jsp。在这些页面里你都可以使用这个变量。</li><li>Session是用户全局变量，在整个会话期间都有效。只要页面不关闭就一直有效（或者直到用户一直未活动导致会话过期，默认session过期时间为30分钟，或调用HttpSession的invalidate()方法）。存放在HttpSession对象中 </li><li>application是程序全局变量，对每个用户每个页面都有效。存放在ServletContext对象中。它的存活时间是最长的，如果不进行手工删除，它们就一直可以使用 </li></ol><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>当数据只需要在下一个forward有用时，用request就够了。<br>若数据不只是在下一个forward有用时，就用session。<br>若数据包含上下文，环境信息之类的，用application。</p><h4 id="HTTP协议的无状态性"><a href="#HTTP协议的无状态性" class="headerlink" title="HTTP协议的无状态性"></a>HTTP协议的无状态性</h4><p>因为HTTP协议是无状态的，也就是说当用户发送一次请求给服务器之后，服务器响应客户端的请求，当同一个客户端再次发送请求给服务器时，服务器并不知道这个请求是同一个客户端发送的。而要保存用户的状态，涉及到两种技术，<code>Session</code>和<code>Cookie</code>，其中<code>Session</code>是保存在服务器端的，会随着会话的结束而销毁，而<code>Cookie</code>保存在客户端，可以保存较长一段时间，但是就因为<code>Cookie</code>保存在客户端，因此有不安全的风险。</p><h4 id="jsp-九大内置对象"><a href="#jsp-九大内置对象" class="headerlink" title="jsp 九大内置对象"></a>jsp 九大内置对象</h4><p>jsp内置对象由jsp规范进行初始化，主要有以下几种：</p><ul><li>request</li><li>response</li><li>pageContext</li><li>session</li><li>application</li><li>out</li><li>config</li><li>page</li><li>exception</li></ul><h5 id="request对象"><a href="#request对象" class="headerlink" title="request对象"></a>request对象</h5><p>用于封装请求数据。一般用户在表单填写的数据会被封装成request对象，通过post方法传递给目标页面。request还相应提供了一些方法用于访问这些数据。主要方法有以下几个： </p><ul><li><code>void setAttribute(attributeName, attributeValue)</code>：用于设置属性值。 </li><li><code>Object getAttribute(attributeName, attributeValue)</code>：用于获取属性值。 </li><li><code>String getParameter(&quot;parameterName&quot;)</code>：获取参数值。 </li><li><code>Enumeration getParameterNames()</code>：获取所有的参数名的集合。 </li><li><code>String[] getParameterValues(&quot;parameterName&quot;)</code>：获取parameterName的所有属性值的数组。 </li><li><code>Map getParameterMap()</code>：获取所有属性名和属性值的Map对象。 </li><li><code>void setCharacterEncoding()</code>：设置编码格式。</li><li><code>getCookies</code>：获取所有Cookie对象</li><li><code>getSession</code>：获取和请求相关的会话</li><li><code>getRemoteAddr</code>：获取客户端的IP地址</li><li><code>getProtocol</code>：获取客户端向服务器端传送数据的协议名称</li><li><code>getMethod</code>：获取客户端向服务器端传送数据的方法</li><li><code>getInputStream</code>：返回请求输入流,获取请求中的数据</li></ul><p><strong>注意</strong></p><p>getParameter和getAttribute区别</p><ol><li>当两个Web组件之间为链接关系时，被链接的组件通过getParameter()方法来获得请求参数，</li><li>当两个Web组件之间为内部转发时，转发目标组件通过getAttribute()方法来和转发源组件共享request范围内的数据。</li><li>getParameter得到的都是String类型的，getAttribute则可以是对象</li><li>getParameter()是获取POST/GET传递的参数值，getAttribute()是获取SESSION的值</li></ol><p><strong>总结</strong></p><ul><li>一般通过表单和链接传递的参数使用getParameter</li><li>通过request.setAttribute(“name”,”jerry”)的方式赋值的使用request.getAttribute(“name”)</li></ul><p><strong>参考</strong></p><p><a href="http://blog.csdn.net/gavinloo/article/details/6552319" target="_blank" rel="noopener">JSP中getParameter和getAttribute区别</a></p><h5 id="response对象"><a href="#response对象" class="headerlink" title="response对象"></a>response对象</h5><p>用于封装响应数据，其作用域是本页面。主要方法如下： </p><ul><li><code>void addCookie(Cookie cookie)</code>：添加一个Cookie对象，用于在客户端保存特定信息。 </li><li><code>void addHeader(name, value</code>)：添加一个HTTP头信息，该头信息会被发送到客户端。 </li><li><code>setHeader</code>：设置指定名字的Http文件头信息</li><li><code>void containsHeader(name)</code>：判断是否含有名为”name”的头信息。 </li><li><code>void sendError(int)</code>：向客户端发送错误的状态码。 </li><li><code>void sendRedirect(url)</code>：向客户端发送重定向的url链接，让客户端跳转到该链接。 </li><li><code>void setContentType(contentType)</code>：设置MIME类型和编码方式。</li><li><code>getOutputStream</code>：返回到客户端的输出流对象</li></ul><h5 id="session对象"><a href="#session对象" class="headerlink" title="session对象"></a>session对象</h5><p>会话对象，用来记录每个客户端的访问状态。主要方法如下： </p><ul><li><code>Object getAttribute(name)</code>：获取session范围内名为name的属性值。 </li><li><code>void setAttribute(name, value)</code>：设置session范围内的属性。 </li><li><code>void removeAttribute(name)</code>：删除session范围内名为name的属性。 </li><li><code>Enumeration getAttributeNames()</code>：获取session中保存的所有属性名。 </li><li><code>long getCreationTime()</code>：返回session被创建的时间。 </li><li><code>String getId()</code>：返回session被创建时jsp容器分配的唯一标识。 </li><li><code>long getLastAccessedTime()</code>：返回最后一次通过session发送请求的时间。 </li><li><code>int getMaxInactiveInterval()</code>：返回session的失效时间，即两次请求间隔多长时间该session被取消，单位为秒。 </li><li><code>boolean isNew()</code>：判断是否是新的session。 </li><li><code>void invalidate()</code>：清空session内容。</li></ul><h5 id="application对象"><a href="#application对象" class="headerlink" title="application对象"></a>application对象</h5><p>用于获取和设置servlet相关信息，application的生命周期是从服务器启动直到服务器关闭。主要方法如下： </p><ul><li><code>void setAttribute(name, value)</code>：以”键-值”对的形式将一个对象的值存入application对象中。 </li><li><code>Object getAttribute(name)</code>：获取application中保存的属性的值。</li><li><code>getAttributeNames</code>：获取应用对象中所有属性的名字</li><li><code>getInitParameter</code>：返回应用对象中指定名字的初始参数值</li><li><code>getServletInfo</code>：返回Servlet编译器中当前版本信息</li></ul><h5 id="out对象"><a href="#out对象" class="headerlink" title="out对象"></a>out对象</h5><p>一个缓冲的输出流，用来向客户端返回信息。由于向客户端输出信息总是要连接，所以向客户端输出总是采用缓冲的形式。主要方法有以下几个： </p><ul><li><code>public void clear()</code>：清除缓冲区的内容，但不将缓冲区的内容输出到客户端。 </li><li><code>public void clearBuffer()</code>：清除缓冲区的内容，且将缓冲区的内容输出到客户端。 </li><li><code>public void close()</code>：关闭输出流并输出缓冲区的数据。</li><li><code>public void flush()</code>：输出缓冲区的数据。 </li><li><code>public int getBufferSize()</code>：获取缓冲区大小。 </li><li><code>public int getRemaining()</code>：获取剩余缓冲区大小。 </li><li><code>public boolean isAutoFlush()</code>：缓冲区是否进行自动清除。 </li><li><code>public void newLine()</code>：输出一个换行符。 </li><li><code>public void print(String)</code>：打印信息。 </li><li><code>public void println(String)</code>：打印信息并换行。</li><li><code>public void write(String)</code>：输出字符信息。</li></ul><p><strong>注意</strong></p><p>out.print 和 out.write区别</p><p>jsp中的out对象是JspWriter类型的，JspWriter继承了java.io.Writer。<br>write方法是在在父类Writer中定义的，print方法是在子类JspWriter中定义的。<br>重载的print方法可以将各种类型的数据转换成字符串的形式输出。<br>而重载的write方法只能输出字符／字符数组／字符串等与字符相关的数据。<br>而且如果使用这两种方法输出值为null的字符串对象，那么print方法输出的结果是＂null＂，而write方法则会抛出NullPoiterException异常．</p><h5 id="config对象"><a href="#config对象" class="headerlink" title="config对象"></a>config对象</h5><p>是ServletConfig类的一个实例，在servlet初始化时可以通过config对象想servlet传递信息。主要方法如下： </p><ul><li><code>String getServletName()</code>：获得servlet名称。 </li><li><code>ServletContext getServletContext()</code>：获得一个包含服务器相关信息的ServletContext对象。 </li><li><code>String getInitParameter(name)</code>：获得servlet初始化参数。 </li><li><code>Enumeration getInitParameterNames()</code>：获得servlet初始化时所有参数的名字的枚举对象。</li></ul><h5 id="page对象"><a href="#page对象" class="headerlink" title="page对象"></a>page对象</h5><p>是指当前的jsp页面本身，他是java.lang.Object类的对象，通过page对象可以很方便地调用servlet中定义的方法。常用方法如下： </p><ul><li><code>class getClass()</code>：返回当前的类名。 </li><li><code>int getHashCode()</code>：返回当前类的哈希码。 </li><li><code>String toString()</code>：将此对象转换成字符串。 </li><li><code>boolean equals(object)</code>：比较两个对象是否是相等。 </li><li><code>void copy(object)</code>：将该对象复制到指定的object对象中。</li></ul><h5 id="exception对象"><a href="#exception对象" class="headerlink" title="exception对象"></a>exception对象</h5><p>java.lang.Throwable类的对象，用来处理页面错误和异常。常用方法如下： </p><ul><li><code>String getMessage()</code>：返回异常对象的异常信息。 </li><li><code>String getLocalizedMessage()</code>：返回本地化语言的异常信息。 </li><li><code>void printStackTrace()</code>：打印异常的栈反向追踪痕迹。 </li><li><code>String toString()</code>：返回异常的简单描述。</li></ul><p><strong>注意</strong></p><p>使用异常对象时，应将page的isErrorPage属性设置为”true”，此时jsp是一个处理异常的页面</p><h5 id="pageContext对象"><a href="#pageContext对象" class="headerlink" title="pageContext对象"></a>pageContext对象</h5><p>pageContetx对象是jsp页面中所有对象功能的最大集成着。</p><p>使用他可以访问所有的jsp内置对象。常用方法如下： </p><ul><li><code>forward</code>：重定向到另一页面或Servlet组件</li><li><code>getAttribute</code>：获取某范围中指定名字的属性值</li><li><code>findAttribute</code>：按范围搜索指定名字的属性</li><li><code>removeAttribute</code>：删除某范围中指定名字的属性</li><li><code>setAttribute</code>：设定某范围中指定名字的属性值</li><li><code>getException</code>：返回当前异常对象</li><li><code>getRequest</code>：返回当前请求对象</li><li><code>getResponse</code>：返回当前响应对象</li><li><code>getServletConfig</code>：返回当前页面的ServletConfig对象</li><li><code>getServletContext</code>：返回所有页面共享的ServletContext对象</li><li><code>getSession</code>：返回当前页面的会话对象</li></ul><h4 id="Forward和Redirect"><a href="#Forward和Redirect" class="headerlink" title="Forward和Redirect"></a>Forward和Redirect</h4><h5 id="Forward"><a href="#Forward" class="headerlink" title="Forward"></a>Forward</h5><p><strong>实现语句</strong><br> <code>request.getRequestDispatcher(path).forward(request, response)</code></p><p> <strong>转发时传递对象</strong></p><p>当前Servlet对象中可以通过以下方法存储对象<br><code>request.setAttribute(String, Object)</code><br>转发目的地Servlet可以通过以下方法获取对象<br><code>request.getAttribute(String)</code> </p><blockquote><p>要注意的是，获取的对象类型为<code>object</code>要进行类型转换。 </p></blockquote><p><strong>也可以用jsp动作来实现转发</strong><br><code>&lt;jsp:forward page=&quot;apage.jsp&quot; /&gt;</code></p><h5 id="Redirect"><a href="#Redirect" class="headerlink" title="Redirect"></a>Redirect</h5><p><strong>实现语句</strong><br><code>response.sendRedirect(path)</code></p><p><strong>在jsp页面中实现重定向</strong><br>&lt;%response.sendRedirect(“new.jsp”);//重定向到new.jsp%&gt;</p><h5 id="转发和重定向的区别"><a href="#转发和重定向的区别" class="headerlink" title="转发和重定向的区别"></a>转发和重定向的区别</h5><ul><li>转发时URL不改变；重定向时URL改变。</li><li>转发只发出一次请求；重定向发出两次请求。</li><li>转发在服务器端完成，故又称为服务器端跳转；重定向在客户端完成，故又称客户端跳转。</li></ul><p><strong>转发和重定向示意图</strong></p><p><img src="Web-backstage/Forward_Redirect.png" alt></p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><p>主要功能是用户登录，在用户登录时提示用户是否记住登录信息，当用户选择记住登录信息时，会将用户的登录信息保存在Cookie中，以后用户再进入登录页面时会自动为用户写入用户的登录信息。</p><h4 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>response.addCookie(cooke)</td><td>写入Cookie对象</td></tr><tr><td>Cookie[] cookies = request.getCookies()</td><td>读取Cookie对象</td></tr><tr><td>void setMaxAge(int expiry)</td><td>设置Cookie有效期，以秒为单位</td></tr><tr><td>void setValue(String value)</td><td>Cookie创建后，对Cookie进行赋值</td></tr><tr><td>String getName()</td><td>获取Cookie名称</td></tr><tr><td>String getValue()</td><td>获取Cookie的值</td></tr><tr><td>int getMaxAge()</td><td>获取Cookie的有效时间，以秒为单位</td></tr><tr><td>Cookie cookie = new Cookie(String key, String value)</td><td>创建一个新的Cookie对象</td></tr></tbody></table><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><p>login.jsp</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> <span class="keyword">import</span>=<span class="string">"java.net.*"</span> contentType=<span class="string">"text/html; charset=UTF-8"</span></span><br><span class="line">    pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;登录&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;请登录&lt;/h1&gt;</span><br><span class="line">&lt;hr/&gt;</span><br><span class="line">&lt;%</span><br><span class="line">request.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">String userName = <span class="string">""</span>;</span><br><span class="line">String password = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取cookie对象</span></span><br><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span> != cookies &amp;&amp; cookies.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span>(Cookie c : cookies) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">"userName"</span>.equals(c.getName())) &#123;</span><br><span class="line"><span class="comment">//为了防止读取到的cookie值为乱码，</span></span><br><span class="line"><span class="comment">//将cookie的值使用URLDecoder.decode(String str, String encoding)进行转码</span></span><br><span class="line">userName = URLDecoder.decode(c.getValue(), <span class="string">"UTF-8"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"password"</span>.equals(c.getName())) &#123;</span><br><span class="line">password = URLDecoder.decode(c.getValue(), <span class="string">"UTF-8"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;form action=<span class="string">"dologin.jsp"</span> action=<span class="string">"post"</span>&gt;</span><br><span class="line">&lt;table&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;用户名：&lt;/td&gt;</span><br><span class="line">&lt;td&gt;&lt;input type="text" name="userName" value="&lt;%=userName %&gt;" /&gt;&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;密码：&lt;/td&gt;</span><br><span class="line">&lt;td&gt;&lt;input type="password" name="password" value="&lt;%=password %&gt;" /&gt;&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td colspan="2"&gt;&lt;input type="checkbox" name="isRemeber" value="remeber" checked="checked"&gt;十天内免登录&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td colspan="2"&gt;&lt;input type="submit" value="登录"&gt;&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>在这个页面中我们看到取出Cookie中保存的内容时用到了一个URLDecoder.decode(String str, String encoding)方法，这是因为根据RFC 2109中的规定，在Cookie中只能包含ASCII的编码，中文很显然不是ASCII编码的，为了防止出现乱码，需要进行一次转码，而要将中文存入Cookie的方法将在下面看到。</p><p>用户在登录页面写入相关信息并提交之后交给dologin.jsp进行处理，主要是根据用户的选择判断是否将用户的登录信息存入Cookie中，如果需要，则将登录信息写入Cookie。</p><p>dologin.jsp</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> <span class="keyword">import</span>=<span class="string">"java.net.*"</span> contentType=<span class="string">"text/html; charset=UTF-8"</span></span><br><span class="line">    pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;登录成功&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;登录成功&lt;/h1&gt;</span><br><span class="line">&lt;hr/&gt;</span><br><span class="line">&lt;%</span><br><span class="line">request.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">String userName = <span class="string">""</span>;</span><br><span class="line">String password = <span class="string">""</span>;</span><br><span class="line">String[] isRemeber = request.getParameterValues(<span class="string">"isRemeber"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span> != isRemeber &amp;&amp; isRemeber.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//获取userName和password的值，为了防止给cookie赋值时出现乱码异常，</span></span><br><span class="line"><span class="comment">//使用URLEncoder.encode(String str, String encoding)转码</span></span><br><span class="line">userName = URLEncoder.encode(request.getParameter(<span class="string">"userName"</span>), <span class="string">"UTF-8"</span>);</span><br><span class="line">password = URLEncoder.encode(request.getParameter(<span class="string">"password"</span>), <span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义cookie</span></span><br><span class="line">Cookie userNameCookie = <span class="keyword">new</span> Cookie(<span class="string">"userName"</span>, userName);</span><br><span class="line">Cookie passwordCookie = <span class="keyword">new</span> Cookie(<span class="string">"password"</span>, password);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置cookie的有效时间</span></span><br><span class="line">userNameCookie.setMaxAge(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">10</span>);</span><br><span class="line">passwordCookie.setMaxAge(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入cookie对象</span></span><br><span class="line">response.addCookie(userNameCookie);</span><br><span class="line">response.addCookie(passwordCookie);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span> != cookies &amp;&amp; cookies.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span>(Cookie c : cookies) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">"userName"</span>.equals(c.getName()) || <span class="string">"password"</span>.equals(c.getName())) &#123;</span><br><span class="line">c.setMaxAge(<span class="number">0</span>);</span><br><span class="line">                      <span class="comment">//写入cookie对象</span></span><br><span class="line">response.addCookie(c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>过滤器是一个服务器端的组件，它可以截取客户端的请求和服务端的响应信息，并对这些信息进行过滤。</p><h4 id="过滤器的工作原理"><a href="#过滤器的工作原理" class="headerlink" title="过滤器的工作原理"></a>过滤器的工作原理</h4><p><img src="Web-backstage/filter.png" alt></p><h4 id="过滤器的生命周期"><a href="#过滤器的生命周期" class="headerlink" title="过滤器的生命周期"></a>过滤器的生命周期</h4><p>过滤器的生命周期分为四个阶段：实例化、初始化、过滤和销毁：</p><p>实例化是指在Web工程的web.xml文件里声明一个过滤器，在声明了过滤器之后，Web容器会创建一个过滤器的实例；</p><p>初始化是指在创建了过滤器实例之后，服务器会执行过滤器中的init()方法，这是过滤器的初始化方法；</p><p>初始化之后过滤器就可以对请求和响应进行过滤了，过滤主要调用的是过滤器的doFilter()方法；</p><p>最后当服务器停止时，会将过滤器销毁，销毁过滤器前主要调用过滤器的destory()方法，释放资源。</p><h4 id="过滤器的常用方法"><a href="#过滤器的常用方法" class="headerlink" title="过滤器的常用方法"></a>过滤器的常用方法</h4><p>过滤器最常用的方法有三个：init()、doFilter()和destory()</p><p>1）init()方法：这是过滤器的初始化方法，在Web容器创建了过滤器实例之后将调用这个方法进行一些初始化的操作，这个方法可以读取web.xml中为过滤器定义的一些初始化参数。</p><p>2）doFilter()方法：这是过滤器的核心方法，表示将请求传给下一个过滤器或目标资源，当过滤器收到响应之后再执行FilterChain.doFilter()之后的内容。</p><p>3）destory()方法：这是Web容器在销毁过滤器实例前调用的方法，主要用来释放过滤器的资源等。</p><h4 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncodingFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存当前应用的字符集名称</span></span><br><span class="line">    <span class="keyword">private</span> String charEncoding=<span class="keyword">null</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="comment">//获取配置好的编码格式</span></span><br><span class="line">        charEncoding=config.getInitParameter(<span class="string">"encoding"</span>);</span><br><span class="line">        <span class="comment">//未设置编码信息则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (charEncoding==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"EncodingFilter中的编码信息设置为空！！！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse resp, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//如果当前默认的编码值与请求中的编码值不一致，</span></span><br><span class="line">        <span class="comment">//则将请求中的编码设置为默认的编码</span></span><br><span class="line">        <span class="keyword">if</span> (!charEncoding.equals(req.getCharacterEncoding()))&#123;</span><br><span class="line">            req.setCharacterEncoding(charEncoding);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将响应信息的编码格式也设置为默认格式</span></span><br><span class="line">        resp.setCharacterEncoding(charEncoding);</span><br><span class="line">        chain.doFilter(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="XML配置"><a href="#XML配置" class="headerlink" title="XML配置"></a>XML配置</h4><blockquote><p>如果有多个过滤器，那么过滤器执行的顺序按照XML里的先后顺序</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>EncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.icarus.filter.EncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>EncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--设置需要过滤的url--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="过滤器链"><a href="#过滤器链" class="headerlink" title="过滤器链"></a>过滤器链</h4><p>当用户发送请求请求Web资源时，过滤器1会首先获取用户的请求，对请求进行过滤，然后执行FilterChain.doFilter()将请求发送给过滤器2，过滤器2在过滤了用户请求之后执行FilterChain.doFilter()方法请求实际的Web资源，Web资源的响应将首先被过滤器2获取，在过滤器2对响应进行过滤之后将响应传递给过滤器1，在过滤器1过滤之后才将响应发送给用户。</p><p><img src="Web-backstage/doFilter.png" alt></p><h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>监听器是Servlet规范中定义的一种特殊类，用于监听ServletContext、HttpSession和ServletRequest等域对象的创建和销毁事件，它还可以监听域对象的属性发生修改的事件，可以在事件发生前或者发生后做一些必要的处理。</p><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p>在Servlet中要创建监听器类首先需要新建一个类并继承相应的监听器接口，实现接口中定义的方法，然后在web.xml文件中注册相应的监听器即可。如果一个web.xml文件中注册了多个监听器，则监听器的启动顺序按照在web.xml中的注册顺序启动。如果一个web.xml文件中同时定义了监听器、过滤器和Servlet，那么web容器会先加载监听器、再加载过滤器最后加载Servlet。</p><h4 id="监听器的分类"><a href="#监听器的分类" class="headerlink" title="监听器的分类"></a>监听器的分类</h4><p>按照监听的事件可以将监听器划分为以下三类：</p><ul><li>监听域对象<strong>自身的创建和销毁的事件</strong>监听器；</li><li>监听域对象中<strong>属性的增加和删除的事件</strong>监听器；</li><li>监听<strong>绑定到HttpSession域中某个对象状态的事件</strong>监听器。<ul><li>HttpSession中对象的状态有两种：绑定与解除绑定、钝化与活化。</li><li>绑定与解除绑定是指在HttpSession中将某个对象设置为属性值或者移除某个属性的值。</li><li>钝化是指服务器会将不常使用的Session对象暂时序列化到系统文件或数据库中，而活化就是将暂存在系统文件或数据库中的Session对象反序列化到服务器中。</li></ul></li></ul><p>按照监听对象可以分成以下三类：</p><table><thead><tr><th>监听对象</th><th>监听接口</th><th>监听事件</th></tr></thead><tbody><tr><td>ServletRequest</td><td>ServletRequestListener</td><td>ServletRequestEvent</td></tr><tr><td></td><td>ServletRequestAttributeListener</td><td>ServletRequestAttributeEvent</td></tr></tbody></table><table><thead><tr><th>监听对象</th><th>监听接口</th><th>监听事件</th></tr></thead><tbody><tr><td>HttpSession</td><td>HttpSessionListener</td><td>HttpSessionEvent</td></tr><tr><td></td><td>HttpSessionActivationListener</td><td>HttpSessionEvent</td></tr><tr><td></td><td>HttpSessionAttributeListener</td><td>HttpSessionBindingEvent</td></tr><tr><td></td><td>HttpSessionBindingListener</td><td>HttpSessionBindingEvent</td></tr></tbody></table><table><thead><tr><th>监听对象</th><th>监听接口</th><th>监听事件</th></tr></thead><tbody><tr><td>ServletContext</td><td>ServletContextListener</td><td>ServletContextEvent</td></tr><tr><td></td><td>ServletContextAttributeListener</td><td>ServletContextAttributeEvent</td></tr></tbody></table><h4 id="举例-3"><a href="#举例-3" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span>,</span></span><br><span class="line"><span class="class">        <span class="title">HttpSessionListener</span>, <span class="title">HttpSessionAttributeListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServletContext application;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Public constructor is required by servlet spec</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SessionListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// ServletContextListener implementation</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">      <span class="comment">/* This method is called when the servlet context is</span></span><br><span class="line"><span class="comment">         initialized(when the Web application is deployed). </span></span><br><span class="line"><span class="comment">         You can initialize servlet context related data here.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      application = sce.getServletContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">      <span class="comment">/* This method is invoked when the Servlet Context </span></span><br><span class="line"><span class="comment">         (the Web application) is undeployed or </span></span><br><span class="line"><span class="comment">         Application Server shuts down.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// HttpSessionListener implementation</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(HttpSessionEvent se)</span> </span>&#123;</span><br><span class="line">      <span class="comment">/* Session is created. */</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionDestroyed</span><span class="params">(HttpSessionEvent se)</span> </span>&#123;</span><br><span class="line">      <span class="comment">/* Session is destroyed. */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// HttpSessionAttributeListener implementation</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeAdded</span><span class="params">(HttpSessionBindingEvent sbe)</span> </span>&#123;</span><br><span class="line">      <span class="comment">/* This method is called when an attribute </span></span><br><span class="line"><span class="comment">         is added to a session.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">        List&lt;String&gt; userList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        application.setAttribute(<span class="string">"userList"</span>,userList);</span><br><span class="line">        userList.add(String.valueOf(sbe.getValue()));</span><br><span class="line">        System.out.println(<span class="string">"第一次加入username"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeRemoved</span><span class="params">(HttpSessionBindingEvent sbe)</span> </span>&#123;</span><br><span class="line">      <span class="comment">/* This method is called when an attribute</span></span><br><span class="line"><span class="comment">         is removed from a session.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeReplaced</span><span class="params">(HttpSessionBindingEvent sbe)</span> </span>&#123;</span><br><span class="line">      <span class="comment">/* This method is invoked when an attibute</span></span><br><span class="line"><span class="comment">         is replaced in a session.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">        List&lt;String&gt; userList = (List&lt;String&gt;) application.getAttribute(<span class="string">"userList"</span>);</span><br><span class="line">        String newValue= String.valueOf(sbe.getSession().getAttribute(sbe.getName()));</span><br><span class="line">        userList.add(newValue);</span><br><span class="line">        System.out.println(<span class="string">"再次加入username"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="XML配置-1"><a href="#XML配置-1" class="headerlink" title="XML配置"></a>XML配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">com.frank.listener.SessionListener</span><br><span class="line"><span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h3><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><p><code>${expr}</code></p><h4 id="举例-4"><a href="#举例-4" class="headerlink" title="举例"></a>举例</h4><p><strong>获取某个域内的元素</strong></p><p><code>${sessionScope.user.sex}</code></p><p>上述EL范例的意思是：从Session的范围中，取得用户的性别。</p><p>假若依照之前JSP Scriptlet的写法如下：</p><p>User user =(User)session.getAttribute(“user”);</p><p>String sex =user.getSex( );</p><p>两者相比较之下，可以发现EL 的语法比传统JSP Scriptlet 更为方便、简洁。</p><p><strong>数学表达式</strong></p><ul><li>${(1 + 2) * 3}等于9</li><li>${1 + (2 * 3)} 等于7</li></ul><p><strong>是否忽略EL表达式</strong></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page isELIgnored =<span class="string">"true|false"</span> %&gt;</span><br></pre></td></tr></table></figure><p>设为true，EL表达式就会被忽略，若设为false，则容器将会计算EL表达式。</p><h4 id="基础操作符"><a href="#基础操作符" class="headerlink" title="基础操作符"></a>基础操作符</h4><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>.</td><td>访问一个Bean属性或者一个映射条目</td></tr><tr><td>[ ]</td><td>访问一个数组或者链表的元素</td></tr><tr><td>( )</td><td>组织一个子表达式以改变优先级</td></tr><tr><td>+</td><td>加</td></tr><tr><td>-</td><td>减或负</td></tr><tr><td>*</td><td>乘</td></tr><tr><td>/ or div</td><td>除</td></tr><tr><td>% or mod</td><td>取模</td></tr><tr><td>== or eq</td><td>测试是否相等</td></tr><tr><td>!= or ne</td><td>测试是否不等</td></tr><tr><td>&lt; or lt</td><td>测试是否小于</td></tr><tr><td>&gt; or gt</td><td>测试是否大于</td></tr><tr><td>&lt;= or le</td><td>测试是否小于等于</td></tr><tr><td>&gt;= or ge</td><td>测试是否大于等于</td></tr><tr><td>&amp;&amp; or and</td><td>测试逻辑与</td></tr><tr><td>or</td><td>测试逻辑或</td></tr><tr><td>! or not</td><td>测试取反</td></tr><tr><td>empty</td><td>测试是否空值</td></tr></tbody></table><h5 id="与-运算符"><a href="#与-运算符" class="headerlink" title=".与 [ ] 运算符"></a>.与 [ ] 运算符</h5><p>EL 提供 . 和 [ ] 两种运算符来导航数据。</p><p>下列两者所代表的意思是一样的：</p><p>${sessionScope.user.sex}等于${sessionScope.user[“sex”]}</p><p><strong>. </strong>和 [ ] 也可以一起同时使用，如下：</p><p>${sessionScope.shoppingCart[0].price}</p><p>回传结果为shoppingCart中第一项物品的价格。</p><p>不过，以下两种情况，两者会有差异：</p><ol><li>当要存取的属性名称中包含一些特殊字符，如. 或 – 等并非字母或数字的符号，就一定要使用 [ ]</li></ol><p>例如：${user.My-Name }</p><p>上述是不正确的方式，应当改为：${user[“My-Name”] }</p><ol start="2"><li>我们来考虑下列情况：</li></ol><p>${sessionScope.user[data]}</p><p>此时，data 是一个变量，假若data的值为”sex”时，那上述的例子等于${sessionScope.user.sex}；</p><p>假若data 的值为”name”时，它就等于${sessionScope.user.name}。</p><p>因此，如果要动态取值时，就可以用上述的方法来做，但<strong>. </strong>无法做到动态取值。</p><h4 id="EL-变量"><a href="#EL-变量" class="headerlink" title="EL 变量"></a>EL 变量</h4><p>EL 存取变量数据的方法很简单，例如：${username}。它的意思是取出某一范围中名称为username的变量。</p><p>因为我们并没有指定哪一个范围的username，所以它的默认值会先从Page 范围找，假如找不到，</p><p>再依序到Request、Session、Application范围。假如途中找到username，就直接回传，不再继续找下去，</p><p>但是假如全部的范围都没有找到时，就回传null，当然EL表达式还会做出优化，页面上显示空白，而不是打印输出NULL。</p><table><thead><tr><th>属性范围（jstl名称）</th><th>EL中的名称</th></tr></thead><tbody><tr><td>Page</td><td>PageScope</td></tr><tr><td>Request</td><td>RequestScope</td></tr><tr><td>Session</td><td>SessionScope</td></tr><tr><td>Application</td><td>ApplicationScope</td></tr></tbody></table><h4 id="EL隐含对象"><a href="#EL隐含对象" class="headerlink" title="EL隐含对象"></a>EL隐含对象</h4><table><thead><tr><th>隐含对象</th><th>描述</th></tr></thead><tbody><tr><td>pageScope</td><td>page 作用域</td></tr><tr><td>requestScope</td><td>request 作用域</td></tr><tr><td>sessionScope</td><td>session 作用域</td></tr><tr><td>applicationScope</td><td>application 作用域</td></tr><tr><td>param</td><td>Request 对象的参数，字符串</td></tr><tr><td>paramValues</td><td>Request对象的参数，字符串集合</td></tr><tr><td>header</td><td>HTTP 信息头，字符串</td></tr><tr><td>headerValues</td><td>HTTP 信息头，字符串集合</td></tr><tr><td>initParam</td><td>上下文初始化参数</td></tr><tr><td>cookie</td><td>Cookie值</td></tr><tr><td>pageContext</td><td>当前页面的pageContext</td></tr></tbody></table><h5 id="pageContext对象-1"><a href="#pageContext对象-1" class="headerlink" title="pageContext对象"></a>pageContext对象</h5><p>pageContext对象是JSP中pageContext对象的引用。通过pageContext对象，您可以访问request对象。比如，访问request对象传入的查询字符串，就像这样：${pageContext.request.queryString}</p><h5 id="Scope对象"><a href="#Scope对象" class="headerlink" title="Scope对象"></a>Scope对象</h5><p>pageScope，requestScope，sessionScope，applicationScope变量用来访问存储在各个作用域层次的变量。</p><p>举例来说，如果您需要显式访问在applicationScope层的box变量，可以这样来访问：${applicationScope.box}。</p><h5 id="param和paramValues对象"><a href="#param和paramValues对象" class="headerlink" title="param和paramValues对象"></a>param和paramValues对象</h5><p>param对象返回单一的字符串，而paramValues对象则返回一个字符串数组</p><p>param和paramValues对象用来访问参数值，通过使用request.getParameter方法和request.getParameterValues方法。</p><p>举例来说，访问一个名为order的参数，可以这样使用表达式：${param.order}，或者${param[“order”]}。</p><h5 id="header和headerValues对象"><a href="#header和headerValues对象" class="headerlink" title="header和headerValues对象"></a>header和headerValues对象</h5><p>header对象返回单一值，而headerValues则返回一个字符串数组</p><p>header和headerValues对象用来访问信息头，通过使用 request.getHeader方法和request.getHeaders方法。</p><p>举例来说：</p><p>要访问一个名为user-agent的信息头，可以这样使用表达式：${header.user-agent}，或者${header[“user-agent”]}</p><h3 id="JSTL标签"><a href="#JSTL标签" class="headerlink" title="JSTL标签"></a>JSTL标签</h3><p>(全名：java standard tag libarary - java标准标签库)</p><p>JSP标准标签库（JSTL）是一个JSP标签集合，它封装了JSP应用的通用核心功能。</p><p>根据JSTL标签所提供的功能，可以将其分为5个类别。</p><ul><li>核心标签</li><li>格式化标签</li><li>SQL 标签</li><li>XML 标签</li><li>JSTL 函数</li></ul><h4 id="核心标签"><a href="#核心标签" class="headerlink" title="核心标签"></a>核心标签</h4><p>核心标签是最常用的JSTL标签。引用核心标签库的语法如下：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> prefix=<span class="string">"c"</span>%&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;c:set&gt;&lt;/c:set&gt;</code></td><td>用于保存数据</td></tr><tr><td><code>&lt;c:out value=*&quot;&quot;*&gt;&lt;/c:out&gt;</code></td><td>用于在JSP中显示数据，就像&lt;%= … &gt;</td></tr><tr><td><code>&lt;c:if test=*&quot;&quot;*&gt;&lt;/c:if&gt;</code></td><td>单条件判断</td></tr><tr><td><code>&lt;c:choose&gt;&lt;/c:choose&gt;</code></td><td>本身只当做<code>&lt;c:when&gt;</code>和<code>&lt;c:otherwise&gt;</code>的父标签</td></tr><tr><td><code>&lt;c:when test=*&quot;&quot;*&gt;&lt;/c:when&gt;</code></td><td><code>&lt;c:choose&gt;</code>的子标签，用来判断条件是否成立</td></tr><tr><td><code>&lt;c:otherwise&gt;&lt;/c:otherwise&gt;</code></td><td><code>&lt;c:choose&gt;</code>的子标签，接在<code>&lt;c:when&gt;</code>标签后，当<code>&lt;c:when&gt;</code>标签判断为false时被执行</td></tr><tr><td><code>&lt;c:forEach&gt;&lt;/c:forEach&gt;</code></td><td>基础迭代标签，接受多种集合类型</td></tr><tr><td><code>&lt;c:forTokens items=*&quot;&quot;* delims=*&quot;&quot;*&gt;&lt;/c:forTokens&gt;</code></td><td>根据指定的分隔符来分隔内容并迭代输出</td></tr><tr><td><code>&lt;c:redirect&gt;&lt;/c:redirect&gt;</code></td><td>重定向至一个新的URL</td></tr></tbody></table><h5 id="判断标签"><a href="#判断标签" class="headerlink" title="判断标签"></a>判断标签</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">"$&#123;not empty item.publish_time&#125;"</span>&gt;</span><br><span class="line">内容</span><br><span class="line">&lt;/c:if&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">"$&#123;item['domain']!=null&#125;"</span>&gt;</span><br><span class="line">内容</span><br><span class="line">&lt;/c:if&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">"$&#123;!empty permissionMap&#125;"</span>&gt; </span><br><span class="line">内容</span><br><span class="line">&lt;/c:if&gt;</span><br></pre></td></tr></table></figure><h5 id="循环标签"><a href="#循环标签" class="headerlink" title="循环标签"></a>循环标签</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">标签的语法定义如下所示</span><br><span class="line">&lt;c:forEach <span class="keyword">var</span>=<span class="string">"每个变量名字"</span>   items=<span class="string">"要迭代的list"</span>   varStatus=<span class="string">"每个对象的状态"</span></span><br><span class="line">begin=<span class="string">"循环从哪儿开始"</span>    end=<span class="string">"循环到哪儿结束"</span>    step=<span class="string">"循环的步长"</span>&gt;</span><br><span class="line">循环要输出的东西</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line"></span><br><span class="line">举例</span><br><span class="line">&lt;c:forEach items=<span class="string">"$&#123;domainList &#125;"</span> <span class="keyword">var</span>=<span class="string">"item"</span>&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td align="center" valign="middle"&gt;$&#123;item["domain"]==null?"&amp;nbsp;":item["domain"]&#125;&lt;/td&gt;</span><br><span class="line">&lt;td align=<span class="string">"center"</span> valign=<span class="string">"middle"</span>&gt;</span><br><span class="line">  &lt;fmt:formatDate value=<span class="string">"$&#123;item['bind_date']&#125;"</span> pattern=<span class="string">"yyyy-MM-dd HH:mm:ss"</span>/&gt;</span><br><span class="line">&lt;/td&gt;</span><br><span class="line">&lt;td align=<span class="string">"center"</span> valign=<span class="string">"middle"</span>&gt;</span><br><span class="line">    &lt;c:<span class="keyword">if</span> test=<span class="string">"$&#123;item['domain']!=null&#125;"</span>&gt;</span><br><span class="line">    &lt;a href="javascript:;" id="$&#123;item['domain']&#125;" class="del"&gt;&amp;nbsp;&lt;/a&gt;</span><br><span class="line">    &lt;/c:if&gt;</span><br><span class="line">   &lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;  </span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure><h5 id="选择标签"><a href="#选择标签" class="headerlink" title="选择标签"></a>选择标签</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:set var="score"&gt;85&lt;/c:set&gt;</span><br><span class="line">&lt;c:choose&gt;</span><br><span class="line">  &lt;c:when test=<span class="string">"$&#123;score&gt;=90&#125;"</span>&gt;</span><br><span class="line">    你的成绩为优秀！</span><br><span class="line">  &lt;/c:when&gt;</span><br><span class="line">  &lt;c:when test=<span class="string">"$&#123;score&gt;=70&amp;&amp;score&lt;90&#125;"</span>&gt;</span><br><span class="line">    您的成绩为良好!</span><br><span class="line">  &lt;/c:when&gt;</span><br><span class="line">  &lt;c:when test=<span class="string">"$&#123;score&gt;60&amp;&amp;score&lt;70&#125;"</span>&gt;</span><br><span class="line">    您的成绩为及格</span><br><span class="line">  &lt;/c:when&gt;</span><br><span class="line">  &lt;c:otherwise&gt;</span><br><span class="line">    对不起，您没有通过考试！</span><br><span class="line">  &lt;/c:otherwise&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br></pre></td></tr></table></figure><h4 id="格式化标签"><a href="#格式化标签" class="headerlink" title="格式化标签"></a>格式化标签</h4><p>JSTL格式化标签用来格式化并输出文本、日期、时间、数字。引用格式化标签库的语法如下：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib uri=<span class="string">"http://java.sun.com/jsp/jstl/fmt"</span> prefix=<span class="string">"fmt"</span>%&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;fmt:formatNumber&gt;</code></td><td>使用指定的格式或精度格式化数字</td></tr><tr><td><code>&lt;fmt:parseNumber&gt;</code></td><td>解析一个代表着数字，货币或百分比的字符串</td></tr><tr><td><code>&lt;fmt:formatDate&gt;</code></td><td>使用指定的风格或模式格式化日期和时间</td></tr><tr><td><code>&lt;fmt:parseDate&gt;</code></td><td>解析一个代表着日期或时间的字符串</td></tr><tr><td><code>&lt;fmt:bundle&gt;</code></td><td>绑定资源</td></tr><tr><td><code>&lt;fmt:setLocale&gt;</code></td><td>指定地区</td></tr><tr><td><code>&lt;fmt:setBundle&gt;</code></td><td>绑定资源</td></tr><tr><td><code>&lt;fmt:timeZone&gt;</code></td><td>指定时区</td></tr><tr><td><code>&lt;fmt:setTimeZone&gt;</code></td><td>指定时区</td></tr><tr><td><code>&lt;fmt:message&gt;</code></td><td>显示资源配置文件信息</td></tr><tr><td><code>&lt;fmt:requestEncoding&gt;</code></td><td>设置request的字符编码</td></tr></tbody></table><h4 id="SQL标签"><a href="#SQL标签" class="headerlink" title="SQL标签"></a>SQL标签</h4><p>JSTL SQL标签库提供了与关系型数据库（Oracle，MySQL，SQL Server等等）进行交互的标签。引用SQL标签库的语法如下：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib uri=<span class="string">"http://java.sun.com/jsp/jstl/sql"</span> prefix=<span class="string">"sql"</span>%&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;sql:setDataSource&gt;</code></td><td>指定数据源</td></tr><tr><td><code>&lt;sql:query&gt;</code></td><td>运行SQL查询语句</td></tr><tr><td><code>&lt;sql:update&gt;</code></td><td>运行SQL更新语句</td></tr><tr><td><code>&lt;sql:param&gt;</code></td><td>将SQL语句中的参数设为指定值</td></tr><tr><td><code>&lt;sql:dateParam&gt;</code></td><td>将SQL语句中的日期参数设为指定的java.util.Date 对象值</td></tr><tr><td><code>&lt;sql:transaction&gt;</code></td><td>在共享数据库连接中提供嵌套的数据库行为元素，将所有语句以一个事务的形式来运行</td></tr></tbody></table><h4 id="XML-标签"><a href="#XML-标签" class="headerlink" title="XML 标签"></a>XML 标签</h4><p>JSTL XML标签库提供了创建和操作XML文档的标签。引用XML标签库的语法如下：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib uri=<span class="string">"http://java.sun.com/jsp/jstl/xml"</span> prefix=<span class="string">"x"</span>%&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;x:out&gt;</code></td><td>与&lt;%= … &gt;,类似，不过只用于XPath表达式</td></tr></tbody></table><h4 id="JSTL函数"><a href="#JSTL函数" class="headerlink" title="JSTL函数"></a>JSTL函数</h4><p>JSTL包含一系列标准函数，大部分是通用的字符串处理函数。引用JSTL函数库的语法如下：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib uri=<span class="string">"http://java.sun.com/jsp/jstl/functions"</span> prefix=<span class="string">"fn"</span>%&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>fn:contains()</code></td><td>测试输入的字符串是否包含指定的子串</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;HTTP服务器&quot;&gt;&lt;a href=&quot;#HTTP服务器&quot; class=&quot;headerlink&quot; title=&quot;HTTP服务器&quot;&gt;&lt;/a&gt;HTTP服务器&lt;/h3&gt;&lt;p&gt;HTTP服务器本质上也是一种应用程序——它通常运行在服务器之上，绑定服务器的IP地址并监听某一个tc
      
    
    </summary>
    
      <category term="Internet" scheme="https://barry215.github.io/categories/Internet/"/>
    
    
      <category term="nginx" scheme="https://barry215.github.io/tags/nginx/"/>
    
      <category term="http" scheme="https://barry215.github.io/tags/http/"/>
    
      <category term="tomcat" scheme="https://barry215.github.io/tags/tomcat/"/>
    
      <category term="servlet" scheme="https://barry215.github.io/tags/servlet/"/>
    
      <category term="jsp" scheme="https://barry215.github.io/tags/jsp/"/>
    
      <category term="jstl" scheme="https://barry215.github.io/tags/jstl/"/>
    
  </entry>
  
  <entry>
    <title>网络基础知识</title>
    <link href="https://barry215.github.io/2016/11/08/Internet-foundation/"/>
    <id>https://barry215.github.io/2016/11/08/Internet-foundation/</id>
    <published>2016-11-08T14:13:22.000Z</published>
    <updated>2017-04-07T12:39:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络基础知识"><a href="#网络基础知识" class="headerlink" title="网络基础知识"></a>网络基础知识</h2><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><p>它是参考模型是国际标准化组织（ISO）制定的一个用于计算机或通信系统间互联的标准体系。</p><p>它将计算机网络体系结构的通信协议划分为七层，自下而上依次为：</p><p>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。其中第四层完成数据传送服务，上面三层面向用户。</p><p><img src="Internet-foundation/protocol1.jpg" alt="模型对比"></p><h3 id="TCP-IP五层模型"><a href="#TCP-IP五层模型" class="headerlink" title="TCP/IP五层模型"></a>TCP/IP五层模型</h3><p>应用层、传输层、网络层、数据链路层、物理层。层级越往上越接近用户，越往下越接近硬件。</p><p>每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则。</p><p><img src="Internet-foundation/protocol2.jpg" alt="五层模型"></p><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>就是用物理的方式把多个计算机连接在一起，比如无线电，双绞线，光缆，电缆</p><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>把二进制的信号按规则组合起来，使它变得有意义</p><h5 id="以太网协议"><a href="#以太网协议" class="headerlink" title="以太网协议"></a>以太网协议</h5><p>以太网就是平常所说的局域网的一种</p><p>同一个以太网下的电脑用唯一的mac地址识别，然后可以相互发送数据</p><h5 id="以太网数据包"><a href="#以太网数据包" class="headerlink" title="以太网数据包"></a>以太网数据包</h5><p>一组电信号构成一个数据包，叫做”帧”（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）</p><p>这个数据包最大是1500字节，所以如果数据很长，就必须分割成多个帧进行发送。</p><p><img src="Internet-foundation/head_data_1.png" alt></p><h5 id="mac地址"><a href="#mac地址" class="headerlink" title="mac地址"></a>mac地址</h5><p>以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。</p><p>每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。</p><p>举例：a8:bb:cf:04:cf:bc是一个mac地址</p><h5 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h5><p>网卡是工作在链路层的网络组件，是局域网中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能等。</p><h5 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h5><p>在以太网内传输数据，肯定要知道目的主机的mac地址。所以需要一个ARP协议来知道目的主机的mac地址</p><p>然后因为某种原因，以太网采用广播的方式发送数据包，即向以太网内的所有计算机发送数据包，然后如果计算机的mac地址和目的的mac地址一样，那就打开数据包，否则就丢弃</p><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p><img src="Internet-foundation/yitaiwang.png" alt></p><p>以太网内发送数据包有局限性</p><ul><li>采用广播的方式发送，效率低</li><li>目的主机在发送者的以太网外就无法发送</li></ul><p>所以我们需要网络地址来判断目的主机在哪一个子网络</p><p>网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。</p><h5 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h5><p>规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。</p><p>现在的IP协议有IPv4和IPv6两种，IPv4是主要的网络地址</p><p>IPv4 规定网络地址是由32个二进制位组成，为了分辨方便，我们用分成四段的十进制数表示IP地址。</p><p>因为2的8次是256，所以IPv4的地址是从0.0.0.0一直到255.255.255.255</p><p>互联网上的每一台计算机，都会分配到一个IP地址。</p><p>这个地址分成两个部分，前一部分代表网络地址，后一部分代表主机地址</p><p>但是每个部分的长度不是固定的，所以我们需要子网掩码来获取哪一部分是网络地址</p><p>IP协议的作用主要有两个</p><ul><li>为每一台计算机分配IP地址</li><li>确定哪些地址在同一个子网络</li></ul><h5 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h5><p>它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。</p><p>比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。</p><p>知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个<strong>子网络</strong>。</p><p><strong>子网掩码可以区分网络位是几位，主机位是几位</strong></p><p>方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。</p><p>A类默认子网掩码为：255.0.0.0<br>B类默认子网掩码为：255.255.0.0<br>C类默认子网掩码为：255.255.255.0</p><p>比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0，两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。</p><h5 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h5><p><strong>IP地址分为3类</strong></p><ul><li>A类地址 0.0.0.0~127.255.255.255</li><li>B类地址 128.0.0.0~191.255.255.255</li><li>C类地址 192.0.0.0~223.255.255.255</li><li>D类地址 224.0.0.0~239.255.255.255 （不用）</li><li>E类地址 240.0.0.0~255.255.255.255 （不用）</li></ul><blockquote><p>投入使用的只有ABC三类，DE两类是保留的。</p></blockquote><p><strong>私有地址</strong>(private address)也叫保留地址，它们不会在全球使用，只具有本地意义</p><ul><li>10.0.0.0 - 10.255.255.255</li><li>172.16.0.0 - 172.31.255.255</li><li>192.168.0.0 - 192.168.255.255</li></ul><p>所以一般局域网的地址都是192.168.X.X</p><p><strong>子网划分</strong></p><p>子网的划分主要是将主机位借用几位来表示子网号，余下几位主机位表示新的主机号，借来的位数加在子网掩码上</p><h5 id="广播地址"><a href="#广播地址" class="headerlink" title="广播地址"></a>广播地址</h5><p>它是在使用TCP/IP 协议的网络中，<strong>主机位</strong> 为全1 的IP 地址</p><h5 id="网络地址"><a href="#网络地址" class="headerlink" title="网络地址"></a>网络地址</h5><p>它是IP与子网掩码做与操作得到的地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">将202.100.2.0划分成4个子网.</span><br><span class="line">4=2的2次幂，所以需要向主机位借2位。</span><br><span class="line">因为该IP地址属于C类地址，</span><br><span class="line">所以主机位有8位，0000 0000，借两位之后</span><br><span class="line">子网掩码会变成  11111111 11111111 11111111 11000000</span><br><span class="line">即为：255.255.255.192</span><br><span class="line">那么划分的子网起始地址为（不考虑网络地址和广播地址）</span><br><span class="line">11001010 01100100 00000010 00000000 网络地址</span><br><span class="line">11001010 01100100 00000010 01000000</span><br><span class="line">11001010 01100100 00000010 10000000</span><br><span class="line">11001010 01100100 00000010 11000000 内含广播地址</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">申请一个C类IP，链接6个公司，最大的子公司有26台计算机，求子网掩码。</span><br><span class="line">解：</span><br><span class="line">因为  2^4 &lt; 26 &lt; 2^5</span><br><span class="line">所以  主机位应该为5位</span><br><span class="line">所以  该子网掩码为</span><br><span class="line">11111111 11111111 11111111 11100000</span><br><span class="line">即，255.255.255.224</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">B类地址子网掩码为255.255.255.248，则每个子网内可用的主机地址有（）个？</span><br><span class="line">解：</span><br><span class="line">255.255.255.248：</span><br><span class="line">11111111 11111111 11111111 11111000</span><br><span class="line">可以得出主机位只有3位，2的3次幂=8</span><br><span class="line">减去广播地址和网络地址，8-2=6</span><br><span class="line">所以子网内可用的主机地址有6个。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">某IP地址192.168.48.10，掩码为255.255.255.128，其所在的子网为()，广播地址为()，有效的主机IP地址范围从()到().</span><br><span class="line">192.168.48.0/192.168.48.127/192.168.48.1  到 192.168.48.126</span><br><span class="line"></span><br><span class="line">网络位为25  主机位为7 </span><br><span class="line">网络地址ip和子网掩码相与的192.168.48.0</span><br><span class="line"></span><br><span class="line">广播地址等于网络地址的主机位的二进制全为1</span><br><span class="line">192.168.48.127</span><br><span class="line"></span><br><span class="line">有效的主机IP地址=网络地址+1   ----   广播地址-1</span><br><span class="line">192.168.48.1 到 192.168.48.126</span><br></pre></td></tr></table></figure><h5 id="NAT协议"><a href="#NAT协议" class="headerlink" title="NAT协议"></a>NAT协议</h5><p>将私网地址转换成公网地址，从而连接到公共网络</p><p>好处：节省了公网IP地址</p><h5 id="IP数据包"><a href="#IP数据包" class="headerlink" title="IP数据包"></a>IP数据包</h5><p>把IP数据包直接放进以太网数据包的”数据”部分</p><p><img src="Internet-foundation/head_data_2.png" alt></p><h5 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h5><p>因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的MAC地址，另一个是对方的IP地址。通常情况下，对方的IP地址是已知的，但是我们不知道它的MAC地址。</p><p>所以我们需要用ARP协议来获取目的主机的MAC地址。</p><p>这里又可以分成两种情况</p><ul><li>如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关去处理。</li><li>如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。</li></ul><p>总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。</p><h5 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h5><p>网关(Gateway)又称网间连接器、协议转换器。网关在网络层以上实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关既可以用于广域网互连，也可以用于局域网互连。</p><p>一般来说，路由器的LAN接口的IP地址就是你所在局域网中的网关。当你所在的局域网的计算机需要和其它局域网中的计算机，或者需要访问互联网的时候，你所在局域网的计算机会先把数据包传输到网关（路由器的LAN接口），然后再由网关进行转发。</p><blockquote><p>说明：由于历史的原因，许多有关TCP/IP的文献曾经把网络层使用的路由器称为网关，在今天很多局域网采用都是路由来接入网络，因此通常指的网关就是路由器的IP</p></blockquote><p><img src="Internet-foundation/wangguan.jpg" alt></p><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>虽然通过以上两层，数据传到了计算机，但是计算机还是不知道这个数据是哪个应用程序的数据。所以我们又在计算机上定义了端口（port）。</p><p>传输层的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。</p><h5 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h5><p>端口是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。</p><h5 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h5><p>现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。</p><p><img src="Internet-foundation/head_data_3.png" alt></p><h5 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h5><p>UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。</p><p>所以出现了TCP协议，它会和目的主机进行三次握手确认，保证了数据传输的准确性</p><p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。</p><p>只需要一次连接，属于长连接，只要不断开的情况可以一直使用。</p><p><img src="Internet-foundation/tcp.png" alt></p><h5 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h5><p>如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。</p><p>滑动窗口本质上是描述接受方的TCP数据报缓冲区大小的数据，发送方根据这个数据来计算自己最多能发送多长的数据。如果发送方收到接受方的窗口大小为0的TCP数据报，那么发送方将停止发送数据，等到接受方发送窗口大小不为0的数据报的到来。窗口可以实时调整。</p><p>TCP的窗口单位是字节，不是报文段。</p><p>利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。</p><p><a href="http://www.jianshu.com/p/8afbbdd4af48" target="_blank" rel="noopener">TCP滑动窗口和流控</a></p><h5 id="数据拥堵控制"><a href="#数据拥堵控制" class="headerlink" title="数据拥堵控制"></a>数据拥堵控制</h5><p>在广域网中TCP发送方需要确认连接双方的线路的数据最大吞吐量是多少。这，就是所谓的拥塞窗口。</p><p>确定了拥塞窗口的大小，发送方就用这个拥塞窗口的大小发送数据。</p><p>一般是通过慢启动的方式来的，就是一开始发送一个数据报，然后等待对方的回应，得到回应后就把这个窗口的大小加倍，然后连续发送两个数据报，下一轮发送更多的数据报，直到出现超时错误，就知道了拥塞窗口的大小，这也就是为什么下载速度是慢慢开始涨的</p><p><a href="http://www.jianshu.com/p/bd141e76bc8b" target="_blank" rel="noopener">http://www.jianshu.com/p/bd141e76bc8b</a></p><h5 id="SOCKET"><a href="#SOCKET" class="headerlink" title="SOCKET"></a>SOCKET</h5><p>Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象，从而形成了我们知道的一些最基本的函数接口。</p><p>在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面。因为他是端口到端口的通讯接口，所以它让程序和程序之间可以相互交流</p><p>主要流程：服务器监听，客户端连接，连接确认</p><h5 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h5><p>TCP（传输控制协议）</p><p>基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。</p><p>支持超时重发</p><p>UDP（用户数据报协议）</p><p>它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去</p><p>只管是否发送成功，不保证对方是否接收到数据，所以UDP是不安全的，有可能会丢失数据包。</p><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>这一层有很多的协议，因为要规定应用程序的数据格式。比如Email (SMTP)、HTTP、FTP这些数据，都对应的协议。</p><p>数据包是TCP/IP协议通信传输中的数据单位，也称为“包”。</p><p><img src="Internet-foundation/head_data_4.png" alt></p><h5 id="SMTP协议"><a href="#SMTP协议" class="headerlink" title="SMTP协议"></a>SMTP协议</h5><p>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），用来发送电子邮件。</p><h5 id="HTTP数据包"><a href="#HTTP数据包" class="headerlink" title="HTTP数据包"></a>HTTP数据包</h5><p><img src="Internet-foundation/http1.png" alt></p><h5 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h5><p>HTTP(超文本传输协议)是利用TCP在两台电脑(通常是Web服务器和客户端)之间传输信息的协议。客户端使用Web浏览器发起HTTP请求给Web服务器，Web服务器发送被请求的信息给客户端。</p><p>HTTP协议，可以认为主要是用来访问网页的，是比TCP更上层的协议，http里面规定了我们访问网页的时候如何进行缓存，以及请求什么格式。等等，主要是为了让人们访问网页的时候更快，更安全，而规定了很多参数。你可以认为TCP就是搬运工，保证搬动的东西不被损坏。http协议是做业务的，用来决定要不要搬运，以及如何搬运，从哪去搬运。</p><h5 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h5><p>以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。用于安全的HTTP数据传输。</p><h5 id="SSL协议"><a href="#SSL协议" class="headerlink" title="SSL协议"></a>SSL协议</h5><p>SSL协议能够对信用卡和个人信息提供较安全的保护。SSL是对计算机之间整个会话进行加密的协议。在SSL中，采用了公开密钥和私有密钥两种加密方法。</p><h5 id="FTP协议"><a href="#FTP协议" class="headerlink" title="FTP协议"></a>FTP协议</h5><p>FTP（File Transfer Protocol，文件传输协议） 是 TCP/IP 协议组中的协议之一。FTP协议包括两个组成部分，其一为FTP服务器，其二为FTP客户端。其中FTP服务器用来存储文件，用户可以使用FTP客户端通过FTP协议访问位于FTP服务器上的资源。在开发网站的时候，通常利用FTP协议把网页或程序传到Web服务器上。此外，由于FTP传输效率非常高，在网络上传输大的文件时，一般也采用该协议。</p><p><img src="Internet-foundation/internet.png" alt></p><h3 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h3><p>发送数据包，需要知道两个地址</p><ul><li>目的计算机的mac地址</li><li>目的计算机的IP地址</li></ul><p>如果目的计算机的地址不在子网络中</p><table><thead><tr><th>场景</th><th>数据包地址</th></tr></thead><tbody><tr><td>非同一个子网络</td><td>网关的MAC地址，对方的IP地址</td></tr><tr><td>同一个子网络</td><td>对方的MAC地址，对方的IP地址</td></tr></tbody></table><h4 id="静态IP地址设置"><a href="#静态IP地址设置" class="headerlink" title="静态IP地址设置"></a>静态IP地址设置</h4><p><img src="Internet-foundation/xieyi.png" alt></p><p>需要4个网络参数</p><ul><li>本机的IP地址   192.168.1.100</li></ul><ul><li>子网掩码          255.255.255.0</li><li>网关的IP地址   192.168.1.1</li><li>DNS的IP地址   8.8.8.8</li></ul><h4 id="动态IP地址设置"><a href="#动态IP地址设置" class="headerlink" title="动态IP地址设置"></a>动态IP地址设置</h4><p>新的计算机加入网络，必须向”DHCP服务器”发送一个”DHCP请求”数据包，申请IP地址和相关的网络参数。</p><h5 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h5><p>每一个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做”DHCP服务器”</p><h4 id="访问网页"><a href="#访问网页" class="headerlink" title="访问网页"></a>访问网页</h4><p>1、配置好4个网络参数</p><p>2、在浏览器里输入网址：<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p><p>3、访问DNS服务器，将这个网址转换成IP地址128.39.120.45</p><p>4、用子网掩码判断128.39.120.45这个地址是不是和自己在同一个子网络</p><p>5、因为不是在同一个子网络中，数据包发到网关，网关再转发</p><p>6、目的主机接受数据包</p><p>7、服务器和浏览器三次握手</p><p>8、数据包确认</p><p>9、返回数据包给浏览器</p><h5 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h5><blockquote><p>CDN缓存，也叫网关缓存、反向代理缓存。浏览器先向CDN网关发起WEB请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态地请求转发到合适的源服务器上。</p></blockquote><p>启用CDN缓存后浏览器访问的全过程：</p><p>1.用户输入URL，浏览器将解析过后的域名发给DNS服务器</p><p>2.CDN返回该域名对应的CNAME，此时浏览器需要再次对获得的CNAME进行解析，才能得到CDN缓存服务器的IP地址。在此过程中全局负载均衡DNS解析服务器会将用户的访问请求定位到离用户最近、负载最轻的CDN缓存服务器上。这种技术也被称为“DNS重定向”，DNS服务器不是为每个请求返回相同的IP地址，比如在悉尼的一个客户请求解析<a href="http://www.cdn.com，DNS服务器根据地理位置，计算出距离这个用户最近的CDN服务器，于是返回一个悉尼CDN节点的IP地址。这种方法也不一定是最优的，因为地理位置上最近的两个点，延迟可能反而很高。还有一种方法是通过估计节点间的样本延迟，具体原理我也不了解。" target="_blank" rel="noopener">www.cdn.com，DNS服务器根据地理位置，计算出距离这个用户最近的CDN服务器，于是返回一个悉尼CDN节点的IP地址。这种方法也不一定是最优的，因为地理位置上最近的两个点，延迟可能反而很高。还有一种方法是通过估计节点间的样本延迟，具体原理我也不了解。</a></p><p>3.再次解析后，浏览器得到CDN缓存服务器的实际IP地址，向缓存服务器发起请求。</p><p>4.缓存服务器根据浏览器提供的域名，通过内部DNS解析得到此域名源服务器的真实IP地址，再由缓存服务器向该服务器发起访问请求。</p><p>5.缓存服务器拿到数据后，一方面将数据发回浏览器，另一方面进行本地保存，以备后用。之后再次访问，数据将从CDN缓存服务器中被返回。CDN不会永久保存数据，可以设置CDN的刷新频率，来达到数据的更新。</p><p>6.浏览器得到由缓存服务器发回的数据，并将其显示出来。至此，完成整个域名访问的过程。</p><p>速学路径</p><p><a href="https://segmentfault.com/a/1190000000538796" target="_blank" rel="noopener">https://segmentfault.com/a/1190000000538796</a></p><h5 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h5><p>域名是为了方便人而将域名（句点分割的字符串）映射到IP上。实际上机器之间用的是IP地址。</p><p>目的就是比IP地址好记</p><h5 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h5><p>是一台装有很多域名和IP地址对应的服务器</p><h4 id="网络架设"><a href="#网络架设" class="headerlink" title="网络架设"></a>网络架设</h4><h5 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h5><p>ISP（Internet Service Provider）即因特网服务提供商，能提供拨号上网服务、网上浏览、下载文件、收发电子邮件等服务，是网络最终用户进入Internet的入口和桥梁。它包括Internet接入服务和Internet内容提供服务。这里主要是Internet接入服务，即通过电话线把你的计算机或其他终端设备连入Internet。</p><p>中国三大基础运营商：中国电信，中国移动，中国联通。</p><h5 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h5><p>PPP（Point-to-Point Protocol点到点协议）是为在同等单元之间传输数据包这样的简单链路设计的链路层协议。</p><p>PPP是目前使用最广泛的数据链路层协议，不管是低速的拨号猫连接还是高速的光纤链路，都适用PPP协议。因特网用户通常都要连接到某个ISP 才能接入到因特网。 PPP协议就是用户计算机和ISP进行通信时所使用的数据链路层协议。 ISP使用PPP协议为计算机分配一些网络参数（如IP地址、域名等）。</p><h5 id="PPPoE协议"><a href="#PPPoE协议" class="headerlink" title="PPPoE协议"></a>PPPoE协议</h5><p>PPPoE（PPP over Ethernet）是在以太网上建立PPP连接，由于以太网技术十分成熟且使用广泛，而PPP协议在传统的拨号上网应用中显示出良好的可扩展性和优质的管理控制机制，二者结合而成的PPPoE协议得到了宽带接入运营商的认可并广为采用。它可以使以太网的主机通过一个简单的桥接设备连到一个远端的接入集中器上。通过pppoe协议，远端接入设备能够实现对每个接入用户的控制和计费。</p><h5 id="猫"><a href="#猫" class="headerlink" title="猫"></a>猫</h5><p>猫是Moden，宽带上网调制解调器</p><p>光纤或者是电话线经过猫，然后可以拉出来一根网线，再和电脑连接，电脑通过拨号的方式上网</p><p>有些小区或者一些地区已经省去了用猫这个步骤了，直接给你一根网线，插进电脑直接能拨号</p><h5 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h5><p>路由器相当于一台低配的计算机，一般路由器有两个部分组成，WAN和LAN，WAN是用来拨号的，是让路由自身能上网的一个部分，LAN是用来局域网内交换数据的，跟交换机的作用一样，我们的电脑插在LAN口才能上网</p><p>路由器验证宽带连接以后，连接的电脑不再需要验证</p><p>路由内置DHCP服务器，可以为使用路由的电脑自动分配IP，所以他们直接插上就能上网</p><h5 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h5><p>交换机简单的说，就是不能拨号的路由器，但是它不是一个计算机，它只有LAN，没有WAN，把网线插进交换机的任意接口，把电脑插进交换机的任意接口，把电脑2插进交换机的任意接口，这样两台电脑都需要拨号才能上网（就是宽带连接，交换机跟没使用路由器的拨号方法是一样的），以此看来交换机是用来数据交换的。</p><h5 id="路由器和交换机的区别"><a href="#路由器和交换机的区别" class="headerlink" title="路由器和交换机的区别"></a>路由器和交换机的区别</h5><ul><li>交换机是一根网线上网，但是大家上网是分别拨号，各自使用自己的宽带，大家上网没有影响。而路由器比交换机多了一个虚拟拨号功能，通过同一台路由器上网的电脑是共用一个宽带账号，大家上网要相互影响。</li><li>交换机工作在数据链路层，交换机根据MAC地址寻址。路由器工作在网络层，根据IP地址寻址，路由器可以处理TCP/IP协议，而交换机不可以。</li><li>交换机可以使连接它的多台电脑组成局域网，如果还有代理服务器的话还可以实现同时上网功能而且局域网所有电脑是共享它的带宽速率的，但是交换机没有路由器的自动识别数据包发送和到达地址的功能。路由器可以自动识别数据包发送和到达的地址，路由器相当于马路上的警察，负责交通疏导和指路的。</li></ul><h5 id="路由器和交换器的作用举例（涉及网络模型）"><a href="#路由器和交换器的作用举例（涉及网络模型）" class="headerlink" title="路由器和交换器的作用举例（涉及网络模型）"></a>路由器和交换器的作用举例（涉及网络模型）</h5><p>应用层就是最后使用者(写信和收信的人),中间的任何网络设备就是一个一个邮局。应用层写了好了信，就用一个信封装好，填好收信人，交给下一层协议，下一层协议既不关心信里有什么内容，也不关心收信人在哪里，它只要再按自己约定的职责，再封一层信封，交给自己的下一层就行了。就像公司老总，他只管写好信，封个信封，写上：发给XX公司王总。交给秘书，秘书交给行政，行政交给收发室……老总不用关心这封信是从哪个邮局走，走哪条路。最后，数据交到物理层。物理层只管往外发广播，就是把信复制N封，发到自己可达的任何下一个邮局就行，到了这一步，就算是离开了你的电脑了。 </p><p>首先到交换机，交换机会打开第一层和第二层的信封。如果发现这封信只是寄给公司内部人员的，那就不用交到邮局(路由器)去，直接转发给收信的部门。如果信是发到外面的，就重新写上两层信封，转交给路由器。路由器一般会拆、装三层信封，它会根据第三层信封上的目标地址，来选择对方邮局(路由功能),例如，寄到北京的信，就不会从A邮局(路由器/网段)走，寄往上海的信，就不会从B邮局走……等等。最后一个又一个邮局(路由器)接力,每个邮局都拆开三层信封，再封上三层信封，送往下一个应到的邮局。 </p><p>最后，到达目标收件人公司，由收发室(物理层)，行政部(数据链路层)，秘书科(IP层)，根据信封上写的房间号(TCP/UDP端口号)，决定送给张总(应用A)，或者王总(应用B)，收信人收到信，打开最后一层信封，开始阅读信件，或者按照信件上的内容开始做事。这就是应用层的工作了。</p><h5 id="WAN口"><a href="#WAN口" class="headerlink" title="WAN口"></a>WAN口</h5><p>WAN，全称Wide Area Network，中文名叫做广域网。</p><p>WAN是一种跨越大的、地域性的计算机网络的集合。通常跨越省、市，甚至一个国家。广域网包括大大小小不同的子网，子网可以是局域网，也可以是小型的广域网。</p><h5 id="LAN口"><a href="#LAN口" class="headerlink" title="LAN口"></a>LAN口</h5><p>LAN，全称Local Area Network，中文名叫做<strong>局域网</strong>。</p><p>顾名思义，LAN是指在某一区域内由多台计算机互联成的计算机组。一般是方圆几千米以内。局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的日程安排、电子邮件和传真通信服务等功能。局域网是封闭型的，可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。</p><p>具体到路由器，我们一般组网，都是组建的LAN网络，用户在局域网里通信、传输文件。其获取到的是内部IP，LAN 内部是交换机。我们可以不连接 WAN 口，把路由器当做普通交换机来使用</p><h5 id="WLAN"><a href="#WLAN" class="headerlink" title="WLAN"></a>WLAN</h5><p>WLAN是无线局域网 (Wireless Local Area Network)的简称。它是以射频无线微波通信技术构建的局域网，不用缆线即能提供传统有线局域网的所有功能，是高速有线接入的补充，属于小范围、短距离无线接入。</p><h5 id="WiFi"><a href="#WiFi" class="headerlink" title="WiFi"></a>WiFi</h5><p>WiFi是无线保真(wireless fidelity)的缩写，是能将电脑、手机等以无线方式互联的技术。</p><p>而WLAN是指无线局域网，其覆盖范围能达到5公里。WiFi是WLAN的一个子集，WiFi是短距离无线通信技术，而WLAN可以构建强大的电信级互联网络，布置多个AP(热点)，比如校园无线局域网。</p><p>从包含关系上来说，WiFi是WLAN的一个标准，WiFi包含于 WLAN中，属于采用WLAN协议中的一项新技术。WiFi的覆盖范围则可达300英尺左右（约合90米），WLAN最大（加天线）可以到5KM。</p><h5 id="GWF"><a href="#GWF" class="headerlink" title="GWF"></a>GWF</h5><p>GreatFireWall(防火长城),也称中国防火墙或中国国家防火墙</p><p>手段</p><ul><li>它通过使用错误的DNS解析地址来使你的浏览器得到错误的IP地址——DNS污染</li><li>它在会在你访问外网（国外的网）的时候，拦截一些特定网址的请求——IP封锁</li></ul><h5 id="HOSTS"><a href="#HOSTS" class="headerlink" title="HOSTS"></a>HOSTS</h5><p>Hosts 文件本来是用来提高解析效率。在进行 DNS 请求以前，系统会先检查自己的 Hosts 文件中是否有这个地址映射关系，如果有则调用这个 IP 地址映射，如果没有再向已知的 DNS 服务器提出域名解析。也就是说 Hosts 的请求级别比 DNS 高。当你的 Hosts 文件里面有对应的 IP 时，它就会直接访问那个 IP，而不用通过 DNS。<br>所以，当我们直接将 Google、Twitter、Facebook 之类的 IP 放入 Hosts 文件后，就可以跳过 DNS 的解析这一步，直接就行 IP 访问，不受 GFW 的 DNS 污染干扰了</p><h5 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h5><p>VPN的作用是在公用网络上建立专用网络。</p><p>比如你是一名公安民警，你出差在外住酒店，需要到公安内部网络查询某些资料。但是酒店的网络是公有网络，数据传输途中要经过酒店的路由，ISP的路由。中途任何有技术的人都可以看到你跟内部网络之间的明文通信。这时候需要在你和公安内部网络建立一条加密的专用信道。发送数据的时候加密，接收数据的时候解密，加解密的方式事先设定好。这样第三方看到加密过后的数据也无法理解其中的含义。</p><p>如果你明文请求Google主机，GFW会直接重置连接。但是你在国外有个VPN代理服务器，代理服务器帮你请求Google；再把Google的响应用加密的方式转发给你。因为你跟VPN代理之间是加密传输，GFW不知道你访问的是Google，它不可能把所有发到国外的请求都重置掉，所以成功突破封锁。</p><p>用VPN代理后，你的IP地址就变成了VPN服务器的地址，所有的网络操作都是服务器帮你做的</p><h4 id="浏览器知识"><a href="#浏览器知识" class="headerlink" title="浏览器知识"></a>浏览器知识</h4><h5 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h5><p>URL全称是资源描述符，一个URL地址，它用于描述一个网络上的资源</p><h5 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h5><p><img src="Internet-foundation/http2.png" alt></p><h5 id="HTTP请求头"><a href="#HTTP请求头" class="headerlink" title="HTTP请求头"></a>HTTP请求头</h5><p><img src="Internet-foundation/request.jpeg" alt></p><table><thead><tr><th></th><th>GET /user/2 HTTP/1.1</th></tr></thead><tbody><tr><td>Host</td><td><a href="http://www.maijinta.cn" target="_blank" rel="noopener">www.maijinta.cn</a></td></tr><tr><td>Cache-Control</td><td>max-age=0</td></tr><tr><td>Upgrade-Insecure-Requests</td><td>1</td></tr><tr><td>User-Agent</td><td>Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.98 Safari/537.36</td></tr><tr><td>Accept</td><td>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,<em>/</em>;q=0.8</td></tr><tr><td>Accept-Encoding</td><td>gzip, deflate, sdch</td></tr><tr><td>Accept-Language</td><td>zh-CN,zh;q=0.8</td></tr><tr><td>Cookie</td><td>JSESSIONID=C189DB3E2F2239EFDA2120A702B6DF34</td></tr></tbody></table><p>accept:浏览器通过这个头告诉服务器，它所支持的数据类型<br>Accept-Charset: 浏览器通过这个头告诉服务器，它支持哪种字符集<br>Accept-Encoding：浏览器通过这个头告诉服务器，支持的压缩格式<br>Accept-Language：浏览器通过这个头告诉服务器，它的语言环境<br>Host：浏览器通过这个头告诉服务器，想访问哪台主机<br>If-Modified-Since: 浏览器通过这个头告诉服务器，缓存数据的时间<br>Referer：浏览器通过这个头告诉服务器，客户机是哪个页面来的  防盗链<br>Connection：浏览器通过这个头告诉服务器，请求完后是断开链接还是何持链接</p><h5 id="WEB缓存机制"><a href="#WEB缓存机制" class="headerlink" title="WEB缓存机制"></a>WEB缓存机制</h5><p>Cache策略</p><p><img src="Internet-foundation/cache.png" alt></p><p>浏览器缓存</p><p>浏览器会把缓存的文件保存在一个叫User Data的文件夹下，下次页面加载同样资源时，可以直接从本地读取，不必通过HTTP从服务器端再次下载资源，大大加快了页面的响应速度</p><p>本地缓存阶段</p><p>HTPP1.0 使用Expires来设置有效期，有效期未到，则使用浏览器缓存，到了再请求服务器</p><p>HTPP1.1 使用Cache-Control的<code>max-age</code>来设置最大缓存时间，<code>max-age</code>就会覆盖Expires</p><p>协商缓存阶段</p><p>HTPP1.0 使用Last-Modified与If-Modified-Since，服务器返回的是Last-Modified，浏览器第二次会发If-Modified-Since</p><p>HTTP1.1 使用ETag与If-None-Match，服务器返回的是ETag，浏览器第二次会发If-None-Match，当ETag和Last-modified同时存在时，Last-modified会被忽略</p><p><img src="Internet-foundation/cacheHead.png" alt></p><p>当一个用户发起一个静态资源请求的时候，浏览器会通过以下几步来获取资源：</p><ul><li>本地缓存阶段：先在本地查找该资源，如果有发现该资源，而且该资源还没有过期，就使用这一个资源，完全不会发送http请求到服务器；</li><li>协商缓存阶段：如果在本地缓存找到对应的资源，但是不知道该资源是否过期或者已经过期，则发一个http请求到服务器,然后服务器判断这个请求，如果请求的资源在服务器上没有改动过，则返回304，让浏览器使用本地找到的那个资源；</li><li>缓存失败阶段：当服务器发现请求的资源已经修改过，或者这是一个新的请求(在本来没有找到资源)，服务器则返回该资源的数据，并且返回200， 当然这个是指找到资源的情况下，如果服务器上没有这个资源，则返回404。</li></ul><p><img src="Internet-foundation/cacheFlow.png" alt></p><p>刷新失效</p><p><img src="Internet-foundation/flashCache.png" alt></p><h5 id="Web缓存的作用"><a href="#Web缓存的作用" class="headerlink" title="Web缓存的作用"></a>Web缓存的作用</h5><ul><li>减少网络带宽消耗</li><li>降低服务器压力</li><li>减少网络延迟，加快页面打开速度</li></ul><p>WEB缓存速学</p><p><a href="http://imweb.io/topic/55c6f9bac222e3af6ce235b9" target="_blank" rel="noopener">缓存策略</a></p><p><a href="http://www.jianshu.com/p/7a24e0920255" target="_blank" rel="noopener">浏览器缓存</a></p><p><a href="http://www.jianshu.com/p/985b35774295" target="_blank" rel="noopener">浏览器缓存知识小结及应用</a></p><p><a href="https://mp.weixin.qq.com/s/F5gvzdi6MTwCFXV9LKs9NQ" target="_blank" rel="noopener">浏览器缓存机制浅析</a></p><p><a href="http://imweb.io/topic/5795dcb6fb312541492eda8c" target="_blank" rel="noopener">HTTP缓存控制小结</a></p><h5 id="怎么判断是否存在网络延迟"><a href="#怎么判断是否存在网络延迟" class="headerlink" title="怎么判断是否存在网络延迟"></a>怎么判断是否存在网络延迟</h5><ul><li>chrome调试工具</li><li>ping命令</li><li>抓包</li></ul><h5 id="HTTP响应头"><a href="#HTTP响应头" class="headerlink" title="HTTP响应头"></a>HTTP响应头</h5><p><img src="Internet-foundation/response.png" alt></p><table><thead><tr><th></th><th>HTTP/1.1 200 OK</th></tr></thead><tbody><tr><td>Date</td><td>Sat, 02 Jan 2016 13:20:55 GMT</td></tr><tr><td>Server</td><td>Apache/2.4.6 (CentOS) PHP/5.6.14</td></tr><tr><td>Content-Length</td><td>78</td></tr><tr><td>Keep-Alive</td><td>timeout=5, max=100</td></tr><tr><td>Connection</td><td>Keep-Alive</td></tr><tr><td>Content-Type</td><td>application/json; charset=utf-8</td></tr></tbody></table><p>Location: 服务器通过这个头，来告诉浏览器跳到哪里Server：服务器通过这个头，告诉浏览器服务器的型号<br>Content-Encoding：服务器通过这个头，告诉浏览器，数据的压缩格式<br>Content-Length: 服务器通过这个头，告诉浏览器回送数据的长度<br>Content-Language: 服务器通过这个头，告诉浏览器语言环境<br>Content-Type：服务器通过这个头，告诉浏览器回送数据的类型<br>Refresh：服务器通过这个头，告诉浏览器定时刷新<br>Content-Disposition: 服务器通过这个头，告诉浏览器以下载方式打数据<br>Transfer-Encoding：服务器通过这个头，告诉浏览器数据是以分块方式回送的控制浏览器不要缓存</p><h5 id="HTTP8种请求"><a href="#HTTP8种请求" class="headerlink" title="HTTP8种请求"></a>HTTP8种请求</h5><p>HTTP/1.1协议中共定义了八种方法或者叫“动作”get，post，put， options，head，delete，trace，connect，来表明对Request-URI指定的资源的不同操作方式，具体介绍如下：</p><ul><li><code>OPTIONS</code>：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的功能性。</li><li><code>HEAD</code>：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。</li><li><code>GET</code>：向特定的资源发出请求。</li><li><code>POST</code>：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。</li><li><code>PUT</code>：用于向服务器发送请求，如果URI不存在，则要求服务器根据请求创建资源，如果存在，服务器就接受请求内容，并修改URI的原始版本</li><li><code>DELETE</code>：请求服务器删除Request-URI所标识的资源。</li><li><code>TRACE</code>：回显服务器收到的请求，主要用于测试或诊断。</li><li><code>CONNECT</code>：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</li></ul><p>上述方法中最基本的方法有4种，分别是GET，POST，PUT，DELETE。</p><h5 id="HTTP-1-1之后增加的方法PATCH"><a href="#HTTP-1-1之后增加的方法PATCH" class="headerlink" title="HTTP/1.1之后增加的方法PATCH"></a>HTTP/1.1之后增加的方法PATCH</h5><p><code>PATCH</code>方法出现的较晚，<code>PATCH</code>请求与<code>PUT</code>请求类似，同样用于资源的更新。二者有以下两点不同：</p><ul><li>但<code>PATCH</code>一般用于资源的部分更新，而<code>PUT</code>一般用于资源的整体更新。</li><li>当资源不存在时，<code>PATCH</code>会创建一个新的资源，而<code>PUT</code>只会对已在资源进行更新。</li></ul><h5 id="get，put，post，delete详解"><a href="#get，put，post，delete详解" class="headerlink" title="get，put，post，delete详解"></a>get，put，post，delete详解</h5><ul><li><code>get</code>请求会向数据库发索取数据的请求，从而来获取信息，该请求就像数据库的<code>select</code>操作一样，只是用来查询一下数据，不会修改、增加数据，不会影响资源的内容，即该请求不会产生副作用。无论进行多少次操作，结果都是一样的。</li><li><code>put</code> 是向服务器端发送数据的，从而改变信息，该请求就像数据库的update操作一样，用来修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。</li><li><code>post</code>同PUT请求类似，都是向服务器端发送数据的，但是该请求会改变数据的种类等资源，就像数据库的insert操作一样，会创建新的内容。几乎目前所有的提交操作都是用POST请求的。</li><li><code>delete</code>就是用来删除某一个资源的，该请求就像数据库的delete操作。</li></ul><h5 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h5><p>服务器向用户返回的状态码和提示信息</p><table><thead><tr><th></th><th>类别</th><th>原因短语</th></tr></thead><tbody><tr><td>1XX</td><td>Informational (信息性状态码)</td><td>接收的请求正在处理</td></tr><tr><td>2XX</td><td>Success (成功状态码)</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>Redirection (重定向状态码)</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>Client Error (客户端错误状态码)</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>Server Error (服务器错误状态码)</td><td>服务器处理请求出错</td></tr></tbody></table><p>常用状态码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> 200 OK</span><br><span class="line"><span class="meta">#</span><span class="bash">表示从客户端发来的请求在服务器被正常处理了</span></span><br><span class="line"> 301 永久移动 请求的网页已永久移动到新位置。 服务器返回此响应时，会自动将请求者转到新位置</span><br><span class="line"> 302 临时移动 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</span><br><span class="line"> 304 资源未修改</span><br><span class="line"> 307 重定向 GET</span><br><span class="line"><span class="meta">#</span><span class="bash">自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</span></span><br><span class="line"> 400 Bad Request</span><br><span class="line"><span class="meta">#</span><span class="bash">该状态码表示请求报文中存在的语法错误。当错误发生时，需修改请求的内容后再次发送请求，浏览器会像200 OK一样对待该状态码。</span></span><br><span class="line"> 401 未授权</span><br><span class="line"> 403 Forbidden</span><br><span class="line"><span class="meta">#</span><span class="bash">该状态码表明对请求资源的访问被服务器拒绝了。</span></span><br><span class="line"> 404 Not Found</span><br><span class="line"><span class="meta">#</span><span class="bash">该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。</span></span><br><span class="line"> 500 Internal Server Error</span><br><span class="line"><span class="meta">#</span><span class="bash">该状态码表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的bug或某些临时故障。</span></span><br></pre></td></tr></table></figure><h5 id="SESSION"><a href="#SESSION" class="headerlink" title="SESSION"></a>SESSION</h5><p>浏览器访问服务器，服务器就会在内存中生成一个session，用于记录该浏览器和服务器的会话信息。然后服务器在返回数据包的时候，会把这个session的id返回给客户端。客户端把这个sessionID放在本地的cookie当中，以后的请求会带上sessionID，这样服务器就认识你这个客户端了。</p><h5 id="COOKIE"><a href="#COOKIE" class="headerlink" title="COOKIE"></a>COOKIE</h5><p>cookie是服务器放在客户端的一些信息</p><p>Cookies最典型的应用是判定注册用户是否已经登录网站，用户可能会得到提示，是否在下一次进入此网站时保留用户信息以便简化登录手续，这些都是Cookies的功用。另一个重要应用场合是“购物车”之类处理。用户可能会在一段时间内在同一家网站的不同页面中选择不同的商品，这些信息都会写入Cookies，以便在最后付款时提取信息。</p><h4 id="常见的WEB攻击"><a href="#常见的WEB攻击" class="headerlink" title="常见的WEB攻击"></a>常见的WEB攻击</h4><h5 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h5><blockquote><p>Cross-Site Request Forgery - 跨站请求伪造</p></blockquote><p>攻击方式</p><ol><li>用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；</li><li>在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；</li><li>用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；</li><li>网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；</li><li>浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。</li></ol><p>CSRF攻击分类</p><p>CSRF漏洞一般分为站外和站内两种类型。</p><p>CSRF站外类型的漏洞本质上就是传统意义上的外部提交数据问题。通常程序员会考虑给一些留言或者评论的表单加上水印以防止SPAM问题（这里，SPAM可以简单的理解为垃圾留言、垃圾评论，或者是带有站外链接的恶意回复），但是有时为了提高用户的体验性，可能没有对一些操作做任何限制，所以攻击者可以事先预测并设置请求的参数，在站外的Web页面里编写脚本伪造文件请求，或者和自动提交的表单一起使用来实现GET、POST请求，当用户在会话状态下点击链接访问站外Web页面，客户端就被强迫发起请求。</p><p>CSRF站内类型的漏洞在一定程度上是由于程序员滥用REQUEST类变量造成的。在一些敏感的操作中（如修改密码、添加用户等），本来要求用户从表单提交发起POST请求传递参数给程序，但是由于使用了REQUEST类变量造成的。在一些敏感的操作中（如修改密码、添加用户等），本来要求用户从表单提交发起POST请求传递参数给程序，但是由于使用了_REQUEST等变量，程序除支持接收POST请求传递的参数外也支持接收GET请求传递的参数，这样就会为攻击者使用CSRF攻击创造条件。一般攻击者只要把预测的请求参数放在站内一个贴子或者留言的图片链接里，受害者浏览了这样的页面就会被强迫发起这些请求。</p><p><img src="Internet-foundation/csrf.jpg" alt></p><h5 id="CSRF漏洞防御"><a href="#CSRF漏洞防御" class="headerlink" title="CSRF漏洞防御"></a>CSRF漏洞防御</h5><ol><li>验证HTTP Referer字段，查看HTTP请求来源</li><li>在请求中添加token并验证</li><li>禁用CORS，可以防止其他网页里的恶意链接</li></ol><h5 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h5><blockquote><p>Cross Origin Resourse-Sharing - 跨站资源共享</p></blockquote><p>它允许浏览器向跨站服务器发送XHR请求。CORS的出现，使得网站开发者可对受信任的站点（域名）绕过浏览器同源策略的限制，提供了极大的灵活性。</p><p>XHR</p><p>XMLHttpRequest对象可以在不向服务器提交整个页面的情况下，实现局部更新网页。当页面全部加载完毕后，客户端通过该对象向服务器请求数据，服务器端接受数据并处理后，向客户端反馈数据。 XMLHttpRequest 对象提供了对 HTTP 协议的完全的访问，包括做出 POST 和 HEAD 请求以及普通的 GET 请求的能力。XMLHttpRequest 可以同步或异步返回 Web 服务器的响应，并且能以文本或者一个 DOM 文档形式返回内容。尽管名为 XMLHttpRequest，它并不限于和 XML 文档一起使用：它可以接收任何形式的文本文档。</p><h5 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h5><p>XSS是跨站脚本攻击的缩写，是一种网站应用程序的安全漏洞攻击，是代码注入的一种。 通常是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="http://jingyan.baidu.com/article/3c343ff7e862850d3679637b.html" target="_blank" rel="noopener">LAN、WAN、WLAN的区别</a></li><li><a href="http://www.jianshu.com/p/674fb7ec1e2c" target="_blank" rel="noopener">计算机网络基础知识大总汇</a></li><li><a href="http://www.45it.com/www/201308/35524.htm" target="_blank" rel="noopener">路由器、交换机、猫的作用与区别</a></li><li><a href="http://www.cnblogs.com/Lynn-Zhang/articles/5754336.html" target="_blank" rel="noopener">交换机和路由器的区别</a></li><li><a href="https://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F#TCP.2FIP.E5.8D.94.E8.AD.B0.E6.A3.A7.E7.B5.84.E6.88.90" target="_blank" rel="noopener">TCP/IP协议族</a></li><li><a href="http://bbs.51cto.com/thread-68584-1-1.html" target="_blank" rel="noopener">子网掩码与子网划分 </a></li><li><a href="http://www.cnblogs.com/maybe2030/p/4781555.html" target="_blank" rel="noopener">计算机网络基础知识总结</a></li><li><a href="http://www.cnblogs.com/shuijilove/p/5274659.html" target="_blank" rel="noopener">网络请求心路历程</a></li><li><a href="http://www.jianshu.com/p/0320f7e0ad11" target="_blank" rel="noopener">简单 -http详解</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">HTTP 协议入门</a></li><li><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">字符编码笔记</a></li><li><a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="noopener">互联网协议入门（一）</a></li><li><a href="http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html" target="_blank" rel="noopener">互联网协议入门（二）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;网络基础知识&quot;&gt;&lt;a href=&quot;#网络基础知识&quot; class=&quot;headerlink&quot; title=&quot;网络基础知识&quot;&gt;&lt;/a&gt;网络基础知识&lt;/h2&gt;&lt;h3 id=&quot;OSI七层模型&quot;&gt;&lt;a href=&quot;#OSI七层模型&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="Internet" scheme="https://barry215.github.io/categories/Internet/"/>
    
    
      <category term="http" scheme="https://barry215.github.io/tags/http/"/>
    
      <category term="tcp/ip" scheme="https://barry215.github.io/tags/tcp-ip/"/>
    
  </entry>
  
  <entry>
    <title>SQL 基础</title>
    <link href="https://barry215.github.io/2016/10/30/SQL-foundation/"/>
    <id>https://barry215.github.io/2016/10/30/SQL-foundation/</id>
    <published>2016-10-30T01:12:34.000Z</published>
    <updated>2017-08-10T14:19:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常用的数据库"><a href="#常用的数据库" class="headerlink" title="常用的数据库"></a>常用的数据库</h3><h4 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h4><p>MySQL，Oracle，SqlServer</p><h4 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h4><p>Redis，MongoDB</p><h4 id="两者关系"><a href="#两者关系" class="headerlink" title="两者关系"></a>两者关系</h4><p><a href="http://www.infoq.com/cn/news/2011/01/nosql-why" target="_blank" rel="noopener">为什么要使用NoSQL</a></p><p><a href="https://my.oschina.net/u/1773689/blog/364548" target="_blank" rel="noopener">关系型数据库和非关系型数据库</a></p><h3 id="数据库的数据类型"><a href="#数据库的数据类型" class="headerlink" title="数据库的数据类型"></a>数据库的数据类型</h3><h4 id="时间类型区别"><a href="#时间类型区别" class="headerlink" title="时间类型区别"></a>时间类型区别</h4><table><thead><tr><th>数据类型</th><th>含义</th></tr></thead><tbody><tr><td>date</td><td>日期 ‘2008-12-2’</td></tr><tr><td>time</td><td>时间 ‘12:25:36’</td></tr><tr><td>datetime</td><td>日期时间 ‘2008-12-2 22:06:44’</td></tr><tr><td>timestamp</td><td>自动存储记录修改时间 格式同上</td></tr></tbody></table><blockquote><p>DATETIM和TIMESTAMP类型所占的存储空间不同，前者8个字节，后者4个字节。</p><p>这样造成的后果是两者能表示的时间范围不同。</p><p>前者范围为1000-01-01 00:00:00 ~ 9999-12-31 23:59:59，后者范围为1970-01-01 08:00:01到2038-01-19 11:14:07。</p><p>所以可以看到TIMESTAMP支持的范围比DATATIME要小,容易出现超出的情况。</p></blockquote><h4 id="更多资料"><a href="#更多资料" class="headerlink" title="更多资料"></a>更多资料</h4><p><a href="http://blog.csdn.net/souldak/article/details/11737799" target="_blank" rel="noopener">mysql中timestamp,datetime,int类型的区别与优劣</a></p><p><a href="http://shanks.leanote.com/post/mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B#title-1" target="_blank" rel="noopener">MySQL数据类型详解</a></p><h3 id="MySQL关键字"><a href="#MySQL关键字" class="headerlink" title="MySQL关键字"></a>MySQL关键字</h3><table><thead><tr><th>关键字</th><th>含义</th></tr></thead><tbody><tr><td>NULL</td><td>数据列可包含NULL值</td></tr><tr><td>NOT NULL</td><td>数据列不允许包含NULL值</td></tr><tr><td>DEFAULT</td><td>默认值</td></tr><tr><td>PRIMARY KEY</td><td>主键</td></tr><tr><td>AUTO_INCREMENT</td><td>自动递增，适用于整数类型</td></tr><tr><td>UNSIGNED</td><td>无符号</td></tr><tr><td>CHARACTER SET name</td><td>指定一个字符集</td></tr></tbody></table><h3 id="须知"><a href="#须知" class="headerlink" title="须知"></a>须知</h3><ul><li>SQL 对大小写不敏感</li><li><code>&#39;&#39;</code>单引号包裹用来表示是字符，不过大多数数据库也支持<code>&quot;&quot;</code>双引号</li><li><code>*</code>表示所有表内字段</li></ul><h3 id="表示例"><a href="#表示例" class="headerlink" title="表示例"></a>表示例</h3><h4 id="user"><a href="#user" class="headerlink" title="user"></a>user</h4><table><thead><tr><th style="text-align:center">USER_ID</th><th style="text-align:center">USER_NAME</th><th style="text-align:center">CLASS_ID</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">frank</td><td style="text-align:center">16052502</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">barry</td><td style="text-align:center">16031023</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">peter</td><td style="text-align:center">16021314</td></tr></tbody></table><h4 id="course"><a href="#course" class="headerlink" title="course"></a>course</h4><table><thead><tr><th style="text-align:center">COURSE_ID</th><th style="text-align:center">COURSE_NAME</th><th style="text-align:center">CREDIT</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">数据库</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">操作系统</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">数据结构</td><td style="text-align:center">2</td></tr></tbody></table><h4 id="class"><a href="#class" class="headerlink" title="class"></a>class</h4><table><thead><tr><th style="text-align:center">CLASS_ID</th><th style="text-align:center">CLASS_NAME</th><th style="text-align:center">CLASS_SIZE</th></tr></thead><tbody><tr><td style="text-align:center">16052502</td><td style="text-align:center">电子2班</td><td style="text-align:center">35</td></tr><tr><td style="text-align:center">16031023</td><td style="text-align:center">软工3班</td><td style="text-align:center">41</td></tr><tr><td style="text-align:center">16021314</td><td style="text-align:center">会计4班</td><td style="text-align:center">37</td></tr></tbody></table><h4 id="grade"><a href="#grade" class="headerlink" title="grade"></a>grade</h4><table><thead><tr><th style="text-align:center">USER_ID</th><th style="text-align:center">COURSE_ID</th><th style="text-align:center">SCORE</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">73</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">86</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">1</td><td style="text-align:center">54</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">88</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">90</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center">69</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">93</td></tr></tbody></table><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><h4 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h4><p>从某个表里筛选</p><blockquote><p>SELECT 列名称 FROM 表名称</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">USER_ID</th><th style="text-align:center">USER_NAME</th><th style="text-align:center">CLASS_ID</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">frank</td><td style="text-align:center">16052502</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">barry</td><td style="text-align:center">16031023</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">peter</td><td style="text-align:center">16021314</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id,user_name <span class="keyword">from</span> <span class="keyword">user</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">USER_ID</th><th style="text-align:center">USER_NAME</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">frank</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">barry</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">peter</td></tr></tbody></table><h4 id="SELECT-DISTINCT"><a href="#SELECT-DISTINCT" class="headerlink" title="SELECT DISTINCT"></a>SELECT DISTINCT</h4><p>把返回结果中重复的值去掉</p><blockquote><p>SELECT DISTINCT 列名称 FROM 表名称</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id <span class="keyword">from</span> grade</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">USER_ID</th></tr></thead><tbody><tr><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2</td></tr><tr><td style="text-align:center">3</td></tr><tr><td style="text-align:center">3</td></tr><tr><td style="text-align:center">2</td></tr><tr><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> user_id <span class="keyword">from</span> grade</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">USER_ID</th></tr></thead><tbody><tr><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2</td></tr><tr><td style="text-align:center">3</td></tr></tbody></table><h4 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h4><p>增加筛选的条件</p><blockquote><p>SELECT 列名称 FROM 表名称 WHERE 列 运算符 值</p></blockquote><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>=</td><td>等于</td></tr><tr><td>&lt;&gt;</td><td>不等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>BETWEEN..AND..</td><td>在某个范围内  (字母顺序或数字顺序)</td></tr><tr><td>NOT BETWEEN..AND..</td><td>不在某个范围内  (字母顺序或数字顺序)</td></tr><tr><td>LIKE ‘%..%’</td><td>以某种模式模糊匹配（字符串）</td></tr><tr><td>NOT LIKE ‘%..%’</td><td>除了模糊匹配的以外的（字符串）</td></tr><tr><td>IN ( .. , .. , .. )</td><td>在列表里</td></tr><tr><td>NOT IN ( .. , .. , .. )</td><td>不在列表里</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> user_name = <span class="string">'frank'</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">USER_ID</th></tr></thead><tbody><tr><td style="text-align:center">1</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id,user_name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> user_name <span class="keyword">like</span> <span class="string">'%r%'</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">USER_ID</th><th style="text-align:center">USER_NAME</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">frank</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">barry</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">peter</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> user_name <span class="keyword">in</span> (<span class="string">'frank'</span>,<span class="string">'barry'</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">USER_ID</th></tr></thead><tbody><tr><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2</td></tr></tbody></table><h4 id="AND-amp-OR"><a href="#AND-amp-OR" class="headerlink" title="AND&amp;OR"></a>AND&amp;OR</h4><p>AND 和 OR 可在 WHERE 子语句中把两个或多个条件结合起来</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> score <span class="keyword">from</span> grade <span class="keyword">where</span> course_id = <span class="number">2</span> <span class="keyword">and</span> user_id = <span class="number">2</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">SCORE</th></tr></thead><tbody><tr><td style="text-align:center">90</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> score <span class="keyword">from</span> grade <span class="keyword">where</span> course_id = <span class="number">2</span> <span class="keyword">and</span> (user_id = <span class="number">1</span> <span class="keyword">or</span> user_id = <span class="number">2</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">SCORE</th></tr></thead><tbody><tr><td style="text-align:center">73</td></tr><tr><td style="text-align:center">90</td></tr></tbody></table><h4 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h4><p>用于根据指定的列对结果集进行排序，<strong>默认是升序</strong>，字母顺序或数字顺序</p><table><thead><tr><th style="text-align:center">顺序</th><th style="text-align:center">符号</th></tr></thead><tbody><tr><td style="text-align:center">升序</td><td style="text-align:center">ASC</td></tr><tr><td style="text-align:center">降序</td><td style="text-align:center">DESC</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> score <span class="keyword">from</span> grade <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">SCORE</th></tr></thead><tbody><tr><td style="text-align:center">93</td></tr><tr><td style="text-align:center">90</td></tr><tr><td style="text-align:center">88</td></tr><tr><td style="text-align:center">86</td></tr><tr><td style="text-align:center">73</td></tr><tr><td style="text-align:center">69</td></tr><tr><td style="text-align:center">54</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">order</span> <span class="keyword">by</span> user_name</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">USER_NAME</th></tr></thead><tbody><tr><td style="text-align:center">barry</td></tr><tr><td style="text-align:center">frank</td></tr><tr><td style="text-align:center">peter</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id,score <span class="keyword">from</span> grade <span class="keyword">order</span> <span class="keyword">by</span> user_id <span class="keyword">desc</span> , score <span class="keyword">asc</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">USER_ID</th><th style="text-align:center">SCORE</th></tr></thead><tbody><tr><td style="text-align:center">3</td><td style="text-align:center">54</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">88</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">86</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">90</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">93</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">69</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">73</td></tr></tbody></table><h4 id="INSERT-INTO"><a href="#INSERT-INTO" class="headerlink" title="INSERT INTO"></a>INSERT INTO</h4><p>用于向表格中插入新的行</p><blockquote><p>INSERT INTO 表名称 VALUES (值1, 值2,….)</p><p>INSERT INTO table_name (列1, 列2,…) VALUES (值1, 值2,….)</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> <span class="keyword">values</span> (<span class="number">4</span>,<span class="string">'tom'</span>,<span class="number">16063385</span>);</span><br><span class="line"><span class="keyword">select</span> user_name <span class="keyword">from</span> <span class="keyword">user</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">USER_NAME</th></tr></thead><tbody><tr><td style="text-align:center">frank</td></tr><tr><td style="text-align:center">barry</td></tr><tr><td style="text-align:center">peter</td></tr><tr><td style="text-align:center">tom</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (user_id,user_name) <span class="keyword">values</span> (<span class="number">5</span>,<span class="string">'jerry'</span>);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">USER_ID</th><th style="text-align:center">USER_NAME</th><th style="text-align:center">CLASS_ID</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">frank</td><td style="text-align:center">16052502</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">barry</td><td style="text-align:center">16031023</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">peter</td><td style="text-align:center">16021314</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">tom</td><td style="text-align:center">16063385</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">jerry</td></tr></tbody></table><h4 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h4><p>用于修改表中的数据</p><blockquote><p>UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> grade <span class="keyword">set</span> score = <span class="number">100</span> <span class="keyword">where</span> user_id = <span class="number">1</span> <span class="keyword">and</span> course_id = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">select</span> user_id,course_id,score <span class="keyword">from</span> grade <span class="keyword">where</span> user_id = <span class="number">1</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">USER_ID</th><th style="text-align:center">COURSE_ID</th><th style="text-align:center">SCORE</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">73</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center">100</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> grade <span class="keyword">set</span> course_id = <span class="number">1</span>,score = <span class="number">99</span> <span class="keyword">where</span> user_id = <span class="number">1</span> <span class="keyword">and</span> course_id = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">select</span> user_id,course_id,score <span class="keyword">from</span> grade <span class="keyword">where</span> user_id = <span class="number">1</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">USER_ID</th><th style="text-align:center">COURSE_ID</th><th style="text-align:center">SCORE</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">99</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center">100</td></tr></tbody></table><h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><p>用于删除表中的行</p><blockquote><p>DELETE FROM 表名称 WHERE 列名称 = 值</p><p>DELETE FROM table_name  删除表内所有的行</p><p>DELETE * FROM table_name  删除表内所有的行</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> user_name = <span class="string">'peter'</span>;</span><br><span class="line"><span class="keyword">select</span> user_id,user_name <span class="keyword">from</span> <span class="keyword">user</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">USER_ID</th><th style="text-align:center">USER_NAME</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">frank</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">barry</td></tr></tbody></table><h3 id="进阶语法"><a href="#进阶语法" class="headerlink" title="进阶语法"></a>进阶语法</h3><h4 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h4><p>用于规定要返回的记录的数目</p><blockquote><p>SELECT column_name(s)<br>FROM table_name<br>LIMIT number</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">limit</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">USER_NAME</th></tr></thead><tbody><tr><td style="text-align:center">frank</td></tr><tr><td style="text-align:center">barry</td></tr></tbody></table><h4 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h4><p>用于在 WHERE 子句中搜索列中的指定模式</p><blockquote><p>SELECT column_name(s)<br>FROM table_name<br>WHERE column_name LIKE pattern</p></blockquote><p>提示：”%” 可用于定义通配符（模式中缺少的字母）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id,user_name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">like</span> <span class="string">'%r'</span>   <span class="comment">--结尾是r</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">USER_ID</th><th style="text-align:center">USER_NAME</th></tr></thead><tbody><tr><td style="text-align:center">3</td><td style="text-align:center">peter</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id,user_name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">not</span> <span class="keyword">like</span> <span class="string">'f%'</span>  <span class="comment">--开头不是f</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">USER_ID</th><th style="text-align:center">USER_NAME</th></tr></thead><tbody><tr><td style="text-align:center">2</td><td style="text-align:center">barry</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">peter</td></tr></tbody></table><h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>在搜索数据库中的数据时，SQL 通配符可以替代一个或多个字符。</p><p>SQL 通配符必须与 LIKE 运算符一起使用。</p><table><thead><tr><th>通配符</th><th>描述</th></tr></thead><tbody><tr><td>%</td><td>替代一个或多个字符</td></tr><tr><td>_</td><td>仅替代一个字符</td></tr><tr><td>[charlist]</td><td>字符列中的任何单一字符</td></tr><tr><td>[^charlist]或者[!charlist]</td><td>不在字符列中的任何单一字符</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">like</span> <span class="string">'[fb]%'</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">USER_NAME</th></tr></thead><tbody><tr><td style="text-align:center">frank</td></tr><tr><td style="text-align:center">barry</td></tr></tbody></table><h4 id="AS别名"><a href="#AS别名" class="headerlink" title="AS别名"></a>AS别名</h4><p>为列名称和表名称指定别名</p><p>表的别名</p><blockquote><p>SELECT column_name(s)<br>FROM table_name<br>AS alias_name</p></blockquote><p>列的别名</p><blockquote><p>SELECT column_name AS alias_name<br>FROM table_name</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id, user_name <span class="keyword">as</span> <span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'frank'</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">USER_ID</th><th style="text-align:center">NAME</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">frank</td></tr></tbody></table><h4 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h4><p>之前都是在一个表里进行查询，当查询涉及两个表以上时，就叫连接查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user.user_name,course.course_name <span class="keyword">from</span> <span class="keyword">user</span>,course</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">USER_NAME</th><th style="text-align:center">COURSE_NAME</th></tr></thead><tbody><tr><td style="text-align:center">frank</td><td style="text-align:center">数据库</td></tr><tr><td style="text-align:center">frank</td><td style="text-align:center">操作系统</td></tr><tr><td style="text-align:center">frank</td><td style="text-align:center">数据结构</td></tr><tr><td style="text-align:center">barry</td><td style="text-align:center">数据库</td></tr><tr><td style="text-align:center">barry</td><td style="text-align:center">操作系统</td></tr><tr><td style="text-align:center">barry</td><td style="text-align:center">数据结构</td></tr><tr><td style="text-align:center">peter</td><td style="text-align:center">数据库</td></tr><tr><td style="text-align:center">peter</td><td style="text-align:center">操作系统</td></tr><tr><td style="text-align:center">peter</td><td style="text-align:center">数据结构</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user.user_name,class.class_name <span class="keyword">from</span> <span class="keyword">user</span>,<span class="keyword">class</span> <span class="keyword">where</span> user.class_id = class.class_id</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">USER_NAME</th><th style="text-align:center">CLASS_NAME</th></tr></thead><tbody><tr><td style="text-align:center">frank</td><td style="text-align:center">电子2班</td></tr><tr><td style="text-align:center">barry</td><td style="text-align:center">软工3班</td></tr><tr><td style="text-align:center">peter</td><td style="text-align:center">会计4班</td></tr></tbody></table><h4 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h4><p>专门用于查询两张及两张表以上的数据</p><h5 id="INNER-JOIN"><a href="#INNER-JOIN" class="headerlink" title="INNER JOIN"></a>INNER JOIN</h5><p>两张表里都有匹配的话，就返回那一行</p><blockquote><p>SELECT column_name(s)<br>FROM table_name1<br>INNER JOIN table_name2<br>ON table_name1.column_name=table_name2.column_name</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user.user_name,grade.score <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">inner</span> <span class="keyword">join</span> grade <span class="keyword">on</span> user.user_id = grade.user_id</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">USER_NAME</th><th style="text-align:center">SCORE</th></tr></thead><tbody><tr><td style="text-align:center">frank</td><td style="text-align:center">73</td></tr><tr><td style="text-align:center">frank</td><td style="text-align:center">69</td></tr><tr><td style="text-align:center">barry</td><td style="text-align:center">86</td></tr><tr><td style="text-align:center">barry</td><td style="text-align:center">90</td></tr><tr><td style="text-align:center">barry</td><td style="text-align:center">93</td></tr><tr><td style="text-align:center">peter</td><td style="text-align:center">54</td></tr><tr><td style="text-align:center">peter</td><td style="text-align:center">88</td></tr></tbody></table><h5 id="LEFT-JOIN"><a href="#LEFT-JOIN" class="headerlink" title="LEFT JOIN"></a>LEFT JOIN</h5><p>LEFT JOIN 关键字会从左表那里返回所有的行，即使在右表中没有匹配的行</p><p>这里的左表就是指下面的table_name1，右表指的是下面的table_name2</p><blockquote><p>SELECT column_name(s)<br>FROM table_name1<br>LEFT JOIN table_name2<br>ON table_name1.column_name=table_name2.column_name</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(user_id,user_name) <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">'shell'</span>);</span><br><span class="line"><span class="keyword">select</span> user.user_name,class.class_name <span class="keyword">from</span> <span class="keyword">user</span> </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> <span class="keyword">class</span> <span class="keyword">on</span> user.class_id = class.class_id</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">USER_NAME</th><th style="text-align:center">CLASS_NAME</th></tr></thead><tbody><tr><td style="text-align:center">peter</td><td style="text-align:center">会计4班</td></tr><tr><td style="text-align:center">barry</td><td style="text-align:center">软工3班</td></tr><tr><td style="text-align:center">frank</td><td style="text-align:center">电子2班</td></tr><tr><td style="text-align:center">shell</td></tr></tbody></table><h5 id="RIGHT-JOIN"><a href="#RIGHT-JOIN" class="headerlink" title="RIGHT JOIN"></a>RIGHT JOIN</h5><p>RIGHT JOIN 关键字会右表那里返回所有的行，即使在左表中没有匹配的行。</p><p>这里的左表就是指下面的table_name1，右表指的是下面的table_name2</p><blockquote><p>SELECT column_name(s)<br>FROM table_name1<br>RIGHT JOIN table_name2<br>ON table_name1.column_name=table_name2.column_name</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">class</span> <span class="keyword">values</span> (<span class="number">16090134</span>,<span class="string">'新建班级'</span>,<span class="number">50</span>);</span><br><span class="line"><span class="keyword">select</span> user.user_name,class.class_name <span class="keyword">from</span> <span class="keyword">user</span> </span><br><span class="line"><span class="keyword">right</span> <span class="keyword">join</span> <span class="keyword">class</span> <span class="keyword">on</span> user.class_id = class.class_id</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">USER_NAME</th><th style="text-align:center">CLASS_NAME</th></tr></thead><tbody><tr><td style="text-align:center">frank</td><td style="text-align:center">电子2班</td></tr><tr><td style="text-align:center">barry</td><td style="text-align:center">软工3班</td></tr><tr><td style="text-align:center">peter</td><td style="text-align:center">会计4班</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">新建班级</td></tr></tbody></table><h5 id="FULL-JOIN"><a href="#FULL-JOIN" class="headerlink" title="FULL JOIN"></a>FULL JOIN</h5><p>只要其中某个表存在匹配，就会返回行</p><blockquote><p>SELECT column_name(s)<br>FROM table_name1<br>FULL JOIN table_name2<br>ON table_name1.column_name=table_name2.column_name</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user.user_name,class.class_name <span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">full</span> <span class="keyword">join</span> <span class="keyword">class</span> <span class="keyword">on</span> user.class_id = class.class_id</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">USR_NAME</th><th style="text-align:center">CLASS_NAME</th></tr></thead><tbody><tr><td style="text-align:center">frank</td><td style="text-align:center">电子2班</td></tr><tr><td style="text-align:center">barry</td><td style="text-align:center">软工3班</td></tr><tr><td style="text-align:center">peter</td><td style="text-align:center">会计4班</td></tr><tr><td style="text-align:center">shell</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">新建班级</td></tr></tbody></table><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>一个select语句中嵌套另一个select语句</p><p><a href="http://justcode.ikeepstudying.com/2016/08/mysql%E5%85%A5%E9%97%A8-%E4%B9%9D-%E5%AD%90%E6%9F%A5%E8%AF%A2-subquery/" target="_blank" rel="noopener">MySQL子查询</a></p><h5 id="当子查询返回的是一个结果"><a href="#当子查询返回的是一个结果" class="headerlink" title="当子查询返回的是一个结果"></a>当子查询返回的是一个结果</h5><blockquote><p>SELECT column_name(s)</p><p>FROM table_name</p><p>WHERE column_name 运算符 (SELECT子查询)</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_name <span class="keyword">from</span> <span class="keyword">user</span> </span><br><span class="line"><span class="keyword">where</span> class_id = (<span class="keyword">select</span> class_id <span class="keyword">from</span> <span class="keyword">class</span> <span class="keyword">where</span> class_name = <span class="string">'软工3班'</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">USER_NAME</th></tr></thead><tbody><tr><td style="text-align:center">barry</td></tr></tbody></table><h5 id="IN-NOT-IN"><a href="#IN-NOT-IN" class="headerlink" title="IN / NOT IN"></a>IN / NOT IN</h5><p>当子查询返回的结果有多个的时候，判断是不是在子查询的结果里</p><blockquote><p>SELECT column_name(s)</p><p>FROM table_name</p><p>WHERE column_name IN (SELECT子查询)</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> user_id <span class="keyword">in</span> (<span class="keyword">select</span> user_id <span class="keyword">from</span> grade <span class="keyword">where</span> score &gt; <span class="number">80</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">USER_NAME</th></tr></thead><tbody><tr><td style="text-align:center">barry</td></tr><tr><td style="text-align:center">peter</td></tr></tbody></table><h5 id="EXISTS-NOT-EXISTS"><a href="#EXISTS-NOT-EXISTS" class="headerlink" title="EXISTS / NOT EXISTS"></a>EXISTS / NOT EXISTS</h5><p>判断子查询的结果存不存在</p><blockquote><p>SELECT column_name(s)</p><p>FROM table_name</p><p>WHER EXISTS (SELECT子查询)</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_name <span class="keyword">from</span> <span class="keyword">user</span> </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> grade <span class="keyword">where</span> user.user_id = grade.user_id <span class="keyword">and</span> grade.score &gt; <span class="number">80</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">USER_NAME</th></tr></thead><tbody><tr><td style="text-align:center">barry</td></tr><tr><td style="text-align:center">peter</td></tr></tbody></table><h5 id="ANY-SOME"><a href="#ANY-SOME" class="headerlink" title="ANY / SOME"></a>ANY / SOME</h5><p>当子查询返回的结果有多个的时候，表示任何的意思，ANY和SOME的结果一样，如where n &gt; any (1,2) 等同 where n &gt; 1 or n &gt; 2, n&gt;1或n&gt;2都行</p><blockquote><p>SELECT column_name(s)</p><p>FROM table_name</p><p>WHERE column_name 运算符 ANY (SELECT子查询)</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> class_id =  </span><br><span class="line"><span class="keyword">any</span> (<span class="keyword">select</span> class_id <span class="keyword">from</span> <span class="keyword">class</span> <span class="keyword">where</span> class_name = <span class="string">'软工3班'</span> <span class="keyword">and</span> class_name = <span class="string">'会计4班'</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">USER_NAME</th></tr></thead><tbody><tr><td style="text-align:center">barry</td></tr><tr><td style="text-align:center">peter</td></tr></tbody></table><h5 id="ALL"><a href="#ALL" class="headerlink" title="ALL"></a>ALL</h5><p>当子查询返回的结果有多个的时候，表示所有的意思，如where n &gt; all (1,2) 等同 where n &gt; 1 and n &gt; 2, 必须满足n &gt; 1 和 n &gt; 2</p><blockquote><p>SELECT column_name(s)</p><p>FROM table_name</p><p>WHERE column_name 运算符 ALL (SELECT子查询)</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> score <span class="keyword">from</span> grade <span class="keyword">where</span> score &gt; <span class="keyword">all</span> (<span class="keyword">select</span> score <span class="keyword">from</span> grade <span class="keyword">where</span> user_id = <span class="number">3</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">SCORE</th></tr></thead><tbody><tr><td style="text-align:center">90</td></tr><tr><td style="text-align:center">93</td></tr></tbody></table><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h5 id="AVG"><a href="#AVG" class="headerlink" title="AVG()"></a>AVG()</h5><p>求该列的平均值</p><blockquote><p>SELECT AVG(column_name) FROM table_name</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(score) <span class="keyword">as</span> avg_score <span class="keyword">from</span> grade</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">AVG_SCORE</th></tr></thead><tbody><tr><td style="text-align:center">79</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> user_id </span><br><span class="line"><span class="keyword">in</span> (<span class="keyword">select</span> user_id <span class="keyword">from</span> grade <span class="keyword">where</span> score &gt; (<span class="keyword">select</span> <span class="keyword">avg</span>(score) <span class="keyword">from</span> grade))</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">USER_NAME</th></tr></thead><tbody><tr><td style="text-align:center">barry</td></tr><tr><td style="text-align:center">peter</td></tr></tbody></table><h5 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT()"></a>COUNT()</h5><p>返回匹配指定条件的行数</p><blockquote><p>SELECT COUNT(column_name) FROM table_name</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(user_id) <span class="keyword">as</span> user_sum <span class="keyword">from</span> grade</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">USER_SUM</th></tr></thead><tbody><tr><td style="text-align:center">7</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> user_id) <span class="keyword">as</span> user_sum <span class="keyword">from</span> grade</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">USER_SUM</th></tr></thead><tbody><tr><td style="text-align:center">3</td></tr></tbody></table><h5 id="MAX"><a href="#MAX" class="headerlink" title="MAX()"></a>MAX()</h5><p>返回一列中的最大值</p><blockquote><p>SELECT MAX(column_name) FROM table_name</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(score) <span class="keyword">from</span> grade</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">MAX(SCORE)</th></tr></thead><tbody><tr><td style="text-align:center">93</td></tr></tbody></table><h5 id="MIN"><a href="#MIN" class="headerlink" title="MIN()"></a>MIN()</h5><p>返回一列中的最小值</p><blockquote><p>SELECT MIN(column_name) FROM table_name</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">min</span>(score) <span class="keyword">from</span> grade</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">MIN(SCORE)</th></tr></thead><tbody><tr><td style="text-align:center">54</td></tr></tbody></table><h5 id="SUM"><a href="#SUM" class="headerlink" title="SUM()"></a>SUM()</h5><p>返回数值列的总数</p><blockquote><p>SELECT SUM(column_name) FROM table_name</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(score) <span class="keyword">from</span> grade</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">SUM(SCORE)</th></tr></thead><tbody><tr><td style="text-align:center">553</td></tr></tbody></table><h4 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h4><p>根据一个或多个列对结果集进行分组</p><blockquote><p>SELECT column_name, aggregate_function(column_name)<br>FROM table_name<br>WHERE column_name operator value<br>GROUP BY column_name</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id,<span class="keyword">avg</span>(score) <span class="keyword">as</span> <span class="keyword">avg</span> <span class="keyword">from</span> grade <span class="keyword">group</span> <span class="keyword">by</span> user_id</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">USER_ID</th><th style="text-align:center">AVG</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">71.000</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">89.667</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">71.000</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id,course_id,<span class="keyword">sum</span>(score) <span class="keyword">from</span> grade <span class="keyword">group</span> <span class="keyword">by</span> user_id,course_id</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">USER_ID</th><th style="text-align:center">COURSE_ID</th><th style="text-align:center">SUM(SCORE)</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">73</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center">69</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">86</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">90</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">93</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">1</td><td style="text-align:center">54</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">88</td></tr></tbody></table><h4 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h4><p>和where类似，不过筛选条件可以有函数<br><strong>where过滤行，而having过滤分组</strong></p><blockquote><p>SELECT column_name, aggregate_function(column_name)<br>FROM table_name<br>WHERE column_name operator value<br>GROUP BY column_name<br>HAVING aggregate_function(column_name) operator value</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id,<span class="keyword">avg</span>(score) <span class="keyword">from</span> grade <span class="keyword">where</span> user_id &gt; <span class="number">1</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> user_id</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">avg</span>(score) &gt; <span class="number">70</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">USER_ID</th><th style="text-align:center">AVG(SCORE)</th></tr></thead><tbody><tr><td style="text-align:center">2</td><td style="text-align:center">89.667</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">71.000</td></tr></tbody></table><h4 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h4><blockquote><p>UNION 操作符用于合并两个或多个 SELECT 语句的结果集</p></blockquote><p>请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> course_name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">inner</span> <span class="keyword">join</span> grade <span class="keyword">on</span> user.user_id = grade.user_id <span class="keyword">inner</span> <span class="keyword">join</span> course <span class="keyword">on</span> grade.course_id = course.course_id <span class="keyword">where</span> user_name = frank;</span><br><span class="line">union</span><br><span class="line"><span class="keyword">select</span> course_name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">inner</span> <span class="keyword">join</span> grade <span class="keyword">on</span> user.user_id = grade.user_id <span class="keyword">inner</span> <span class="keyword">join</span> course <span class="keyword">on</span> grade.course_id = course.course_id <span class="keyword">where</span> user_name = barry;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">COURSE_NAME</th></tr></thead><tbody><tr><td style="text-align:center">数据库</td></tr><tr><td style="text-align:center">操作系统</td></tr><tr><td style="text-align:center">数据结构</td></tr></tbody></table><h4 id="UNION-ALL"><a href="#UNION-ALL" class="headerlink" title="UNION ALL"></a>UNION ALL</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> course_name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">inner</span> <span class="keyword">join</span> grade <span class="keyword">on</span> user.user_id = grade.user_id <span class="keyword">inner</span> <span class="keyword">join</span> course <span class="keyword">on</span> grade.course_id = course.course_id <span class="keyword">where</span> user_name = frank;</span><br><span class="line">union all</span><br><span class="line"><span class="keyword">select</span> course_name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">inner</span> <span class="keyword">join</span> grade <span class="keyword">on</span> user.user_id = grade.user_id <span class="keyword">inner</span> <span class="keyword">join</span> course <span class="keyword">on</span> grade.course_id = course.course_id <span class="keyword">where</span> user_name = barry;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">COURSE_NAME</th></tr></thead><tbody><tr><td style="text-align:center">数据库</td></tr><tr><td style="text-align:center">操作系统</td></tr><tr><td style="text-align:center">数据结构</td></tr><tr><td style="text-align:center">操作系统</td></tr><tr><td style="text-align:center">数据结构</td></tr></tbody></table><p>#### </p>]]></content>
    
    <summary type="html">
    
      举例说明了SQL的增删改查和一些基本函数的语法
    
    </summary>
    
      <category term="DataBase" scheme="https://barry215.github.io/categories/DataBase/"/>
    
    
      <category term="sql" scheme="https://barry215.github.io/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>Java 实践</title>
    <link href="https://barry215.github.io/2016/10/26/Java-practice/"/>
    <id>https://barry215.github.io/2016/10/26/Java-practice/</id>
    <published>2016-10-26T07:43:18.000Z</published>
    <updated>2017-03-24T03:28:09.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java设计模式"><a href="#java设计模式" class="headerlink" title="java设计模式"></a>java设计模式</h3><h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><ul><li>思想<ul><li>当你有很多类似的类需要实例化的时候，你可以建造一个工厂，让工厂来生产(实例化)它们</li></ul></li><li>举例<ul><li>自定义了很多异常，每次程序运行出错都需要生成不同类型的异常，我们可以用异常工厂来生产这些异常</li><li>你是一个身怀满技的工人，想制作电脑做生意，但是电脑制作工艺更新太快，一个人学不过来，所以开一家工厂，让工厂来生产电脑，这样你就不用学这么多电脑制作的知识了。你只需要吩咐工厂生产。</li></ul></li></ul><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><ul><li>思想<ul><li>建立在简单工厂的思想下，我们把具体工厂生产实例的方法抽象出来，再建一个抽象型的工厂，用于制定生产规范</li></ul></li><li>举例<ul><li>你现在有了一家生产电脑的大工厂，专门生产各种类型的电脑。后来，这家工厂太大，生产的电脑型号也太多，你为了管理和分工方便，把工厂拆分成苹果电脑工厂，平板电脑工厂，普通电脑工厂三家工厂，然后再创建一个工厂监制会，专门统一每个工厂必须要有的流程和加工。然后每个工厂都按照监制会的标准去生产不同类型的电脑。</li></ul></li></ul><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><ul><li><p>思想</p><ul><li>这个世界上有些东西是独一无二的，我们必须保证它只能有一个实例。</li></ul></li><li><p>特征</p><ul><li>单例类只能有一个实例</li><li>单例类必须自行创建自己的唯一的实例</li><li>单例类必须给所有其他对象提供这一实例</li><li><code>Singleton</code>(单例):在单例类的内部实现只生成一个实例，同时它提供一个静态的<code>getInstance()</code>方法，让使用者可以访问它的唯一实例</li><li>为了防止在外部对其实例化，将其构造函数设计为<code>私有</code></li><li>在单例类内部定义了一个<code>Singleton</code>类型的<strong>静态</strong>对象，作为外部共享的唯一实例。</li></ul></li><li><p>举例</p><ul><li>你是个好男人，把工厂赚的钱都给了老婆，但是老婆只能有一个</li></ul></li><li><p>实现方式</p><ul><li><p>线程不安全</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>synchronized <a href="http://www.jianshu.com/p/29854dc7bd86" target="_blank" rel="noopener">更多</a></p><ul><li>Java语言的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。</li></ul></li><li><p>用法</p><ul><li>修饰一个类，其作用的范围是synchronized后面括号括起来的部分，作用的对象是这个类的所有对象</li><li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象</li><li>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象</li><li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象</li></ul></li><li><p>线程安全</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h4><ul><li>思想<ul><li>在工厂模式下，多了一层导演者。可以简单理解成用户做一件事情，会先找外包公司，而不是直接找工厂。外包公司会根据用户的需求来选择合适的工厂来生产。</li></ul></li><li>举例<ul><li>后来你年纪大了，工厂的事情管的太累，所以你让邀请一个人当这家公司的CEO，你当董事局主席。工厂的业务都是CEO来负责，无论多开了几家工厂，和你都没有关系。你有事的话就吩咐CEO就好。</li></ul></li></ul><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><ul><li>思想<ul><li>我们笔记本用的到充电器其实就是个适配器，笔记本电脑的工作电压是20V，而我国的家庭用电是220V，如何让20V的笔记本电脑能够在220V的电压下工作？就是靠这个充电器搞定的。在软件开发中，有时也存在类似这种不兼容的情况，我们也可以像引入一个电源适配器一样引入一个称之为适配器的角色来协调这些存在不兼容的结构，这种设计方案即为适配器模式。</li></ul></li><li>举例<ul><li>你的公司遇到互联网大潮，需要转型到线上销售，但是你原来的公司没有电商部门，只有线下销售，所以你花重金请来了一个电商团队，帮你协调线上和线下的联合销售。</li></ul></li></ul><h4 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h4><p><a href="http://blog.csdn.net/chenssy/article/category/1424118" target="_blank" rel="noopener">设计模式总结</a></p><p><a href="http://wiki.jikexueyuan.com/project/java-design-pattern/" target="_blank" rel="noopener">23种设计模式</a></p><p><a href="http://www.jianshu.com/p/9bceeedaf658" target="_blank" rel="noopener">设计模式干货系列</a></p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><h4 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h4><p>关系型数据库中的一条记录中有若干个属性，若其中某一个属性组(注意是组)能唯一标识一条记录，该属性组就可以成为一个主键比如 ：</p><blockquote><p><strong>学生表(学号，姓名，性别，班级)</strong></p><p>其中每个学生的学号是唯一的，学号就是一个主键。</p><p><strong>用户表(用户名、密码、登录级别)</strong></p><p>其中用户名是唯一的, 用户名就是一个主键。</p><p>总之主键是能确定一条记录的唯一标识。</p></blockquote><h4 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h4><p>外键用于与另一张表的关联。是能确定另一张表记录的字段，用于保持数据的一致性。比如，A表中的一个字段，是B表的主键，那他就可以是A表的外键。</p><h4 id="基本的增删改查"><a href="#基本的增删改查" class="headerlink" title="基本的增删改查"></a>基本的增删改查</h4><ul><li>增加：insert into table1(field1,field2) values(value1,value2)</li><li>删除：delete from table1 where 范围</li><li>更新：update table1 set field1=value1 where 范围</li><li>查询：select field1,field2 from table1 where 范围</li></ul><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>导入相应jar包</p><h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><p>第一步：加载驱动类通过,java.lang.Class的静态方法forName(String className)实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);<span class="comment">//这行语句需要捕获，也就是加上try catch</span></span><br></pre></td></tr></table></figure><p>第二步：创建数据库的连接</p><ol><li>要连接数据库，需要向java.sql.DriverManager请求并获得Connection对象， 该对象就代表一个数据库的连接。使用DriverManager的getConnectin(String url , String username ,  String password )方法传入指定的欲连接的数据库的路径、数据库的用户名和密码来获得。 </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String url = <span class="string">"jdbc:mysql://localhost:3306/数据库名称"</span> ;    </span><br><span class="line">String username = <span class="string">"用户名"</span> ;   </span><br><span class="line">String password = <span class="string">"密码"</span> ;   </span><br><span class="line"><span class="keyword">try</span>&#123;   </span><br><span class="line">    Connection conn = DriverManager.getConnection(url , username , password ) ;   </span><br><span class="line">&#125;<span class="keyword">catch</span>(SQLException se)&#123;   </span><br><span class="line">    System.out.println(<span class="string">"数据库连接失败！"</span>);   </span><br><span class="line">    se.printStackTrace() ;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步：创建语句</p><p>个人不推荐使用Statement,容易发生SQL注入的问题，推荐使用PreparedStatement，可以预编译数据库语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">"select field1, field2, field3 from table1"</span></span><br><span class="line">PreparedStatement pre = conn.prepareStatement(sql);</span><br><span class="line">ResultSet rs = pre.executeQuery();</span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">System.out.println(rs.getInt(<span class="string">"field1"</span>));</span><br><span class="line">  <span class="comment">//这里认为field1是int类型所以用getInt方法，其他类型也有相应的方法，使用的时候注意不要出错即可。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步：关闭JDBC对象</p><p>操作完成以后要把所有使用的JDBC对象全都关闭，以释放JDBC资源，关闭顺序和声明顺序相反</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (rs!=<span class="keyword">null</span>)</span><br><span class="line">    rs.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">pre.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (conn!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                conn.close();</span><br><span class="line">                &#125;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><ul><li>介绍<ul><li>FTP 是File Transfer Protocol（文件传输协议）的英文简称，而中文简称为“文传协议”。用于Internet上的控制文件的双向传输。同时，它也是一个应用程序。基于不同的操作系统有不同的FTP应用程序，而所有这些应用程序都遵守同一种协议以传输文件。在FTP的使用当中，用户经常遇到两个概念：”下载”和”上传”。”下载”文件就是从远程主机拷贝文件至自己的计算机上；”上传”文件就是将文件从自己的计算机中拷贝至远程主机上。用Internet语言来说，用户可通过客户机程序向（从）远程主机上传（下载）文件。</li></ul></li><li>ftp地址<ul><li><a href="ftp://www.maijinta.top" target="_blank" rel="noopener">ftp://www.maijinta.top</a></li><li>账号：admin</li><li>密码：000000</li></ul></li></ul><p><img src="Java-practice/internet.png" alt="internet中的FTP和Http区别"></p><ul><li>ftp和http的区别<ul><li>Http，FTP是应用层协议，HTTP用来传输超文本而FTP用来传文件</li></ul></li></ul><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Linux是一种比Windows更加稳定，免费，性能高的操作系统。它被广泛用在服务器领域和移动端，比如安卓系统和嵌入式系统开发，所以我们学习网站开发，必须了解，并掌握Linux。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>在linux中，一切设备，一切软硬件都被看作是文件。</li><li>linux区分大小写</li><li>#(表示超级用户) </li><li>$(表示普通用户)</li><li>命令的参数可以一起使用，如<code>mkdir -vp</code></li></ul><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><h5 id="查看当前目录的绝对路径：pwd"><a href="#查看当前目录的绝对路径：pwd" class="headerlink" title="查看当前目录的绝对路径：pwd"></a>查看当前目录的绝对路径：<code>pwd</code></h5><h5 id="清屏：clear"><a href="#清屏：clear" class="headerlink" title="清屏：clear"></a>清屏：<code>clear</code></h5><h5 id="路径补全：tab-键"><a href="#路径补全：tab-键" class="headerlink" title="路径补全：tab 键"></a>路径补全：<code>tab</code> 键</h5><h5 id="测试网络是否连通：ping"><a href="#测试网络是否连通：ping" class="headerlink" title="测试网络是否连通：ping"></a>测试网络是否连通：<code>ping</code></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.baidu.com #向百度发送数据包，回收数据包</span><br></pre></td></tr></table></figure><h5 id="远程访问服务器：ssh"><a href="#远程访问服务器：ssh" class="headerlink" title="远程访问服务器：ssh"></a>远程访问服务器：<code>ssh</code></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh root@172.11.1.67 #用root用户来登录远程服务器,然后会提示你输入密码</span><br><span class="line">logout #退出</span><br></pre></td></tr></table></figure><h5 id="查看时间：date"><a href="#查看时间：date" class="headerlink" title="查看时间：date"></a>查看时间：<code>date</code></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">返回</span></span><br><span class="line">2016年11月 3日 星期四 14时27分28秒 CST</span><br></pre></td></tr></table></figure><h5 id="查看日期：cal"><a href="#查看日期：cal" class="headerlink" title="查看日期：cal"></a>查看日期：<code>cal</code></h5><h5 id="查看有哪些用户登录了系统：who"><a href="#查看有哪些用户登录了系统：who" class="headerlink" title="查看有哪些用户登录了系统：who"></a>查看有哪些用户登录了系统：<code>who</code></h5><h5 id="查看当前是哪个用户登录了系统：whoami"><a href="#查看当前是哪个用户登录了系统：whoami" class="headerlink" title="查看当前是哪个用户登录了系统：whoami"></a>查看当前是哪个用户登录了系统：<code>whoami</code></h5><h5 id="查看历史命令：history"><a href="#查看历史命令：history" class="headerlink" title="查看历史命令：history"></a>查看历史命令：<code>history</code></h5><h5 id="查看命令帮助：whatis-info-which-man-help"><a href="#查看命令帮助：whatis-info-which-man-help" class="headerlink" title="查看命令帮助：whatis,info,which,man,--help"></a>查看命令帮助：<code>whatis</code>,<code>info</code>,<code>which</code>,<code>man</code>,<code>--help</code></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用方法</span></span><br><span class="line">whatis command</span><br><span class="line">info command</span><br><span class="line">which command</span><br><span class="line">man command</span><br><span class="line">command -h</span><br><span class="line">command -help</span><br><span class="line">command --help</span><br><span class="line"><span class="meta">#</span><span class="bash">在只记得部分命令关键字的场合，我们可通过man -k来搜索；</span></span><br><span class="line"><span class="meta">#</span><span class="bash">需要知道某个命令的简要说明，可以使用whatis；而更详细的介绍，则可用info命令；</span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看命令在哪个位置，我们需要使用<span class="built_in">which</span>；</span></span><br><span class="line"><span class="meta">#</span><span class="bash">而对于命令的具体参数及使用方法，我们需要用到强大的man；</span></span><br><span class="line"><span class="meta">#</span><span class="bash">会在终端列出所有可用的命令,可以使用任何命令的-h或-<span class="built_in">help</span>选项来查看该命令的具体用法。</span></span><br></pre></td></tr></table></figure><h5 id="查文件或目录的大小：du"><a href="#查文件或目录的大小：du" class="headerlink" title="查文件或目录的大小：du"></a>查文件或目录的大小：<code>du</code></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">du -h 文件名</span><br><span class="line"><span class="meta">#</span><span class="bash">查看文件夹大小 du -h T01</span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看文件大小 du -h tt.txt</span></span><br></pre></td></tr></table></figure><h5 id="查看文件与目录的命令：ls"><a href="#查看文件与目录的命令：ls" class="headerlink" title="查看文件与目录的命令：ls"></a>查看文件与目录的命令：<code>ls</code></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls -l #列出长数据串，包含文件的属性与权限数据等，可以简写成:ll</span><br><span class="line">ls -a #列出全部的文件，连同隐藏文件（开头为.的文件）一起列出来（常用）</span><br><span class="line">ls -d #仅列出目录本身，而不是列出目录的文件数据  </span><br><span class="line">ls -h #将文件容量以较易读的方式（GB，kB等）列出来  </span><br><span class="line">ls -R #连同子目录的内容一起列出（递归列出），等于该目录下的所有文件都会显示出来</span><br></pre></td></tr></table></figure><h5 id="切换目录：cd"><a href="#切换目录：cd" class="headerlink" title="切换目录：cd"></a>切换目录：<code>cd</code></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd   # 切换到初始目录下</span><br><span class="line">cd /               # 切换到根目录下</span><br><span class="line">cd (directory)     # 切换到某个子目录下</span><br><span class="line">cd /root/Docements # 切换到目录/root/Docements  </span><br><span class="line">cd -               # 切换到上一次的目录</span><br><span class="line">cd ..              # 切换到上层目录</span><br><span class="line">cd ../path         # 切换到上层目录中的path目录中，“..”表示上一层目录</span><br></pre></td></tr></table></figure><h5 id="覆盖文件内容：echo"><a href="#覆盖文件内容：echo" class="headerlink" title="覆盖文件内容：echo"></a>覆盖文件内容：<code>echo</code></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用&gt;指令覆盖文件原内容并重新输入内容，若文件不存在则创建文件。</span></span><br><span class="line">echo "Raspberry" &gt; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">使用&gt;&gt;指令向文件追加内容，原内容将保存。</span></span><br><span class="line">echo "Intel Galileo" &gt;&gt; test.txt</span><br></pre></td></tr></table></figure><h5 id="创建文件：touch"><a href="#创建文件：touch" class="headerlink" title="创建文件：touch"></a>创建文件：<code>touch</code></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch 文件名</span><br><span class="line"><span class="meta">#</span><span class="bash">例如：</span></span><br><span class="line">touch test.txt</span><br></pre></td></tr></table></figure><h5 id="创建文件夹：mkdir"><a href="#创建文件夹：mkdir" class="headerlink" title="创建文件夹：mkdir"></a>创建文件夹：<code>mkdir</code></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir 文件夹 #创建文件夹</span><br><span class="line">mkdir -p 目录 #此时若路径中的某些目录尚不存在,系统将自动建立好那些尚不存在的目录,即递归创建多个目录</span><br><span class="line">mkdir -v 文件夹 #每次创建新目录都显示信息</span><br></pre></td></tr></table></figure><h5 id="删除空目录：rmdir"><a href="#删除空目录：rmdir" class="headerlink" title="删除空目录：rmdir"></a>删除空目录：<code>rmdir</code></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">例如</span></span><br><span class="line">rmdir d101 #删除空目录d101  </span><br><span class="line">rmdir d102 d103 #同时删除两个空目录d102,d103  </span><br><span class="line">rmdir -p d104/d105/ #删除d105目录后，若d104是空的，则连d104一起删除</span><br></pre></td></tr></table></figure><h5 id="搜寻指定的字符串：grep"><a href="#搜寻指定的字符串：grep" class="headerlink" title="搜寻指定的字符串：grep"></a>搜寻指定的字符串：<code>grep</code></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep "&lt;string&gt;" &lt;file-name&gt;</span><br><span class="line">grep -i "&lt;string&gt;" &lt;file-name&gt;    #在搜寻时会忽略字符串的大小写。</span><br><span class="line">grep -r "&lt;string&gt;" &lt;file-name&gt;    #则会在当前工作目录的文件中递归搜寻指定的字符串。</span><br></pre></td></tr></table></figure><h5 id="查找某目录下文件：find"><a href="#查找某目录下文件：find" class="headerlink" title="查找某目录下文件：find"></a>查找某目录下文件：<code>find</code></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 与时间有关的参数：  </span></span><br><span class="line">find -mtime n : n为数字，意思为在n天之前的“一天内”被更改过的文件；  </span><br><span class="line">find -mtime +n : 列出在n天之前（不含n天本身）被更改过的文件名；  </span><br><span class="line">find -mtime -n : 列出在n天之内（含n天本身）被更改过的文件名；  </span><br><span class="line">find -newer file : 列出比file还要新的文件名  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 例如：  </span></span><br><span class="line">find /root -mtime 0 # 在root目录下查找今天之内有改动的文件  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 与用户或用户组名有关的参数：  </span></span><br><span class="line">find -user name : 列出文件所有者为name的文件  </span><br><span class="line">find -group name : 列出文件所属用户组为name的文件  </span><br><span class="line">find -uid n : 列出文件所有者为用户ID为n的文件  </span><br><span class="line">find -gid n : 列出文件所属用户组为用户组ID为n的文件  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 例如：  </span></span><br><span class="line">find /home/ljianhui -user ljianhui # 在目录/home/ljianhui中找出所有者为ljianhui的文件</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 与文件权限及名称有关的参数：</span></span><br><span class="line">find -name filename ：找出文件名为filename的文件</span><br><span class="line">find -size [+-]SIZE ：找出比SIZE还要大（+）或小（-）的文件  </span><br><span class="line">find -tpye TYPE ：查找文件的类型为TYPE的文件，TYPE的值主要有：一般文件（f)、设备文件（b、c）、  </span><br><span class="line">         目录（d）、连接文件（l）、socket（s）、FIFO管道文件（p）；  </span><br><span class="line">find -perm mode ：查找文件权限刚好等于mode的文件，mode用数字表示，如 0755；  </span><br><span class="line">find -perm -mode ：查找文件权限必须要全部包括mode权限的文件，mode用数字表示  </span><br><span class="line">find -perm +mode ：查找文件权限包含任一mode的权限的文件，mode用数字表示  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 例如：  </span></span><br><span class="line">find / -name passwd # 查找文件名为passwd的文件  </span><br><span class="line">find . -perm 0755 # 查找当前目录中文件权限的0755的文件  </span><br><span class="line">find . -size +12k # 查找当前目录中大于12KB的文件，注意c表示byte</span><br></pre></td></tr></table></figure><h5 id="复制文件：cp"><a href="#复制文件：cp" class="headerlink" title="复制文件：cp"></a>复制文件：<code>cp</code></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cp -a #将文件的特性一起复制，相当于 -pdr 的意思</span><br><span class="line">cp -p #连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份  </span><br><span class="line">cp -i #若目标文件已经存在时，在覆盖时会先询问操作的进行  </span><br><span class="line">cp -d #若来源文件为连结文件的属性(link file)，则复制连结文件属性而非档案本身； </span><br><span class="line">cp -r #递归持续复制，用于目录的复制行为  </span><br><span class="line">cp -u #目标文件与源文件有差异时才会复制</span><br><span class="line"><span class="meta">#</span><span class="bash"> 例如：</span></span><br><span class="line">cp 源文件路径/源文件名 目标路径</span><br><span class="line">cp T01/test.txt T02/  </span><br><span class="line">cp -a file1 file2 #连同文件的所有特性把文件file1复制成文件file2  </span><br><span class="line">cp file1 file2 file3 dir #把文件file1、file2、file3复制到目录dir中</span><br></pre></td></tr></table></figure><h5 id="远程复制文件-夹-：scp"><a href="#远程复制文件-夹-：scp" class="headerlink" title="远程复制文件(夹)：scp"></a>远程复制文件(夹)：<code>scp</code></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">必须在本地使用中这条命令，不能在服务器上用</span></span><br><span class="line">scp [-r](递归复制) root@IP地址或域名:服务器文件(夹) 本地路径</span><br><span class="line">scp -r root@172.11.1.112:/root/install.log /root/</span><br></pre></td></tr></table></figure><h5 id="移动文件-目录或重命名：mv"><a href="#移动文件-目录或重命名：mv" class="headerlink" title="移动文件,目录或重命名：mv"></a>移动文件,目录或重命名：<code>mv</code></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-f #force强制的意思，如果目标文件已经存在，不会询问而直接覆盖  </span><br><span class="line">-i #若目标文件已经存在，就会询问是否覆盖  </span><br><span class="line">-u #若目标文件已经存在，且比目标文件新，才会更新</span><br><span class="line"><span class="meta">#</span><span class="bash"> 例如：</span></span><br><span class="line">mv file1 file2 file3 dir # 把文件file1、file2、file3移动到目录dir中  </span><br><span class="line">mv file1 file2 # 把文件file1重命名为file2</span><br></pre></td></tr></table></figure><blockquote><p>注：该命令可以把一个文件或多个文件一次移动一个文件夹中，但是最后一个目标文件一定要是“目录”。</p></blockquote><h5 id="删除文件或目录：rm"><a href="#删除文件或目录：rm" class="headerlink" title="删除文件或目录：rm"></a>删除文件或目录：<code>rm</code></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rm -f #就是force的意思，忽略不存在的文件，不会出现警告消息  </span><br><span class="line">rm -i #互动模式，在删除前会询问用户是否操作  </span><br><span class="line">rm -r #递归删除，最常用于目录删除，它是一个非常危险的参数</span><br><span class="line"><span class="meta">#</span><span class="bash"> 例如：</span></span><br><span class="line">rm -i file #删除文件file，在删除之前会询问是否进行该操作  </span><br><span class="line">rm -fr dir #强制删除目录dir中的所有文件</span><br></pre></td></tr></table></figure><h5 id="获取进程运行情况：ps"><a href="#获取进程运行情况：ps" class="headerlink" title="获取进程运行情况：ps"></a>获取进程运行情况：<code>ps</code></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ps -A #所有的进程均显示出来  </span><br><span class="line">ps -a #不与terminal有关的所有进程  </span><br><span class="line">ps -u #有效用户的相关进程  </span><br><span class="line">ps -x #一般与a参数一起使用，可列出较完整的信息  </span><br><span class="line">ps -l #较长，较详细地将PID的信息列出</span><br><span class="line">ps -ef #查看系统正在运行的进程</span><br><span class="line"><span class="meta">#</span><span class="bash"> 实例</span></span><br><span class="line">ps aux  # 列出目前所有的正在内存当中的程序</span><br><span class="line">ps ax   # 查看不与terminal有关的所有进程  </span><br><span class="line">ps -lA  # 查看系统所有的进程数据  </span><br><span class="line">ps axjf # 查看连同一部分进程树状态</span><br></pre></td></tr></table></figure><h5 id="显示CPU占用量较大的进程：top"><a href="#显示CPU占用量较大的进程：top" class="headerlink" title="显示CPU占用量较大的进程：top"></a>显示CPU占用量较大的进程：<code>top</code></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">top    #top命令会默认按照CPU的占用情况，显示占用量较大的进程</span><br><span class="line">top -u &lt;username&gt;    #查看某个用户的CPU使用排名情况。</span><br></pre></td></tr></table></figure><h5 id="判断文件的基本数据：file"><a href="#判断文件的基本数据：file" class="headerlink" title="判断文件的基本数据：file"></a>判断文件的基本数据：<code>file</code></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file filename</span><br><span class="line"><span class="meta">#</span><span class="bash">例如：</span></span><br><span class="line">file ger.txt</span><br><span class="line">输出 ger.txt:ASCII text</span><br></pre></td></tr></table></figure><blockquote><p>因为在Linux下文件的类型并不是以后缀为分的，所以这个命令对我们来说就很有用了</p></blockquote><h5 id="对文件进行打包：tar"><a href="#对文件进行打包：tar" class="headerlink" title="对文件进行打包：tar"></a>对文件进行打包：<code>tar</code></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">tar -c ：新建打包文件  </span><br><span class="line">tar -t ：查看打包文件的内容含有哪些文件名  </span><br><span class="line">tar -x ：解打包或解压缩的功能，可以搭配-C（大写）指定解压的目录，注意-c,-t,-x不能同时出现在同一条命令中  </span><br><span class="line">tar -j ：通过bzip2的支持进行压缩/解压缩  </span><br><span class="line">tar -z ：通过gzip的支持进行压缩/解压缩  </span><br><span class="line">tar -v ：在压缩/解压缩过程中，将正在处理的文件名显示出来  </span><br><span class="line">tar -f filename ：filename为要处理的文件  </span><br><span class="line">tar -C dir ：指定压缩/解压缩的目录dir</span><br><span class="line"><span class="meta">#</span><span class="bash"> 主要记住</span></span><br><span class="line">压缩：tar -jcv -f filename.tar.bz2 要被处理的文件或目录名称  </span><br><span class="line">查询：tar -jtv -f filename.tar.bz2  </span><br><span class="line">解压：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录</span><br><span class="line"><span class="meta">#</span><span class="bash"> 打包并压缩</span></span><br><span class="line">tar 参数 目标文件路径和包名 被打包的文件名称</span><br><span class="line">tar -czvf t101.tar.gz T101 #将目录和文件打到当前目录下的t101.tar.gz压缩包中</span><br><span class="line">tar -czvf /opt/t101.tar.gz T101 #将目录和文件打到/opt/t101.tgz压缩包中</span><br><span class="line">tar -tzvf ./t101.tar.gz #查看t101.tar.gz压缩包中的内容</span><br></pre></td></tr></table></figure><blockquote><p>注：</p><ul><li>默认情况并不会压缩，如果指定了相应的参数，它还会调用相应的压缩程序（如gzip和bzip等）进行压缩和解压</li><li>文件名并不定要以后缀tar.bz2结尾，这里主要是为了说明使用的压缩程序为bzip2</li></ul></blockquote><h5 id="查看文件的内容：more-less-cat-head-tail"><a href="#查看文件的内容：more-less-cat-head-tail" class="headerlink" title="查看文件的内容：more,less,cat,head,tail"></a>查看文件的内容：<code>more</code>,<code>less</code>,<code>cat</code>,<code>head</code>,<code>tail</code></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">more 文件名        #按回车一行，空格一页。不能向上下翻行。  </span><br><span class="line">less 文件名        #按回车一行，空格一页。可以通过上下键上下翻行。按q就退出。  </span><br><span class="line">cat 文件名         #查看文件的所有内容  </span><br><span class="line">cat -n 文件名      #查看文件的所有内容，并显示行数   </span><br><span class="line">head -n 文件名     #查看文件的前n行，n表示你要看的行数。  </span><br><span class="line">tail -n 文件名     #查看文件的后n行</span><br></pre></td></tr></table></figure><blockquote><ol><li>cat命令可以一次显示整个文件，如果文件比较大，使用不是很方便；</li><li>more命令可以让屏幕在显示满一屏幕时暂停，此时可按空格健继续显示下一个画面，或按Q键停止显示。</li><li>less命令也可以分页显示文件，和more命令的区别就在于它支持上下键卷动屏幕，当结束浏览时，只要在less命令的提示符“: ”下按Q键即可。</li></ol></blockquote><h5 id="改变文件所属用户组：chgrp"><a href="#改变文件所属用户组：chgrp" class="headerlink" title="改变文件所属用户组：chgrp"></a>改变文件所属用户组：<code>chgrp</code></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chgrp 组名 文件名</span><br><span class="line">chgrp g1015 echo.sh</span><br><span class="line">chgrp -R 组名 文件名</span><br><span class="line">-R #进行递归的持续对所有文件和子目录更改  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 例如：  </span></span><br><span class="line">chgrp -R users ./dir # 递归地把dir目录下中的所有文件和子目录下所有文件的用户组修改为users</span><br></pre></td></tr></table></figure><h5 id="改变文件的所有者：chown"><a href="#改变文件的所有者：chown" class="headerlink" title="改变文件的所有者：chown"></a>改变文件的所有者：<code>chown</code></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">更改单个文件的属主：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">chown 用户名 文件名</span></span><br><span class="line">chown wsg echo.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">更改文件夹的属主：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">语法：chown -R 用户名 文件名</span></span><br><span class="line">chown -R u101 Desktop/ #单独更改文件夹的拥有者(-R表示文件夹的所有子内容全部更改,*表示所有本目录文件)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">同时更改文件的拥有者和所属组</span></span><br><span class="line"><span class="meta">#</span><span class="bash">语法：chown 用户名:组名 文件名</span></span><br><span class="line">chown u101:g1015 install.log.syslog #同时更改文件的拥有者和所属组</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">同时更改文件夹和文件夹下的所有内容的拥有者和所属组</span></span><br><span class="line"><span class="meta">#</span><span class="bash">语法：chown -R 用户名:组名 文件名</span></span><br><span class="line">chown -R u101:g1015 test01 #同时更改文件的拥有者和所属组</span><br></pre></td></tr></table></figure><h5 id="改变文件的权限：chmod"><a href="#改变文件的权限：chmod" class="headerlink" title="改变文件的权限：chmod"></a>改变文件的权限：<code>chmod</code></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">chmod 权限 文件名</span><br><span class="line">如：chmod 755 filename</span><br><span class="line">ls -l命令</span><br><span class="line">获取：drwxr-xr-x  2 root root 4.0K 11-06 18:30 Desktop</span><br><span class="line">解释：</span><br><span class="line">r: read       可读</span><br><span class="line">w: write      可写</span><br><span class="line">x：execute    可执行</span><br><span class="line">d表示是个普通文件夹</span><br><span class="line">-表示普通文件</span><br><span class="line">r用数字4表示，w用数字2表示，x用数字1表示。</span><br><span class="line">第一个rwx，表示该文件所属的用户对其所拥有的操作权限</span><br><span class="line">第二个rwx，表示与该文件所属用户在同组内的用户对其所拥有的操作权限</span><br><span class="line">第三个rwx，表示不与该文件所属用户在同组内的用户对其所拥有的操作权限</span><br><span class="line">第一个root:表示该文件夹属于哪个用户</span><br><span class="line">第二个root:表示该文件夹属于哪个组</span><br><span class="line"></span><br><span class="line">chmod -R xyz 文件或目录  </span><br><span class="line">-R #进行递归的持续更改，即连同子目录下的所有文件都会更改</span><br><span class="line"><span class="meta">#</span><span class="bash"> 例如：  </span></span><br><span class="line">chmod -R 755 file # 把file的文件权限改变为-rxwr-xr-x</span><br><span class="line"><span class="meta">#</span><span class="bash"> 同时，chmod还可以使用u（user）、g（group）、o（other）、a（all）和+（加入）、-（删除）、=（设置）跟rwx搭配来对文件的权限进行更改。</span></span><br><span class="line">chmod g+w file # 向file的文件权限中加入用户组可写权限</span><br></pre></td></tr></table></figure><h5 id="文本编辑：vim-vi"><a href="#文本编辑：vim-vi" class="headerlink" title="文本编辑：vim,vi"></a>文本编辑：<code>vim</code>,<code>vi</code></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">Vim是从 vi 发展出来的一个文本编辑器</span></span><br><span class="line">vim</span><br><span class="line"><span class="meta">#</span><span class="bash">在命令行中输入vim,进入vim编辑器</span></span><br><span class="line">vim filename</span><br><span class="line"><span class="meta">#</span><span class="bash">用vim打开一个文件</span></span><br><span class="line">i</span><br><span class="line"><span class="meta">#</span><span class="bash">按一下i键,下端显示 --INSERT--</span></span><br><span class="line"><span class="meta">#</span><span class="bash">插入命令,在vim中可能任意字符都有作用</span></span><br><span class="line">Esc按键</span><br><span class="line"><span class="meta">#</span><span class="bash">退出i(插入)命令进行其它命令使用</span></span><br><span class="line">:w</span><br><span class="line"><span class="meta">#</span><span class="bash">在编辑的过程中保存文件,相当于word中的ctrl+s</span></span><br><span class="line">:w 文件名</span><br><span class="line"><span class="meta">#</span><span class="bash">另存为</span></span><br><span class="line">:wq</span><br><span class="line"><span class="meta">#</span><span class="bash">保存文件并退出</span></span><br><span class="line">:q!</span><br><span class="line"><span class="meta">#</span><span class="bash">强制退出,不保存</span></span><br><span class="line">u </span><br><span class="line"><span class="meta">#</span><span class="bash">撤消上一步操作</span></span><br><span class="line">dd</span><br><span class="line"><span class="meta">#</span><span class="bash">删除行</span></span><br></pre></td></tr></table></figure><h4 id="更多命令"><a href="#更多命令" class="headerlink" title="更多命令"></a>更多命令</h4><p><a href="http://www.jianshu.com/p/462c9e20ffb5" target="_blank" rel="noopener">29个你必须知道的Linux命令</a></p><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>Git是目前世界上最先进的分布式版本控制系统，以其优秀的控制能力独傲全球</p><h4 id="集中式版本控制系统-SVN-CVS"><a href="#集中式版本控制系统-SVN-CVS" class="headerlink" title="集中式版本控制系统-SVN,CVS"></a>集中式版本控制系统-SVN,CVS</h4><p>版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。</p><h4 id="分布式版本控制系统-Git"><a href="#分布式版本控制系统-Git" class="headerlink" title="分布式版本控制系统-Git"></a>分布式版本控制系统-Git</h4><p>分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p><h4 id="Git学习笔记"><a href="#Git学习笔记" class="headerlink" title="Git学习笔记"></a>Git学习笔记</h4><p><a href="http://jingyan.baidu.com/article/a65957f4e91ccf24e77f9b11.html" target="_blank" rel="noopener">window下配置SSH连接GitHub、GitHub配置ssh key</a></p><p><a href="http://www.jianshu.com/p/1d5e97222cad" target="_blank" rel="noopener">Gi基本操作</a></p><p><a href="http://www.jianshu.com/p/4416c3c61dba" target="_blank" rel="noopener">工作区、暂存区和版本库的关系</a></p><p><a href="http://www.jianshu.com/p/f0d6a5a4325f" target="_blank" rel="noopener">撤销或回退版本</a></p><p><a href="http://www.jianshu.com/p/8468d43074f3" target="_blank" rel="noopener">连接远程仓库</a></p><p><a href="http://www.jianshu.com/p/e7ddad179c9d" target="_blank" rel="noopener">协同工作</a></p><p><a href="http://www.jianshu.com/p/ee8c379ef888" target="_blank" rel="noopener">搭建git服务器</a></p><h4 id="Git命令"><a href="#Git命令" class="headerlink" title="Git命令"></a>Git命令</h4><p><img src="Java-practice/git.png" alt="git"></p><ul><li>workspace: 本地的工作目录。（记作A）</li><li>index：缓存区域，临时保存本地改动。（记作B）</li><li>local repository: 本地仓库，只想最后一次提交HEAD。（记作C）</li><li>remote repository：远程仓库。（记作D）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">初始化</span></span><br><span class="line">git version #查看git版本</span><br><span class="line">git init #创建</span><br><span class="line">git clone /path/to/repository #检出</span><br><span class="line">git config --global user.email "you@example.com" #配置email</span><br><span class="line">git config --global user.name "Name" #配置用户名</span><br><span class="line">ssh-keygen #创建SSH key</span><br><span class="line"><span class="meta">#</span><span class="bash">原理：首先由用户生成一对密钥，然后将公钥保存在SSH服务器用户的目录下.ssh子目录中的authorized_key文件里(/root/.ssh/authorized_key).私钥保存在本地计算机.当用户登陆时,服务器检查authorized_key文件的公钥是否与用户的私钥对应,如果相符则允许登入,否则拒绝.由于私钥只有保存在用户的本地计算机中,因此入侵者就算得到用户口令,也不能登陆到服务器.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">操作</span></span><br><span class="line">git add &lt;file&gt;  #文件添加，A → B</span><br><span class="line">git add .       #所有文件添加，A → B</span><br><span class="line"></span><br><span class="line">git commit -m "代码提交信息" #文件提交，B → C</span><br><span class="line">git commit --amend         #与上次commit合并, *B → C</span><br><span class="line"></span><br><span class="line">git push origin master     #推送至master分支, C → D</span><br><span class="line">git pull                   #更新本地仓库至最新改动， D → A</span><br><span class="line">git fetch                  #抓取远程仓库更新， D → C</span><br><span class="line"></span><br><span class="line">git log     #查看提交记录</span><br><span class="line">git status  #查看修改状态</span><br><span class="line">git diff    #查看详细修改内容</span><br><span class="line">git show    #显示某次提交的内容</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">撤销操作</span></span><br><span class="line">git reset &lt;file&gt;   #某个文件索引会回滚到最后一次提交， C → B</span><br><span class="line">git reset          #索引会回滚到最后一次提交， C → B</span><br><span class="line">git reset --hard   #索引会回滚到最后一次提交， C → B → A</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">仅仅只是撤销已提交的版本库，不会修改暂存区和工作区</span></span><br><span class="line">git reset --soft 版本库ID</span><br><span class="line"><span class="meta">#</span><span class="bash">仅仅只是撤销已提交的版本库和暂存区，不会修改工作区</span></span><br><span class="line">git reset --mixed 版本库ID</span><br><span class="line"><span class="meta">#</span><span class="bash">彻底将工作区、暂存区和版本库记录恢复到指定的版本库</span></span><br><span class="line">git reset --hard 版本库ID</span><br><span class="line"></span><br><span class="line">git checkout                #从index复制到workspace， B → A</span><br><span class="line">git checkout -- files       #文件从index复制到workspace， B → A</span><br><span class="line">git checkout HEAD -- files  #文件从local repository复制到workspace， C → A</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">分支相关</span></span><br><span class="line">git checkout -b branch_name     #创建名叫“branch_name”的分支，并切换过去</span><br><span class="line">git checkout master             #切换回主分支</span><br><span class="line">git branch -d branch_name       #删除名叫“branch_name”的分支</span><br><span class="line">git push origin branch_name     #推送分支到远端仓库</span><br><span class="line">git merge branch_name           #合并分支branch_name到当前分支(如master)</span><br><span class="line">git rebase                      #衍合，线性化的自动， D → A</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">冲突处理</span></span><br><span class="line">git diff #对比workspace与index</span><br><span class="line">git diff HEAD #对于workspace与最后一次commit</span><br><span class="line">git diff &lt;source_branch&gt; &lt;target_branch&gt; #对比差异</span><br><span class="line">git add &lt;filename&gt; #修改完冲突，需要add以标记合并成功</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">删除</span></span><br><span class="line">git rm filename #移除文件(从暂存区和工作区中删除)</span><br><span class="line">git rm --cached filename #移除文件(只从暂存区中删除)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看远端库</span></span><br><span class="line">git remote</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">其他</span></span><br><span class="line">gitk #开启图形化git</span><br><span class="line">git config color.ui true #彩色的 git 输出</span><br><span class="line">git config format.pretty oneline #显示历史记录时，每个提交的信息只显示一行</span><br><span class="line">git add -i #交互式添加文件到暂存区</span><br></pre></td></tr></table></figure><h4 id="Git忽略文件"><a href="#Git忽略文件" class="headerlink" title="Git忽略文件"></a>Git忽略文件</h4><p>在git中如果想忽略掉某个文件，不让这个文件提交到版本库中，可以使用修改根目录中 .gitignore 文件的方法（如无，则需自己手工建立此文件）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Git 中的文件忽略</span><br><span class="line">1. 共享式忽略新建 .gitignore 文件，放在工程目录任意位置即可。.gitignore 文件可以忽略自己。忽略的文件，只针对未跟踪文件有效，对已加入版本库的文件无效。</span><br><span class="line">2. 独享式忽略针对具体版本库 ：.git/info/exclude针对本地全局：git config --global core.excludefile ~/.gitignore</span><br><span class="line">忽略的语法规则：</span><br><span class="line"><span class="meta">(#</span><span class="bash">)表示注释</span></span><br><span class="line">(*)  表示任意多个字符; </span><br><span class="line">(?) 代表一个字符;</span><br><span class="line"> ([abc]) 代表可选字符范围</span><br><span class="line">如果名称最前面是路径分隔符 (/) ，表示忽略的该文件在此目录下。</span><br><span class="line">如果名称的最后面是 (/) ，表示忽略整个目录，但同名文件不忽略。</span><br><span class="line">通过在名称前面加 (!) ，代表不忽略。</span><br><span class="line">例子如下：</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这行是注释</span></span><br><span class="line">*.a                   # 忽略所有 .a 伟扩展名的文件</span><br><span class="line">!lib.a                # 但是 lib.a 不忽略，即时之前设置了忽略所有的 .a</span><br><span class="line">/TODO                 # 只忽略此目录下 TODO 文件，子目录的 TODO 不忽略 </span><br><span class="line">build/                # 忽略所有的 build/ 目录下文件</span><br><span class="line">doc/*.txt             # 忽略如 doc/notes.txt, 但是不忽略如 doc/server/arch.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">经测试发现，若要忽略一个文件夹下的部分文件夹，应该一个一个的标示。可能有更好的方法。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">若<span class="built_in">test</span>下有多个文件和文件夹。若要ignore某些文件夹，应该这个配置.gitignore文件。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">若<span class="built_in">test</span>下有test1，test2,test3文件。要track test3，则.gitignore文件为：</span></span><br><span class="line">test/test1</span><br><span class="line">test/test2</span><br><span class="line">!test/test3</span><br><span class="line"><span class="meta">#</span><span class="bash">若为：</span></span><br><span class="line">test/</span><br><span class="line">!test/test3 ，则不能track test3。</span><br></pre></td></tr></table></figure><h4 id="Git使用规范提醒"><a href="#Git使用规范提醒" class="headerlink" title="Git使用规范提醒"></a>Git使用规范提醒</h4><ul><li>使用Git过程中，必须通过创建分支进行开发，坚决禁止在主干分支上直接开发。review的同事有责任检查其他同事是否遵循分支规范。</li><li>在Git中，默认是不会提交空目录的，如果想提交某个空目录到版本库中，需要在该目录下新建一个 .gitignore 的空白文件，就可以提交了</li><li>把外部文件纳入到自己的 Git 分支来的时候一定要记得是先比对，确认所有修改都是自己修改的，然后再纳入。不然，容易出现代码回溯</li><li>多人协作时，不要各自在自己的 Git 分支开发，然后发文件合并。正确的方法应该是开一个远程分支，然后一起在远程分支里协作。不然，容易出现代码回溯（即别人的代码被覆盖的情况）</li><li>每个人提交代码是一定要 git diff 看提交的东西是不是都是自己修改的。如果有不是自己修改的内容，很可能就是代码回溯</li><li>review 代码的时候如果看到有被删除掉的代码，一定要确实是否是写代码的同事自己删除的。如果不是，很可能就是代码回溯</li></ul><h4 id="Git使用规范"><a href="#Git使用规范" class="headerlink" title="Git使用规范"></a>Git使用规范</h4><p>Git 使用规范流程 - <a href="http://www.ruanyifeng.com/blog/2015/08/git-use-process.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/08/git-use-process.html</a><br>团队中的 Git 实践 - <a href="https://ourai.ws/posts/working-with-git-in-team/" target="_blank" rel="noopener">https://ourai.ws/posts/working-with-git-in-team/</a><br>构家网 git 团队协作使用规范 v2 - <a href="http://wenku.baidu.com/view/e1430d1b7f1922791788e81e" target="_blank" rel="noopener">http://wenku.baidu.com/view/e1430d1b7f1922791788e81e</a></p><h4 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h4><p>Git Book - <a href="https://git-scm.com/book/zh/" target="_blank" rel="noopener">https://git-scm.com/book/zh/</a><br>git简明指南 - <a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="noopener">http://rogerdudler.github.io/git-guide/index.zh.html</a><br>常用 Git 命令清单 - <a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a><br>猴子都能懂的GIT入门 - <a href="http://backlogtool.com/git-guide/cn/" target="_blank" rel="noopener">http://backlogtool.com/git-guide/cn/</a><br>缪雪峰Git教程 - <a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a></p>]]></content>
    
    <summary type="html">
    
      增加了一些扩展内容，包括Java设计模式，JDBC的简单介绍，还有Linux和git的常用命令
    
    </summary>
    
      <category term="Java" scheme="https://barry215.github.io/categories/Java/"/>
    
    
      <category term="linux" scheme="https://barry215.github.io/tags/linux/"/>
    
      <category term="git" scheme="https://barry215.github.io/tags/git/"/>
    
      <category term="java" scheme="https://barry215.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java 进阶知识</title>
    <link href="https://barry215.github.io/2016/10/19/Java-advanced/"/>
    <id>https://barry215.github.io/2016/10/19/Java-advanced/</id>
    <published>2016-10-19T12:06:13.000Z</published>
    <updated>2017-11-17T00:48:51.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p><img src="Java-advanced/exception.jpg" alt="exception"></p><ul><li><p>Error</p><ul><li>是程序无法处理的错误，表示运行应用程序中较严重问题。</li><li>内存溢出可能是因为代码有死循环；静态变量过多；递归</li></ul></li><li><p>Exception</p><ul><li>是程序本身可以处理的异常。</li><li>Exception又包含了运行时异常(RuntimeException, 又叫非检查异常)和非运行时异常(又叫检查异常)</li><li>运行时异常都是RuntimeException类及其子类，这些异常是不检查的异常, 是在程序运行的时候可能会发生的, 所以程序可以捕捉, 也可以不捕捉。</li><li>检查异常是运行时异常以外的异常, 也是Exception及其子类, 这些异常从程序的角度来说是必须经过捕捉检查处理的, 否则不能通过编译。</li></ul><p><img src="Java-advanced/exception2.jpg" alt></p></li><li><p>java中的异常处理机制</p><ul><li><p>捕获异常</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    <span class="comment">// 可能会发生异常的程序代码  </span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Type1 id1)&#123;  </span><br><span class="line">    <span class="comment">// 捕获并处置try抛出的异常类型Type1  </span></span><br><span class="line">&#125;<span class="keyword">catch</span> (Type2 id2)&#123;  </span><br><span class="line">    <span class="comment">//捕获并处置try抛出的异常类型Type2  </span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>抛出异常</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">"这是一个异常"</span>);<span class="comment">//异常信息</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>示例</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">//业务逻辑代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(RuntimeException e)&#123; <span class="comment">//先catch子类错误</span></span><br><span class="line">  System.out.println(e.getMessage()); <span class="comment">//输出异常信息</span></span><br><span class="line">  e.printStackTrace(); <span class="comment">//把该异常的跟踪栈信息输出到控制台</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123; <span class="comment">//再catch父类错误</span></span><br><span class="line">  System.out.println(e.getMessage()); <span class="comment">//输出异常信息</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  <span class="comment">//一般做回收资源的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"><span class="comment">//出现IO错误就抛出，让上一级调用这个test方法的程序处理</span></span><br><span class="line">  <span class="comment">//如果已经是最顶层的程序，比如main方法，那异常就会交给JVM处理，他会打印错误，并且中止程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>自定义的异常</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(message);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">throws</span> MyException</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">"该值不能为0"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println( i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            Test test = <span class="keyword">new</span> Test();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                test.display(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>注意点</strong></p><ul><li>不要在finally块中处理返回值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">//因为finally中包含了return语句</span></span><br><span class="line">  <span class="comment">//所以return true失去作用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不要在构造函数中抛出异常。</li><li>尽可能的减小try块</li></ul></li></ul><h4 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try -with-resources"></a>try -with-resources</h4><p><code>try(){}</code>这个括号在JDK1.7之前是没有的，是1.7的新特性。</p><p>括号里的内容支持包括流以及任何可关闭的资源，数据流会在 try 执行完毕后自动被关闭，而不用我们手动关闭了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (FileReader reader = <span class="keyword">new</span> FileReader(<span class="string">"data.txt"</span>)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">catch</span> (IOException io) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p><strong>自定义泛型方法</strong></p><p>先写public void test1(T t)，由于java中要先声明后使用，所以要在方法前面加上<t> ，即是public <t> void test1(T t)</t></t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Geric</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">test1</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T,K&gt; <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">(T t,K k)</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自定义泛型类</strong></p><p>在类定义了泛型后就不用在方法中再定义了，但静态方法还是要先定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Geric</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">test1</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;K&gt; <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">(T t,K k)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,K,E&gt; <span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">(T t,K k,E e)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>泛型类</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原来的样子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Container</span></span>&#123;</span><br><span class="line">      <span class="keyword">private</span> String key;</span><br><span class="line">      <span class="keyword">private</span> String value;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Container</span><span class="params">(String k,String v)</span></span>&#123;</span><br><span class="line">                key=k;</span><br><span class="line">                value=v;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">getKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">             <span class="keyword">return</span> key;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> Stirng <span class="title">setKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">             <span class="keyword">this</span>.key=key;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">setValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.value=value;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用泛型来代替自己的变量类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Container</span>&lt;<span class="title">k</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> k key;</span><br><span class="line">        <span class="keyword">private</span> V value;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Container</span><span class="params">(K k,V v)</span></span>&#123;</span><br><span class="line">                key=k;</span><br><span class="line">                value=v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> K <span class="title">getkey</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">                  <span class="keyword">return</span> value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.key=key;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">              <span class="keyword">this</span>.value=value;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用例子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Container&lt;String,String&gt; c1=<span class="keyword">new</span> Container&lt;String ,String&gt;(<span class="string">"name"</span>,<span class="string">"hansheng"</span>);</span><br><span class="line">        Container&lt;String,Integer&gt; c2=<span class="keyword">new</span> Container&lt;String,Integer&gt;(<span class="string">"age"</span>,<span class="number">22</span>);</span><br><span class="line">        Container&lt;Double,Double&gt; c3=<span class="keyword">new</span> Container&lt;Double,Double&gt;(<span class="number">1.1</span>,<span class="number">1.3</span>);</span><br><span class="line">        System.out.println(c1.getKey() + <span class="string">" : "</span> + c1.getValue());      </span><br><span class="line">        System.out.println(c2.getKey() + <span class="string">" : "</span> + c2.getValue());</span><br><span class="line">        System.out.println(c3.getKey() + <span class="string">" : "</span> + c3.getValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">name : findingsea</span><br><span class="line">age : <span class="number">24</span></span><br><span class="line"><span class="number">1.1</span> : <span class="number">2.2</span></span><br></pre></td></tr></table></figure><ul><li><strong>泛型接口</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//然后定义这个生成器类来实现这个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">          <span class="keyword">private</span> String[] fruits=<span class="keyword">new</span> String[]&#123;<span class="string">"Apple"</span>,<span class="string">"Banana"</span>,<span class="string">"Pear"</span>&#125;;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    Ramdom rand=<span class="keyword">new</span> Random();</span><br><span class="line">                    <span class="keyword">return</span> fruits[rand.nextInt(<span class="number">3</span>)];</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>泛型方法</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">                System.out.println(t);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">              out(<span class="string">"hansheng"</span>);</span><br><span class="line">              out(<span class="number">123</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="comment">//不限个数的数组形式参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (T t : args) &#123;</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        out(<span class="string">"finding"</span>, <span class="number">123</span>, <span class="number">11.11</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>泛型接口使用方法</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Info</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InfoImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Info</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">private</span> T <span class="keyword">var</span>;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">InfoImpl</span><span class="params">(T <span class="keyword">var</span>)</span></span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.setVar(<span class="keyword">var</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(T <span class="keyword">var</span>)</span></span>&#123;</span><br><span class="line">                  <span class="keyword">this</span>.<span class="keyword">var</span>=<span class="keyword">var</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span></span>&#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span>;</span><br><span class="line">      &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args)</span></span>&#123;</span><br><span class="line">              Info&lt;String&gt; i=<span class="keyword">null</span>;</span><br><span class="line">              i=<span class="keyword">new</span> InfoImpl&lt;String&gt;(<span class="string">"hansheng"</span>);</span><br><span class="line">              System.out.println(<span class="string">"content"</span>+i.getVar());</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>类型判断</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class c1=<span class="keyword">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">Class c2=<span class="keyword">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class="line">System.out.println(c1==c2);</span><br><span class="line"><span class="comment">//返回true</span></span><br></pre></td></tr></table></figure><h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>&lt;? extends XXX&gt;<br>能获取，但是向上转型成XXX；不能插入，因为XXX的子类很多，不能确定你插入哪一种<br>&lt;? super XXX&gt;<br>能插入XXX或XXX的子类，但是存入时会向上转型成XXX；不能获取，因为XXX的父类很多，不知道获取的类型，但是如果用基类Object或者强制类型转换(XX)是可以获取的<br>&lt;?&gt;<br>一个无法确定的类型，不能获取，不能插入</p><h4 id="上边界限定通配符"><a href="#上边界限定通配符" class="headerlink" title="上边界限定通配符"></a>上边界限定通配符</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends Father&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//不能插入任何元素</span></span><br><span class="line"><span class="comment">//list1.add(new Child());</span></span><br><span class="line"><span class="comment">//list1.add(new Father());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以进行下面的赋值</span></span><br><span class="line">List&lt;Child&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list2.add(<span class="keyword">new</span> Child());</span><br><span class="line">List&lt;? extends Father&gt; list3 = list2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以取值，但是会被向上转型成Father</span></span><br><span class="line">Father father = list3.get(<span class="number">0</span>);</span><br><span class="line">Object object = list3.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="下边界限定通配符"><a href="#下边界限定通配符" class="headerlink" title="下边界限定通配符"></a>下边界限定通配符</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">super</span> Child&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//可以插入Child或Child的子类，插入时会被向上转型成Child</span></span><br><span class="line">list1.add(<span class="keyword">new</span> Child());</span><br><span class="line">list1.add(<span class="keyword">new</span> Baby());</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以进行下面的赋值</span></span><br><span class="line">List&lt;Father&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list2.add(<span class="keyword">new</span> Father());</span><br><span class="line">List&lt;? <span class="keyword">super</span> Child&gt; list3 = list2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以这样取值</span></span><br><span class="line">Child child = (Child)list1.get(<span class="number">0</span>);</span><br><span class="line">Father father = (Father)list1.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="边界通配符"><a href="#边界通配符" class="headerlink" title="边界通配符"></a>边界通配符</h4><p><code>List&lt;?&gt; list</code> 表示 <code>list</code> 是持有某种特定类型的 List，但是不知道具体是哪种类型。<br>因为并不知道实际是哪种类型，所以不能添加任何类型，这是不安全的。</p><p>和<code>List list</code>相比也就是没有传入泛型参数，表示这个 list 持有的元素的类型是 Object，因此可以添加任何类型的对象，只不过编译器会有警告信息。</p><p>参考：<br><a href="https://segmentfault.com/a/1190000005337789" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005337789</a><br><a href="http://www.jianshu.com/p/2005318f171f" target="_blank" rel="noopener">http://www.jianshu.com/p/2005318f171f</a></p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><ul><li><strong>通过实现Runable接口</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DisplayMessage</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String message;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">DisplayMessage</span><span class="params">(String message)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.message = message;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         System.out.println(message);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>通过继承Thread类本身</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuessANumber</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">GuessANumber</span><span class="params">(<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.number = number;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      System.out.println(number);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>测试</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadClassDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      Runnable hello = <span class="keyword">new</span> DisplayMessage(<span class="string">"Hello"</span>);</span><br><span class="line">     <span class="comment">//把接口传入线程，进行线程初始化</span></span><br><span class="line">      Thread thread1 = <span class="keyword">new</span> Thread(hello);</span><br><span class="line">     <span class="comment">//将该线程标记为守护线程或用户线程</span></span><br><span class="line">      thread1.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">     <span class="comment">//改变线程名称，使之与参数 name 相同</span></span><br><span class="line">      thread1.setName(<span class="string">"hello"</span>);</span><br><span class="line">     <span class="comment">//使该线程开始执行</span></span><br><span class="line">      thread1.start();</span><br><span class="line">     </span><br><span class="line">      Thread thread2 = <span class="keyword">new</span> GuessANumber(<span class="number">27</span>);</span><br><span class="line">      thread2.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IO处理"><a href="#IO处理" class="headerlink" title="IO处理"></a>IO处理</h3><p><img src="Java-advanced/IO.jpeg" alt="IO图"></p><ul><li><strong>字节和字符的关系</strong><ul><li>1个字节＝8位</li><li>1个字符＝2字节=16位</li><li>一个汉字是2字符，全角符号也2字符，半角就一个字符</li><li>byte 1字节</li><li>short 2字节</li><li>int 4字节</li><li>long 8字节</li><li>char 2字节(字符)</li><li>float 4字节</li><li>double 8字节</li></ul></li></ul><ul><li><p><strong>File类操作API</strong></p><ul><li><p>File实例可以是目录也可以是文件</p></li><li><p><strong>路径分隔符</strong></p><ul><li>windows下的路径分隔符是<code>\</code>，又因为<code>\</code>表示转义字符，所以需要两个<code>\</code>，如”C:\\a.txt”</li><li>Linux下的路径符是<code>/</code>，如/User/frank/document/b.txt</li></ul></li><li><p><strong>构造函数</strong></p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">         <span class="comment">//File(String pathName)</span></span><br><span class="line">         File f1 =<span class="keyword">new</span> File(<span class="string">"c:\\abc\\1.txt"</span>);</span><br><span class="line">         <span class="comment">//File(String parent,String child)</span></span><br><span class="line">         File f2 =<span class="keyword">new</span> File(<span class="string">"c:\\abc"</span>,<span class="string">"2.txt"</span>);</span><br><span class="line">         <span class="comment">//File(File parent,String child)</span></span><br><span class="line">         File f3 =<span class="keyword">new</span> File(<span class="string">"c:"</span>+File.separator+<span class="string">"abc"</span>);<span class="comment">//separator 跨平台分隔符，创建文件夹</span></span><br><span class="line">         File f4 =<span class="keyword">new</span> File(f3,<span class="string">"3.txt"</span>);</span><br><span class="line">         System.out.println(f1);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//输出：c:\abc\1.txt</span></span><br></pre></td></tr></table></figure></li><li><p><strong>创建方法</strong></p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">createNewFile</span><span class="params">()</span> <span class="comment">//不存在返回true 存在返回false</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">mkdir</span><span class="params">()</span> <span class="comment">//创建目录</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">mkdirs</span><span class="params">()</span> <span class="comment">//创建多级目录</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>删除方法</strong></p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">delete</span><span class="params">()</span> <span class="comment">//删除File对象对应的文件或路径</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">deleteOnExit</span><span class="params">()</span> <span class="comment">//当java虚拟机退出时，删除File对象对应的文件或路径</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>判断方法</strong></p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canExecute</span><span class="params">()</span> <span class="comment">//判断File对象对应的文件是否可执行</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canRead</span><span class="params">()</span> <span class="comment">//判断File对象对应的目录或文件是否可读</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canWrite</span><span class="params">()</span> <span class="comment">//判断File对象对应的目录或文件是否可写</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span> <span class="comment">//判断File对象对应的目录或文件是否存在</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDirectory</span><span class="params">()</span> <span class="comment">//判断File对象对应的是目录，不是文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span> <span class="comment">//判断File对象对应的是文件，不是目录</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isHidden</span><span class="params">()</span> <span class="comment">//判断File对象对应的文件是否隐藏</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAbsolute</span><span class="params">()</span> <span class="comment">//判断File对象对应的目录或文件是否是绝对路径</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>获取方法</strong></p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span> <span class="comment">//获取File对象对应的目录名或文件名</span></span></span><br><span class="line"><span class="function">String <span class="title">getPath</span><span class="params">()</span> <span class="comment">//获取File对象对应的路径名</span></span></span><br><span class="line"><span class="function">String <span class="title">getAbsolutePath</span><span class="params">()</span> <span class="comment">//获取File对象绝对路径</span></span></span><br><span class="line"><span class="function">String <span class="title">getParent</span><span class="params">()</span> <span class="comment">//获取File对象对应的父目录名，如果没有父目录返回null</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">lastModified</span><span class="params">()</span> <span class="comment">//获取文件最后一次修改的时间</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">length</span><span class="params">()</span> <span class="comment">//获取文件内容的长度</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">renameTo</span><span class="params">(File f)</span> <span class="comment">//重命名File对象对应的目录或文件，成功返回true</span></span></span><br><span class="line"><span class="function">File[] <span class="title">liseRoots</span><span class="params">()</span> <span class="comment">//获取系统的所有根路径</span></span></span><br><span class="line"><span class="function">String[] <span class="title">list</span><span class="params">()</span> <span class="comment">//获取File对象的所有子路径名或子文件名</span></span></span><br><span class="line"><span class="function">File[] <span class="title">listFiles</span><span class="params">()</span> <span class="comment">//获取File对象的所有子路径或子文件</span></span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>字符流和字节流的主要区别</strong></p><ul><li>字节流读取的时候，读到一个字节就返回一个字节；  字符流使用了字节流读到一个或多个字节（中文对应的字节数是两个，在UTF-8码表中是3个字节）时。先去查指定的编码表，将查到的字符返回。</li><li>字节流可以处理所有类型数据，如：图片，MP3，AVI视频文件，而字符流只能处理字符数据。只要是处理纯文本数据，就要优先考虑使用字符流，除此之外都用字节流</li></ul></li><li><p><strong>输入和输出</strong></p><ul><li>输入(InputStream)是指从文件输入到内存（程序），输出(OutputStream)是指从内存（程序）输出到文件</li></ul></li><li><p><strong>字节流</strong></p><ul><li><p><strong>方法</strong></p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;InputStream&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="comment">//从输入流中读取单个字节</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b)</span> <span class="comment">//从输入流中最多读取b.length个字节的数据，并将其储存在字节数组b中，返回实际读取的字节数</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="comment">//从输入流中最多读取len个字节，并将其储存在字节数组b中，并不是从数组起点开始，而是从off位置开始，返回实际读取的字节数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&lt;OutputStream&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span> <span class="comment">//将指定的字节输出到输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] buf)</span> <span class="comment">//将字节数组中的数据输出到指定的输出流中</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] buf,<span class="keyword">int</span> off,<span class="keyword">int</span> len)</span> <span class="comment">//将字节数组中从off位置开始，长度为len的数据输出到指定的输出流中</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用字节流读数据</strong></p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadByteStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>; <span class="comment">// 声明文件输入流对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(<span class="string">"test.txt"</span>); <span class="comment">// test.txt文件在当前工程目录下事先创建好</span></span><br><span class="line">            <span class="keyword">byte</span> input[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">30</span>];</span><br><span class="line">            fis.read(input); <span class="comment">// 读入到一个字节数组</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">//转化到字符串str中</span></span><br><span class="line">            String str = <span class="keyword">new</span> String(input, <span class="string">"UTF-8"</span>); <span class="comment">// 字符编码要与读入的文件对应</span></span><br><span class="line">            System.out.println(str);</span><br><span class="line">          </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close(); <span class="comment">// 关闭输入流</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用字节流写数据</strong></p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteByteStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//里面true参数表示不覆盖原文件，直接在文件后面追加添加内容</span></span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"test2.txt"</span>,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            String str = <span class="string">"1234567"</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] outStr = str.getBytes(<span class="string">"UTF-8"</span>); <span class="comment">// 读入字节数组，并指定编码方式</span></span><br><span class="line">            fos.write(outStr); <span class="comment">// 使用文件输出流写出到文件</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用字节流拷贝文件</strong></p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyFile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(<span class="string">"test.png"</span>);</span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"test_new.png"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span> input[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">50</span>]; <span class="comment">// 每次读取50 bytes</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (fis.read(input) != -<span class="number">1</span>) &#123; <span class="comment">// read返回读入的数据大小，如果没有数据返回-1</span></span><br><span class="line">                fos.write(input); <span class="comment">// 每次写入50 bytes</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"done"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用带缓冲的字节流读写数据</strong></p><ul><li>不带缓冲的操作, 每读一个字节就要写入一个字节, 由于涉及磁盘的IO操作相比内存的操作要慢很多, 所以不带缓冲的流效率很低  </li><li>带缓冲的流, 可以一次读很多字节, 但不向磁盘中写入, 只是先放到内存里. 等凑够了缓冲区大小的时候一次性写入磁盘, 这种方式可以减少磁盘操作次数, 速度就会提高很多!  </li><li>带缓冲的流适合读写比较大的文件</li></ul></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadByBufferedByteStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"movie.mp4"</span>);</span><br><span class="line">          <span class="comment">// 缓冲区大小1000000字节</span></span><br><span class="line">            BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis,<span class="number">1000000</span>); </span><br><span class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"moive_new.mp4"</span>);</span><br><span class="line">            BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fos,<span class="number">1000000</span>); </span><br><span class="line">          </span><br><span class="line">            <span class="comment">//大型文件对应的数组可以大一些，小文件对应的数组小一些</span></span><br><span class="line">            <span class="keyword">byte</span> input[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100000</span>]; </span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> before = System.currentTimeMillis(); <span class="comment">// 开始计时</span></span><br><span class="line">            <span class="keyword">while</span> (bis.read(input) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(input);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            bos.flush();</span><br><span class="line">            bis.close();</span><br><span class="line">            fis.close();</span><br><span class="line">            bos.close();</span><br><span class="line">            fos.close();</span><br><span class="line">            System.out.println(System.currentTimeMillis()-before+<span class="string">"ms"</span>); <span class="comment">// 总时长</span></span><br><span class="line">            System.out.println(<span class="string">"读取了："</span>+count+<span class="string">"次"</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>字符流</strong></p><ul><li><p><strong>方法</strong></p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;Reader&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="comment">//从输入流中读取单个字符</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] cbuf)</span> <span class="comment">//从输入流中最多读取cbuf.length个字符的数据，并将其储存在字符数组cbuf中，返回实际读取的字符数</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] cbuf, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="comment">//从输入流中最多读取len个字符，并将其储存在字符数组cbuf中，并不是从数组起点开始，而是从off位置开始，返回实际读取的字符数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&lt;Writer&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span> <span class="comment">//将指定的字符输出到输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] buf)</span> <span class="comment">//将字符数组中的数据输出到指定的输出流中</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] buf,<span class="keyword">int</span> off,<span class="keyword">int</span> len)</span> <span class="comment">//将字符数组中从off位置开始，长度为len的数据输出到指定的输出流</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//因为字符流直接以字符作为操作单位，所以Writer可以用字符串来代替字符数组</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String str)</span> <span class="comment">//将str字符串中包含的字符输出到输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String str,<span class="keyword">int</span> off,<span class="keyword">int</span> len)</span> <span class="comment">//将str字符串中从off位置开始，长度为len的数据输出到指定的输出流</span></span></span><br><span class="line"><span class="function"><span class="comment">//因为字符流直接以字符作为操作单位，所以Writer可以用字符串来代替字符数组</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用字符流读写数据</strong></p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RWByCharStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"java.txt"</span>);</span><br><span class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"java_new.txt"</span>);</span><br><span class="line">          <span class="comment">// 字符流的使用要传入字节流作为参数</span></span><br><span class="line">            InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(fis, <span class="string">"UTF-8"</span>); </span><br><span class="line">            OutputStreamWriter writer = <span class="keyword">new</span> OutputStreamWriter(fos, <span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">char</span> input[] = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>]; <span class="comment">// 每次读取的数据大小</span></span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((l = reader.read(input)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// void write(char cbuf[], int off, int len)</span></span><br><span class="line">                <span class="comment">// 文件末尾的长度不一定是100，所以需要设置写入数据长度</span></span><br><span class="line">                writer.write(input, <span class="number">0</span>, l);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            reader.close(); <span class="comment">// 先关闭字符流</span></span><br><span class="line">            fis.close(); <span class="comment">// 再关闭字节流</span></span><br><span class="line">            writer.close();</span><br><span class="line">            fos.close();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"done"</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用带缓冲的字符流读写数据</strong></p><ul><li>使用字符流读取数据时不能按行读取，这时候就需要使用带有缓冲区的字符流。</li></ul></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.Writer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RWByBufferedCharStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"java.txt"</span>);</span><br><span class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"java_new_buff.txt"</span>);</span><br><span class="line"></span><br><span class="line">            InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(fis, <span class="string">"UTF-8"</span>);</span><br><span class="line">            OutputStreamWriter writer = <span class="keyword">new</span> OutputStreamWriter(fos, <span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">            BufferedReader br = <span class="keyword">new</span> BufferedReader(reader);</span><br><span class="line">            <span class="comment">// BufferedWriter bw = new BufferedWriter(writer);</span></span><br><span class="line">            <span class="comment">// PrintWriter和BufferedWriter用法类似</span></span><br><span class="line">            <span class="comment">// PrintWriter可以输出换行符</span></span><br><span class="line">            <span class="comment">// 构造方法PrintWriter(Writer out,boolean autoFlush) 里可以设置缓冲区自动输出，这样就不需要手动调用flush方法了。</span></span><br><span class="line">            PrintWriter pw = <span class="keyword">new</span> PrintWriter(writer, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            String input;</span><br><span class="line">            <span class="keyword">while</span> ((input = br.readLine()) != <span class="keyword">null</span>) &#123; <span class="comment">// BufferedReader可以按行读取</span></span><br><span class="line">                <span class="comment">// bw.write(input); //</span></span><br><span class="line">                <span class="comment">// BufferedWriter的writer方法是带有缓冲区的，此时打印的文本是不带换行符的</span></span><br><span class="line">                pw.println(input);<span class="comment">// PrintWriter的println方法支持不同平台的换行符输出</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// bw.flush(); // 强制输出缓冲区内容。如果不加上flush，最后的缓冲区未读满将不输出内容</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// bw.close();</span></span><br><span class="line">            pw.close();<span class="comment">// 按顺序关闭流</span></span><br><span class="line">            writer.close();</span><br><span class="line">            fos.close();</span><br><span class="line"></span><br><span class="line">            br.close();</span><br><span class="line">            reader.close();</span><br><span class="line">            fis.close();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"done"</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>FileReader 和FileWriter</strong></p><ul><li>FileReader 和FileWriter 专门用于操作文本文件. 用法与FileInputStream 类似</li></ul></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileRW</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        FileReader fr = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">        FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">        BufferedWriter bw = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fr = <span class="keyword">new</span> FileReader(<span class="string">"java.txt"</span>);</span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">            fw = <span class="keyword">new</span> FileWriter(<span class="string">"java_new.txt"</span>);</span><br><span class="line">            bw = <span class="keyword">new</span> BufferedWriter(fw);</span><br><span class="line"></span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                bw.write(line + <span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            bw.flush();</span><br><span class="line">            System.out.println(<span class="string">"done"</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bw.close();</span><br><span class="line">                fw.close();</span><br><span class="line">                br.close();</span><br><span class="line">                fr.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>相互转化</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用字节流读取文件，再转成字符流</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestIO</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\abc.txt"</span>);<span class="comment">// 字节流</span></span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis);<span class="comment">// 字符流</span></span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);<span class="comment">// 缓冲流</span></span><br><span class="line">  String str = <span class="keyword">null</span>;</span><br><span class="line"> <span class="keyword">if</span> ((str = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">    br.close();</span><br><span class="line">    isr.close();</span><br><span class="line">    fis.close();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有字符流转字节流，因为实际开发用不到，所有相关API也没有了</span></span><br><span class="line"><span class="comment">//直接字符流读取文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestIO</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"c:\\abc.txt"</span>);<span class="comment">// 字符流</span></span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(fr);<span class="comment">// 缓冲流</span></span><br><span class="line">    String str = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> ((str = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">    fr.close();</span><br><span class="line">    br.close();</span><br><span class="line">  ｝</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><h3 id="Java-Nio"><a href="#Java-Nio" class="headerlink" title="Java Nio"></a>Java Nio</h3><h4 id="阻塞和非阻塞（都是同步）"><a href="#阻塞和非阻塞（都是同步）" class="headerlink" title="阻塞和非阻塞（都是同步）"></a>阻塞和非阻塞（都是同步）</h4><p>阻塞是询问后阻塞到有结果再返回<br>非阻塞询问后没结果则返回不等待</p><h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h4><p>同步是从上到下地顺序运行<br>异步是分一个任务，在有空的时候执行，返回结果的时候通知主任务<br>区别：<br>同步是主动地执行，异步是被动地执行</p><h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>Channel国内大多翻译成“通道”。Channel和IO中的Stream(流)是差不多一个等级的。只不过Stream是单向的，譬如：InputStream, OutputStream。而Channel是双向的，既可以用来进行读操作，又可以用来进行写操作，NIO中的Channel的主要实现有：FileChannel、DatagramChannel、SocketChannel、ServerSocketChannel；通过看名字就可以猜出个所以然来：分别可以对应文件IO、UDP和TCP（Server和Client）。</p><h4 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h4><p>NIO中的关键Buffer实现有：ByteBuffer、CharBuffer、DoubleBuffer、 FloatBuffer、IntBuffer、 LongBuffer,、ShortBuffer，分别对应基本数据类型: byte、char、double、 float、int、 long、 short。当然NIO中还有MappedByteBuffer, HeapByteBuffer, DirectByteBuffer等这里先不具体陈述其用法细节。</p><h4 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h4><p>Selector 是NIO相对于BIO实现多路复用的基础，Selector 运行单线程处理多个 Channel，如果你的应用打开了多个通道，但每个连接的流量都很低，使用 Selector 就会很方便。例如在一个聊天服务器中。要使用 Selector , 得向 Selector 注册 Channel，然后调用它的 select() 方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新的连接进来、数据接收等。</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzIzMzgxOTQ5NA==&amp;mid=2247483922&amp;idx=1&amp;sn=c9fdc5cd64df5a412b9dc2fc6f9e4880&amp;chksm=e8fe9e1bdf89170d9f0d08dc0320b15238869dd6c8b9496d82b1af75d0ddc102327438029a89&amp;mpshare=1&amp;scene=23&amp;srcid=0807O7xIaN4cSgfRHLv4ZWgq#rd" target="_blank" rel="noopener">Java nio介绍看这篇就够了</a></p><h3 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h3><ul><li><strong>准备</strong><ul><li>要使用Java的邮箱功能需要javax.mail这个jar包</li></ul></li><li><strong>SMTP</strong><ul><li>简单邮件传输协议</li></ul></li><li><strong>POP3</strong><ul><li>邮局协议</li></ul></li><li><strong>最简单的邮件传输</strong><ul><li>不包附件，只有正文部分，并且只是负责邮件的发送，因此只需要SMTP，当要读取邮件的时候就必须要使用POP3</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendEmail</span><span class="params">()</span></span>&#123;    </span><br><span class="line">String FROM = <span class="string">"3427545623@163.com"</span>;<span class="comment">//发件人的email</span></span><br><span class="line">    String PWD = <span class="string">"***********"</span>;<span class="comment">//发件人授权码(不同于密码)，开通SMTP服务后会需要设置授权码</span></span><br><span class="line"></span><br><span class="line">String HOST = <span class="string">"smtp.163.com"</span>;<span class="comment">//设置邮件服务主机，每个服务商的邮件服务器地址都不一样</span></span><br><span class="line">    String PROTOCOL = <span class="string">"smtp"</span>;<span class="comment">//传输协议</span></span><br><span class="line">    <span class="keyword">int</span> PORT = <span class="number">25</span>;<span class="comment">//端口号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Properties类用于保存邮箱环境的属性</span></span><br><span class="line">    Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">    props.put(<span class="string">"mail.smtp.host"</span>, HOST);<span class="comment">//设置服务器地址</span></span><br><span class="line">    props.put(<span class="string">"mail.store.protocol"</span> , PROTOCOL);<span class="comment">//设置协议</span></span><br><span class="line">props.put(<span class="string">"mail.smtp.port"</span>, PORT);<span class="comment">//设置端口</span></span><br><span class="line">    props.put(<span class="string">"mail.smtp.auth"</span>, <span class="keyword">true</span>);<span class="comment">//表示SMTP发送邮件，必须进行身份验证</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//发送者的邮箱地址和口令也可以在这里设置，之后也可以拿出</span></span><br><span class="line">    <span class="comment">//props.put("mail.user", "3427545623@163.com");//此处填写你的账号</span></span><br><span class="line">    <span class="comment">//props.put("mail.password", "***********");// 发件人授权码,也就是STMP口令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化Authenticator这个抽象类，这里重写getPasswordAuthentication方法</span></span><br><span class="line">    Authenticator authenticator = <span class="keyword">new</span> Authenticator() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> PasswordAuthentication <span class="title">getPasswordAuthentication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">//传入发送者邮箱和密码</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PasswordAuthentication(FROM, PWD);</span><br><span class="line">          <span class="comment">//从环境属性中拿出</span></span><br><span class="line">          <span class="comment">//String userName = props.getProperty("mail.user");</span></span><br><span class="line">          <span class="comment">//String password = props.getProperty("mail.password");</span></span><br><span class="line">          <span class="comment">//return new PasswordAuthentication(userName, password);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用环境属性和授权信息，创建邮件会话</span></span><br><span class="line">Session session = Session.getDefaultInstance(props,authenticator);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//传入邮件会话来构造邮件信息对象</span></span><br><span class="line">Message msg = <span class="keyword">new</span> MimeMessage(session);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置Message属性</span></span><br><span class="line">        msg.setFrom(<span class="keyword">new</span> InternetAddress(FROM));<span class="comment">//设置发送者</span></span><br><span class="line">        InternetAddress address = <span class="keyword">new</span> InternetAddress(<span class="string">"593571421@qq.com"</span>);<span class="comment">//获取收件人邮箱的网络地址</span></span><br><span class="line">        msg.setRecipients(Message.RecipientType.TO, address);<span class="comment">//设置收件人的地址</span></span><br><span class="line">        msg.setSubject(<span class="string">"账号激活邮件"</span>);<span class="comment">//设置邮件标题</span></span><br><span class="line">        msg.setSentDate(<span class="keyword">new</span> Date());<span class="comment">//设置发送时间</span></span><br><span class="line">        msg.setContent(<span class="string">"send successfully!"</span>,<span class="string">"text/html;charset=utf-8"</span>);<span class="comment">//设置邮件的内容体和内容格式</span></span><br><span class="line"></span><br><span class="line">        Transport.send(msg);<span class="comment">//发送邮件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(MessagingException mex) &#123;</span><br><span class="line">        mex.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h3><ul><li><a href="http://www.imooc.com/learn/283" target="_blank" rel="noopener">生成验证码</a></li><li><a href="http://www.imooc.com/learn/585" target="_blank" rel="noopener">生成图片验证码</a></li></ul><h3 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h3><ul><li><a href="http://www.imooc.com/learn/531" target="_blank" rel="noopener">java生成二维码</a></li></ul><h3 id="Excel导入导出"><a href="#Excel导入导出" class="headerlink" title="Excel导入导出"></a>Excel导入导出</h3><ul><li><a href="http://www.imooc.com/learn/354" target="_blank" rel="noopener">学习资料</a></li></ul><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><ul><li><p>当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过<strong>加载</strong>，<strong>连接</strong>，<strong>初始化</strong>三步来实现对这个类进行初始化。</p></li><li><p><strong>加载</strong></p><ul><li>通过一个类的全限定名来获取其定义的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在Java堆中生成一个代表这个类的java.lang.Class对象</li></ul></li><li><p><strong>连接</strong></p><ul><li><code>验证</code> 为了确保class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</li><li><code>准备</code> 负责为类的静态成员分配内存，并设置默认初始化值</li><li><code>解析</code> 虚拟机将常量池中的符号引用替换为直接引用</li></ul></li><li><p><strong>初始化</strong></p><ul><li>创建类的实例</li><li>访问类的静态变量，或者为静态变量赋值</li><li>调用类的静态方法</li><li>使用反射方式来强制创建某个类或接口对应的<code>java.lang.Class</code>对象</li><li>初始化某个类的子类</li><li>直接使用java.exe命令来运行某个主类</li><li>初始化注意点<ul><li>如果类存在直接父类的话，且直接父类还没有被初始化，则先初始化其直接父类</li><li>如果类存在一个初始化方法，就执行此方法</li><li>初始化接口并不需要初始化它的父接口。</li></ul></li></ul></li></ul><h4 id="类什么时候初始化"><a href="#类什么时候初始化" class="headerlink" title="类什么时候初始化"></a>类什么时候初始化</h4><p>加载完类后，类的初始化就会发生，意味着它会初始化所有类静态成员，以下情况一个类被初始化：</p><ul><li>实例通过使用new()关键字创建或者使用class.forName()反射，但它有可能导致ClassNotFoundException。</li><li>类的静态方法被调用</li><li>类的静态域被赋值</li><li>静态域被访问，而且它不是常量</li><li>在顶层类中执行assert语句</li></ul><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><ul><li><p>负责将<code>.class</code>文件加载到内存中，并为之生成对应的Class对象。</p><p>虽然我们不需要关心类加载机制，但是了解这个机制我们就能更好的理解程序的运行。</p><ul><li>Bootstrap ClassLoader 根类加载器<ul><li>负责加载存放在JDK\jre\lib（JAVA_HOME/lib）的类库</li></ul></li><li>Extension ClassLoader 扩展类加载器<ul><li>负责加载存放在JAVA_HOME/lib/ext下的类库</li></ul></li><li>Application ClassLoader 系统类加载器<ul><li>负责加载用户类路径（ClassPath）所指定的类</li></ul></li></ul></li></ul><ul><li><strong>示例</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> kevin.demo;  </span><br><span class="line">   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> a;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c = <span class="number">1</span>;  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">       b=<span class="number">2</span>;  </span><br><span class="line">       c = <span class="number">3</span>;  </span><br><span class="line">       System.out.println(<span class="string">"Base:static init block invoked.."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">       System.out.println(<span class="string">"Base:a="</span> + a + <span class="string">",b="</span> + b + <span class="string">",c="</span> + c);  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> d;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> e = <span class="number">4</span>;  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">       e= <span class="number">5</span>;  </span><br><span class="line">       System.out.println(<span class="string">"Derived:static init block invoked..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">super</span>.display();  </span><br><span class="line">       System.out.println(<span class="string">"Derived:d="</span> + d + <span class="string">",e="</span> + e);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">new</span> Derived().display();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">结果：</span><br><span class="line">Base:<span class="keyword">static</span> init block invoked..</span><br><span class="line">Derived:<span class="keyword">static</span> init block invoked...</span><br><span class="line">Base:a=<span class="number">0</span>,b=<span class="number">2</span>,c=<span class="number">3</span></span><br><span class="line">Derived:d=<span class="number">0</span>,e=<span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>JVM类加载机制</strong></p><ul><li>全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li><li>父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li><li>缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</li></ul><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p><h4 id="JMM内存模型"><a href="#JMM内存模型" class="headerlink" title="JMM内存模型"></a>JMM内存模型</h4><p><img src="Java-advanced/jmm.png" alt><br>JMM规定了所有的变量都存储在主内存（Main Memory）中。每个线程还有自己的工作内存（Working Memory）,线程的工作内存中保存了该线程使用到的变量的主内存的副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量（volatile变量仍然有工作内存的拷贝，但是由于它特殊的操作顺序性规定，所以看起来如同直接在主内存中读写访问一般）。不同的线程之间也无法直接访问对方工作内存中的变量，线程之间值的传递都需要通过主内存来完成。</p><h4 id="JVM的内存结构"><a href="#JVM的内存结构" class="headerlink" title="JVM的内存结构"></a>JVM的内存结构</h4><p>JVM的内存一共分为5个部分:</p><ol><li><code>程序计数器</code>: 程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器，因为cpu调度线程是轮流切换的，所以每个线程需要程序计数器来记录下一个字节码指令的地址，来恢复到正确的执行位置</li><li><code>方法区</code>: 方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，也存放着常量池。</li><li><code>虚拟机栈</code>: Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</li><li><code>本地方法栈</code>: 本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务</li><li><code>堆</code>: Java堆是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</li></ol><p>JVM堆内存被分为两部分年轻代(Young Generation)和老年代(Old Generation)</p><p><img src="Java-advanced/jvm.png" alt></p><h5 id="新生代-Young"><a href="#新生代-Young" class="headerlink" title="新生代(Young)"></a>新生代(Young)</h5><p>新生代是所有新对象产生的地方。当年轻代的内存空间被用完时，就会触发垃圾回收。这个垃圾回收叫做Minor GC。新生代分为3个部分Eden区和Survivor区(FromSpace和ToSpace,两个区域大小相同，大小8:1:1)，新生代的大小可以通过-Xmn来控制，也可以用-XX：SurvivorRatio来控制Eden和Survivor的比例。</p><p>特点</p><p>大多数新建的对象都在Eden区</p><p>当Eden区域被填满时，就会执行Minor GC。并把所有存活下来的对象转移到其中一个survivor区</p><p>Minor GC同样会检查存活下来的对象，并把他们转移到另一个survivor区。这样在一段时间内，总会有一个空的survivor区</p><p>经过多次GC周期后，仍然存活下来的对象会被转移到老年代内存空间。通常这是在新生代有资格提升到老年代前通过设定年龄阈值来完成的。</p><h5 id="老年代-Tenured"><a href="#老年代-Tenured" class="headerlink" title="老年代(Tenured)"></a>老年代(Tenured)</h5><p>老年代内存里包含了长期存活的对象和经过多次Minor GC后依然存活下来的对象。通常会在老年代内存被占满时进行垃圾回收。老年代的垃圾收集叫做Major GC。Major GC会花费更多的时间。旧生带占用大小为-Xmx值减去-Xmn对应的值</p><h5 id="永久代-Perm"><a href="#永久代-Perm" class="headerlink" title="永久代(Perm)"></a>永久代(Perm)</h5><p>永久代包含了JVM需要的应用元数据，这些元数据描述了在应用里使用的类和方法。注意，永久代不是Java堆内存的一部分，有一些JVM没有这一代，主要存放敞亮及类的一些信息，默认最小值为16MB，最大值为64MB，可以通过<code>-XX:PermSize</code>及<code>-XX:MaxPermSize</code>来设置最小值和最大值。</p><p>永久代存放JVM运行时使用的类。永久代同样包含了Java SE库的类和方法。永久代的对象在full GC时进行垃圾收集。</p><blockquote><p>以上对象的年轻代和年老代都是指的JVM的Heap空间，而持久代则是之前提到的方法区，不属于堆。</p></blockquote><h4 id="元空间-metaspace"><a href="#元空间-metaspace" class="headerlink" title="元空间(metaspace)"></a>元空间(metaspace)</h4><p>现今JDK8中PermGen(永久代)已经被彻底移除，取而代之的是metaspace数据区，使用native内存，申请和释放由虚拟机负责管理。</p><p>在JDK8下，旧的参数-XX:PermSize和-XX:MaxPermSize会被忽略并显示警告。新的Metaspace通过参数-XX:MetaspaceSize 和-XX:MaxMetaspaceSize设定。</p><h4 id="内存泄露和内存溢出的区别"><a href="#内存泄露和内存溢出的区别" class="headerlink" title="内存泄露和内存溢出的区别"></a>内存泄露和内存溢出的区别</h4><blockquote><p>泄漏强调无法收回，占用内存；溢出强调不够，无法满足</p></blockquote><ul><li>内存泄露：指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。<br>或【内存中存在可达、无用的对象，且不会被GC回收，一直占用着内存。<br>该对象就是内存泄漏的对象 】</li><li>内存溢出：指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。<br>jvm 何时抛出OutOfMemoryException：并不是内存被耗空的时候才抛出<br>1）JVM98%的时间都花费在内存回收<br>2）每次回收的内存小于2%</li></ul><h4 id="垃圾收集器-统称"><a href="#垃圾收集器-统称" class="headerlink" title="垃圾收集器(统称)"></a>垃圾收集器(统称)</h4><h5 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h5><p>一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发minor GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。</p><h5 id="Full-GC-Major-GC"><a href="#Full-GC-Major-GC" class="headerlink" title="Full GC(Major GC)"></a>Full GC(Major GC)</h5><p>对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个对进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC：</p><ul><li>年老代（Tenured）被写满</li><li>持久代（Perm）被写满</li><li>System.gc()被显示调用</li></ul><h4 id="垃圾收集器-分类"><a href="#垃圾收集器-分类" class="headerlink" title="垃圾收集器(分类)"></a>垃圾收集器(分类)</h4><h5 id="Serial-GC"><a href="#Serial-GC" class="headerlink" title="Serial GC"></a>Serial GC</h5><p>Serial是年轻代的单线程GC，GC算法是复制算法</p><h5 id="Serial-old-GC"><a href="#Serial-old-GC" class="headerlink" title="Serial old GC"></a>Serial old GC</h5><p>Serial old是老年代的单线程GC，GC算法是标记-整理算法</p><h5 id="Parnew-GC"><a href="#Parnew-GC" class="headerlink" title="Parnew GC"></a>Parnew GC</h5><p>Parnew是年轻代的多线程GC，GC算法是复制算法</p><h5 id="Parallel-Scavenge-GC"><a href="#Parallel-Scavenge-GC" class="headerlink" title="Parallel Scavenge GC"></a>Parallel Scavenge GC</h5><p>Parallel Scavenge是年轻代的多线程GC，GC算法是复制算法<br>优点：最优化吞吐量</p><blockquote><p>吞吐量 = 用户代码执行时间占cpu所有时间的比率</p></blockquote><h5 id="Parallel-old-GC"><a href="#Parallel-old-GC" class="headerlink" title="Parallel old GC"></a>Parallel old GC</h5><p>Parallel old是老年代的多线程GC，GC算法是标记-整理算法</p><h5 id="CMS（concurrent-mark-sweep）-GC"><a href="#CMS（concurrent-mark-sweep）-GC" class="headerlink" title="CMS（concurrent mark sweep） GC"></a>CMS（concurrent mark sweep） GC</h5><p>CMS是老年代的多线程GC，GC算法是标记-清除算法<br>优点：用户线程和GC线程并发同时运行<br>缺点：清除之后空间碎片太多</p><p><img src="Java-advanced/cms.jpg" alt></p><h5 id="G1-garbage-first-GC"><a href="#G1-garbage-first-GC" class="headerlink" title="G1(garbage first) GC"></a>G1(garbage first) GC</h5><p>G1是管理整个GC堆的多线程GC，它把java堆分成多个大小相等的region独立区域，GC算法是类似标记整理的算法<br>优点：并行和并发</p><h4 id="垃圾回收GC算法"><a href="#垃圾回收GC算法" class="headerlink" title="垃圾回收GC算法"></a>垃圾回收GC算法</h4><ol><li>引用计数算法:</li></ol><blockquote><p>该算法对每一个对象都有一个引用计数，没增加一次引用就+1，减少一次引用-1，在回收时将引用计数为0的对象清理掉。这种算法简单，但是无法解决循环引用的问题(比如: A引用B， B也引用A，但是A和B都没有被其它任何对象引用)。</p></blockquote><ol start="2"><li>标记-清除算法:</li></ol><blockquote><p>该算法分为两个阶段， 第一阶段遍历找出所有需要被回收的对象，并做上标记，第二阶段对清理所有被标记的对象，这种算法效率比较低，并且会产生较多的内存碎片。</p></blockquote><ol start="3"><li>标记-整理(压缩)算法:</li></ol><blockquote><p>该算法的第一阶段和标记-清除算法是一样的，而第二阶段它不是直接清理掉垃圾对象，而且将存活的对象往同一侧移动，移动完成后清理掉另一侧所有的对象。这种算法不会产生内存碎片，但是效率低下。</p></blockquote><ol start="4"><li>复制算法:</li></ol><blockquote><p>该算法将内存分为两个区域，进行垃圾回收时，就将还活着的对象复制到另一块内存区域中，然后再将整片内存区域清空。这种算法简单快速，而且不会产生内存碎片，但是因为将内存分成两块，所以可用的内存会少很多。</p></blockquote><ol start="5"><li>分代收集算法:</li></ol><blockquote><p>将内存细分为多个区域，不同区域GC的频率，并对不同的区域采用适当的收集算法。如JVM将内存分为年轻代和老年代，普通对象最开始分配在年轻代(大对象会直接分配到老年代)，同一个对象在经过几次GC后还存活着，就认为这个对象的生命周期会比较长，将其移入老年代，GC主要发生在年轻代。</p></blockquote><h4 id="GC工作机制"><a href="#GC工作机制" class="headerlink" title="GC工作机制"></a>GC工作机制</h4><p>1.新生代有一个Eden区和两个survivor区，首先将对象放入Eden区，如果空间不足就向其中的一个survivor区上放，如果仍然放不下就会引发一次发生在新生代的minor GC，将存活的对象放入另一个survivor区中，然后清空Eden和之前的那个survivor区的内存。在某次GC过程中，如果发现仍然又放不下的对象，就将这些对象放入老年代内存里去。</p><p>2.大对象以及长期存活的对象直接进入老年区。</p><p>3.当每次执行minor GC的时候应该对要晋升到老年代的对象进行分析，如果这些马上要到老年区的老年对象的大小超过了老年区的剩余大小，那么执行一次Full GC以尽可能地获得老年区的空间。</p><h4 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h4><p>针对的对象：从GC Roots搜索不到，而且经过一次标记清理之后仍没有复活的对象。<br>当一个对象到 GC Roots 没有任何引用链相接的时候，那么这个对象就是不可达，就可以被回收。</p><h4 id="不可达不一定会死"><a href="#不可达不一定会死" class="headerlink" title="不可达不一定会死"></a>不可达不一定会死</h4><p>即使在可达性分析算法中不可达的对象,也并非是“非死不可”的,这时候它们暂时处于“缓刑”阶段,要真正宣告一个对象死亡,至少要经历两次标记过程:<br>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链,那它将会被第一次标记并且进行一次筛选,筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法,或者finalize()方法已经被虚拟机调用过,虚拟机将这两种情况都视为“没有必要执行”。(即意味着直接回收)</p><h4 id="各区GC算法策略"><a href="#各区GC算法策略" class="headerlink" title="各区GC算法策略"></a>各区GC算法策略</h4><p>新生代：复制清理； 老年代：标记-清除或标记-整理算法； 永久代：存放Java中的类和加载类的类加载器本身。</p><h4 id="什么时候发生GC"><a href="#什么时候发生GC" class="headerlink" title="什么时候发生GC"></a>什么时候发生GC</h4><p>eden区放不下新生的对象时，发生minor gc，如果在发生minor gc之前，虚拟机检查老年代的最大可用的连续空间小于新生代所有对象的总空间，则需要担保策略。如果担保，则计算新生代对象晋升的平均空间，如果够用，则冒风险试一次，如果不够用就要发生一次fullgc。除了CMS的concurrent collection之外,年轻代和老年代都会被收集。</p><h4 id="什么时候转向老年区"><a href="#什么时候转向老年区" class="headerlink" title="什么时候转向老年区"></a>什么时候转向老年区</h4><ul><li>对象优先在eden区分配，eden区的gc之后对象年龄就加1，到15岁之后就转老年代</li><li>大对象会直接转向老年代</li><li>如果eden区的survivor区放不下对象时也会转向老年代</li></ul><h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h4><p>finalize是在垃圾收集器删除对象之前对这个对象调用的，如果对象没有在这个方法里进行自救，那只能被回收，但是一个对象的finalize()方法只会被系统自动调用一次</p><h4 id="减少GC开销"><a href="#减少GC开销" class="headerlink" title="减少GC开销"></a>减少GC开销</h4><ol><li>不要显式调用System.gc()</li><li>尽量减少临时对象的使用</li><li>尽量使用StringBuffer,而不用String来累加字符串</li><li>尽量少用静态对象变量</li></ol><h4 id="速学路径"><a href="#速学路径" class="headerlink" title="速学路径"></a>速学路径</h4><p><a href="http://icyfenix.iteye.com/blog/715301" target="_blank" rel="noopener">GC 什么时候对什么东西做什么</a></p><p><a href="http://www.importnew.com/23792.html" target="_blank" rel="noopener">jvm 知识大全</a></p><p><a href="http://www.jianshu.com/p/778dd3848196" target="_blank" rel="noopener">Java垃圾回收机制</a></p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><ul><li><p><strong>动态语言</strong></p><ul><li>Python，Ruby是动态语言，C++，Java，C#不是动态语言。但是JAVA有着一个非常突出的动态相关机制：Reflection(反射)，用在Java身上指的是我们可以于运行时加载、探知、使用编译期间完全未知的classes。换句话说，Java程序可以加载一个运行时才得知名称的class，获悉其完整构造（但不包括methods定义），并生成其对象实体、或对其fields设值、或唤起其methods。</li></ul></li><li><p><strong>概念</strong></p><ul><li>Java反射机制是指在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制</li></ul></li><li><p><strong>静态编译</strong></p><ul><li>在编译时确定类型，绑定对象，即通过</li></ul></li><li><p><strong>动态编译</strong></p><ul><li>运行时确定类型，绑定对象。动态编译最大限度发挥了java的灵活性，体现了多态的应用，有以降低类之间的藕合性</li></ul></li><li><p><strong>优点</strong></p><ul><li>一个大型的软件，不可能一次就把把它设计的很完美，当这个程序编译后，发布了，当发现需要更新某些功能时，我们不可能要用户把以前的卸载，再重新安装新的版本，假如这样的话，这个软件肯定是没有多少人用的。采用静态的话，需要把整个程序重新编译一次才可以实现功能的更新，而采用反射机制的话，它就可以不用卸载，只需要在运行时才动态的创建和编译，就可以实现该功能。</li></ul></li><li><p><strong>缺点</strong></p><ul><li>对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于只直接执行相同的操作。</li></ul></li><li><p><strong>Object</strong></p><ul><li>该类是所有类的父类</li></ul></li><li><p><strong>Class类</strong></p><ul><li>类是java.lang.Class类的实例对象，而Class是所有类的类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Class c = new Class();不能这样构建一个Class</span></span><br><span class="line"><span class="comment">//因为构造方法是私有的</span></span><br><span class="line"><span class="function"><span class="keyword">private</span>  <span class="title">Class</span><span class="params">(ClassLoader loader)</span> </span>&#123; </span><br><span class="line">    classLoader = loader; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>得到Class对象的3种方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这说明任何一个类都有一个隐含的静态成员变量class，这种方式是通过获取类的静态成员变量class得到的</span></span><br><span class="line">Class c1 = Code.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">//code1是Code的一个对象，这种方式是通过一个类的对象的getClass()方法获得的</span></span><br><span class="line">Code code1 = <span class="keyword">new</span> Code();</span><br><span class="line">Class c2 = code1.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">//这种方法是Class类调用forName方法，通过一个类的全量限定名获得</span></span><br><span class="line">Class c3 = Class.forName(<span class="string">"com.trigl.reflect.Code"</span>);</span><br></pre></td></tr></table></figure><ul><li>c1、c2、c3都是Class的对象，他们是完全一样的，而且有个学名，叫做Code的类类型（class type）</li><li>我们可以通过类类型知道一个类的属性和方法，并且可以调用一个类的属性和方法，这就是反射的基础</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(c1.getName());</span><br><span class="line">System.out.println(c2.getName());</span><br><span class="line">System.out.println(c3.getName());</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">com.trigl.reflect.Code</span><br><span class="line">com.trigl.reflect.Code</span><br><span class="line">com.trigl.reflect.Code</span><br></pre></td></tr></table></figure></li><li><p><strong>Class作用</strong></p><ul><li><p>获取成员方法Method</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getDeclaredMethod</span><span class="params">(String name, Class&lt;?&gt; ...parameterTypes)</span> <span class="comment">// 得到该类指定参数的自身声明的方法，不包括父类的</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Method[] <span class="title">getDeclaredMethods</span><span class="params">()</span></span>; <span class="comment">// 得到该类自身声明所有的方法，不包括父类的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt; ...parameterTypes)</span> <span class="comment">// 得到该类指定参数的自身所有的public方法，包括父类的</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Method[] <span class="title">getMethods</span><span class="params">()</span></span>;<span class="comment">// 得到该类自身所有的public方法，包括父类的</span></span><br></pre></td></tr></table></figure></li><li><p>获取成员变量Field</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Field <span class="title">getDeclaredField</span><span class="params">(String name)</span> <span class="comment">// 获得该类指定名称的自身声明的变量，不包括其父类的变量</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Field[] <span class="title">getDeclaredFields</span><span class="params">()</span> <span class="comment">// 获得该类自身声明的所有变量，不包括其父类的变量</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Field <span class="title">getField</span><span class="params">(String name)</span> <span class="comment">// 获得该类指定名称的自身所有的public成员变量，包括其父类变量</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Field[] <span class="title">getFields</span><span class="params">()</span> <span class="comment">// 获得该类自身所有的public成员变量，包括其父类变量</span></span></span><br></pre></td></tr></table></figure></li><li><p>获取构造函数Constructor</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Constructor&lt;T&gt; <span class="title">getDeclaredConstructor</span><span class="params">(Class&lt;?&gt; ...parameterTypes)</span> <span class="comment">//  获得该类指定参数的自身声明的构造器，不包括其父类的构造器</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Constructor&lt;?&gt;[] <span class="title">getDeclaredConstructors</span><span class="params">()</span> <span class="comment">//  获得该类所有的自身声明的构造器，不包括其父类的构造器</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(Class&lt;?&gt; ...parameterTypes)</span> <span class="comment">// 获得该类指定参数的自身所有的public构造器，包括父类</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Constructor&lt;?&gt;[] <span class="title">getConstructors</span><span class="params">()</span> <span class="comment">// 获得该类自身所有的public构造器，包括父类</span></span></span><br></pre></td></tr></table></figure></li><li><p>获得（Class,Method,Constructor上）的注解Annotation</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;A extends Annotation&gt;<span class="function">A <span class="title">getDeclaredAnnotation</span><span class="params">(Class&lt;A&gt; annotationClass)</span><span class="comment">//获取直接修饰该程序的指定类型的Annotation </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Annotation[] <span class="title">getDeclaredAnnotations</span><span class="params">()</span><span class="comment">//获取直接修饰该程序的所有的Annotation </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;A extends Annotation&gt;A <span class="title">getAnnotation</span><span class="params">(Class&lt;A&gt; annotationClass)</span> <span class="comment">//获取该程序元素上存在的指定类型的Annotation</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Annotation[] <span class="title">getAnnotations</span><span class="params">()</span> <span class="comment">//获取该程序元素上存在的所有的Annotation </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnnotationPresent</span><span class="params">(Class&lt;? extends Annotation&gt; annotationClass)</span> <span class="comment">//判断该程序元素上是否存在指定类型的注解</span></span></span><br></pre></td></tr></table></figure></li><li><p>实例化对象</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class c = Class.forName(<span class="string">"com.tengj.reflect.Person"</span>);  <span class="comment">//先生成class</span></span><br><span class="line">Object o = c.newInstance();  <span class="comment">//newInstance会使用该类默认的构造器来实例化一个对象</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>示例</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String msg=<span class="string">"hello wrold"</span>;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">  System.out.println(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"fun"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我叫"</span>+name+<span class="string">",今年"</span>+age+<span class="string">"岁"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      <span class="comment">//获取该类指定参数的方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class c = Class.forName(<span class="string">"com.tengj.reflect.Person"</span>);</span><br><span class="line">            Object o = c.newInstance();</span><br><span class="line">            Method method = c.getMethod(<span class="string">"fun"</span>, String.class, <span class="keyword">int</span>.class);</span><br><span class="line">          <span class="comment">//调用该方法</span></span><br><span class="line">            method.invoke(o, <span class="string">"tengj"</span>, <span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//获取该类声明的所有方法</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">            Class c = Class.forName(<span class="string">"com.tengj.reflect.Person"</span>);</span><br><span class="line">            Method[] methods = c.getDeclaredMethods();</span><br><span class="line">            <span class="keyword">for</span>(Method m:methods)&#123;</span><br><span class="line">              <span class="comment">//得到方法返回值类型的类类型</span></span><br><span class="line">    Class returType = m.getReturnType();</span><br><span class="line">              <span class="comment">//获取参数类型 参数列表类型的类类型</span></span><br><span class="line">   Class[] paramTypes = m.getParameterTypes();</span><br><span class="line">              </span><br><span class="line">                String  methodName = m.getName();</span><br><span class="line">                System.out.println(methodName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//获取该类声明的指定名称的成员变量</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">            Class c = Class.forName(<span class="string">"com.tengj.reflect.Person"</span>);</span><br><span class="line">            Field field = c.getDeclaredField(<span class="string">"msg"</span>); <span class="comment">//因为msg变量是private的，所以不能用getField方法</span></span><br><span class="line">            Object o = c.newInstance();</span><br><span class="line">        <span class="comment">//设置是否允许访问，因为该变量是private的，所以要手动设置允许访问，如果msg是public的就不需要这行了。</span></span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//获取该实例的成员变量的值</span></span><br><span class="line">            Object msg = field.get(o);</span><br><span class="line">        <span class="comment">//将该实例的成员变量的值设为“Bye~”</span></span><br><span class="line">        <span class="comment">//field.setString(o,"Bye~");</span></span><br><span class="line">        <span class="comment">//System.out.println(field.get(o));</span></span><br><span class="line">        <span class="comment">//输出“Bye~”</span></span><br><span class="line">            System.out.println(msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//获取该类声明的所有的成员变量</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">            Class c = Class.forName(<span class="string">"com.tengj.reflect.Person"</span>);</span><br><span class="line">            Field[] fields = c.getDeclaredFields();</span><br><span class="line">            <span class="keyword">for</span>(Field field :fields)&#123;</span><br><span class="line">              <span class="comment">//得到成员变量的类型的类类型</span></span><br><span class="line">       Class fieldType = field.getType();</span><br><span class="line">              </span><br><span class="line">                System.out.println(field.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//获取该类声明的指定参数的构造方法</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">            Class c = Class.forName(<span class="string">"com.tengj.reflect.Person"</span>);</span><br><span class="line">            Constructor constructor = c.getDeclaredConstructor(String.class);</span><br><span class="line">        <span class="comment">//设置是否允许访问，因为该构造器是private的，所以要手动设置允许访问，如果构造器是public的就不需要这行了。</span></span><br><span class="line">            constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//c.newInstance()只能是调用默认的无参构造方法</span></span><br><span class="line">            Object o = constructor.newInstance(<span class="string">"tengj"</span>);<span class="comment">//选择使用有一个形参的构造方法</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//获取该类声明的所有构造方法</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">            Class c = Class.forName(<span class="string">"com.tengj.reflect.Person"</span>);</span><br><span class="line">      Constructor[] constructors = c.getDeclaredConstructors();</span><br><span class="line">            <span class="keyword">for</span>(Constructor constructor:constructors)&#123;</span><br><span class="line">                System.out.println(constructor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">结果：</span><br><span class="line">我叫tengj,今年<span class="number">10</span>岁</span><br><span class="line"></span><br><span class="line">getName</span><br><span class="line">setName</span><br><span class="line">setAge</span><br><span class="line">fun</span><br><span class="line">fun</span><br><span class="line">getAge</span><br><span class="line"></span><br><span class="line">hello wrold</span><br><span class="line">  </span><br><span class="line">name</span><br><span class="line">age</span><br><span class="line">msg</span><br><span class="line">  </span><br><span class="line">tengj</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> com.tengj.reflect.Person()</span><br><span class="line"><span class="keyword">public</span> com.tengj.reflect.Person(java.lang.String)</span><br></pre></td></tr></table></figure><ul><li><strong>使用反射避免泛型的类型约束</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericEssence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List list1 = <span class="keyword">new</span> ArrayList(); <span class="comment">// 没有泛型</span></span><br><span class="line">        List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">// 有泛型</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 1.首先观察正常添加元素方式，在编译器检查泛型，</span></span><br><span class="line"><span class="comment">         * 这个时候如果list2添加int类型会报错</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        list2.add(<span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">//      list2.add(20); // 报错！list2有泛型限制，只能添加String，添加int报错</span></span><br><span class="line">        System.out.println(<span class="string">"list2的长度是："</span> + list2.size()); <span class="comment">// 此时list2长度为1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 2.然后通过反射添加元素方式，在运行期动态加载类，首先得到list1和list2</span></span><br><span class="line"><span class="comment">         * 的类类型相同，然后再通过方法反射绕过编译器来调用add方法，看能否插入int</span></span><br><span class="line"><span class="comment">         * 型的元素</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class c1 = list1.getClass();</span><br><span class="line">        Class c2 = list2.getClass();</span><br><span class="line">        System.out.println(c1 == c2); <span class="comment">// 结果：true，说明类类型完全相同</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证：我们可以通过方法的反射来给list2添加元素，这样可以绕过编译检查</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method m = c2.getMethod(<span class="string">"add"</span>, Object.class); <span class="comment">// 通过方法反射得到add方法</span></span><br><span class="line">            m.invoke(list2, <span class="number">20</span>); <span class="comment">// 给list2添加一个int型的，上面显示在编译器是会报错的</span></span><br><span class="line">            System.out.println(<span class="string">"list2的长度是："</span> + list2.size()); <span class="comment">// 结果：2，说明list2长度增加了，并没有泛型检查</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 综上可以看出，在编译器的时候，泛型会限制集合内元素类型保持一致，但是编译器结束进入</span></span><br><span class="line"><span class="comment">         * 运行期以后，泛型就不再起作用了，即使是不同类型的元素也可以插入集合。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">结果：</span><br><span class="line">list2的长度是：1</span><br><span class="line">true</span><br><span class="line">list2的长度是：2</span><br></pre></td></tr></table></figure><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><ul><li><p><strong>作用</strong></p><ul><li>创建文档。<ul><li>这是最常见的，也是java 最早提供的注解。常用的有<code>@see</code> <code>@param</code> <code>@return</code> 等</li></ul></li><li>跟踪代码中的依赖性。<ul><li>实现替代配置文件功能。比较常见的是spring 2.5 开始的基于注解配置。作用就是减少配置。现在的框架基本都使用了这种配置来减少配置文件的数量。</li></ul></li><li>甚至执行基本编译时检查。<ul><li>如<code>@override</code> 放在方法前，如果你这个方法并不是覆盖了超类方法，则编译时就能检查出。</li></ul></li></ul></li><li><p><strong>标准 Annotation</strong> (java內置注解)</p><ul><li>@Override<ul><li>用于修饰此方法覆盖了父类的方法。</li></ul></li><li>@Deprecated<ul><li>用于修饰已经过时的方法。</li></ul></li><li>@SuppressWarnings<ul><li>通知java编译器忽略特定的警告信息<blockquote><p>@SuppressWarnings(value={“deprecation”, “unchecked”})<br>@SuppressWarnings({“deprecation”, “unchecked”})<br>@SuppressWarnings(“unchecked”)</p></blockquote></li></ul></li></ul></li><li><p><strong>元 Annotation</strong> (元注解)</p><ul><li><p>元 Annotation 是指用来定义 Annotation 的 Annotation</p></li><li><p>@Retention</p><ul><li>指明了该Annotation被保留的时间长短。</li><li>RetentionPolicy取值为SOURCE，CLASS，RUNTIME。<blockquote><p>SOURCE：在源文件中有效(即源文件保留)<br>CLASS：在class文件中有效(即class保留)<br>RUNTIME：在运行时有效(即运行时保留)</p></blockquote></li></ul></li><li><p>@Target</p><ul><li>指明该类型的注解可以注解的程序元素的范围。</li><li>该元注解的取值可以为<code>TYPE</code>,<code>METHOD</code>,<code>CONSTRUCTOR</code>,<code>FIELD</code>等。</li><li>如果Target元注解没有出现，那么定义的注解可以应用于程序的任何元素。<blockquote><p>CONSTRUCTOR：用于描述构造器<br>FIELD：用于描述域<br>LOCAL_VARIABLE：用于描述局部变量<br>METHOD：用于描述方法<br>PACKAGE：用于描述包<br>PARAMETER：用于描述参数<br>TYPE：用于描述类、接口(包括注解类型) 或enum声明</p></blockquote></li></ul></li><li><p>@Inherited</p><ul><li>标记注解，表示了某个被标注的类型是被继承的</li><li>如果用户在当前类中查询这个元注解类型并且当前类的声明中不包含这个元注解类型，那么也将自动查询当前类的父类是否存在Inherited元注解，这个动作将被重复执行知道这个标注类型被找到，或者是查询到顶层的父类。</li></ul></li><li><p>@Documented</p><ul><li>指明拥有这个注解的元素可以被javadoc此类的工具文档化。</li><li>如果一种声明使用Documented进行注解，这种类型的注解被作为被标注的程序成员的公共API。</li></ul></li></ul></li><li><p><strong>示例</strong></p><ul><li>注解方法不能带有参数</li><li>注解方法返回值类型限定为：基本类型、<code>String</code>、<code>Enums</code>、<code>Annotation</code>或者是这些类型的数组</li><li>注解方法可以有默认值</li><li>注解本身能够包含元注解，元注解被用来注解其它注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MethodInfo&#123;</span><br><span class="line">    <span class="function">String <span class="title">author</span><span class="params">()</span> <span class="keyword">default</span> 'yangki'</span>;</span><br><span class="line">    <span class="function">String <span class="title">date</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">revision</span><span class="params">()</span> <span class="keyword">default</span> 1</span>;</span><br><span class="line">    <span class="function">String <span class="title">comments</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.yangki.annotations;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@MethodInfo</span>(author = <span class="string">'yangki'</span>, comments = <span class="string">'Main method'</span>, date = <span class="string">'Nov 17 2012'</span>, revision = <span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Overriden toString method'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="meta">@MethodInfo</span>(comments = <span class="string">'deprecated method'</span>, date = <span class="string">'Nov 17 2015'</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">oldMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">'old method, don'</span>t use it.<span class="string">');</span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@SuppressWarnings(&#123; '</span>unchecked<span class="string">', '</span>deprecation<span class="string">' &#125;)</span></span><br><span class="line"><span class="string">@MethodInfo(author = '</span>yangki<span class="string">', comments = '</span>Main method<span class="string">', date = '</span>Nov <span class="number">17</span> <span class="number">2015</span><span class="string">', revision = 10)</span></span><br><span class="line"><span class="string">public static void genericsTest() throws FileNotFoundException &#123;</span></span><br><span class="line"><span class="string">    List l = new ArrayList();</span></span><br><span class="line"><span class="string">    l.add('</span>abc<span class="string">');</span></span><br><span class="line"><span class="string">    oldMethod();</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>用反射来解析注解<ul><li>注解的<code>RetentionPolicy</code>应该设置为<code>RUNTIME</code> ，否则java类的注解信息在执行过程中将不可用，那么我们也不能从中得到任何和注解有关的数据。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationParsing</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Method method : AnnotationParsing.class</span><br><span class="line">         <span class="comment">//Class.getClassLoader()方法返回的类的类加载器</span></span><br><span class="line">        .getClassLoader()</span><br><span class="line">         <span class="comment">//加载AnnotationExample类</span></span><br><span class="line">        .loadClass((<span class="string">'net.yangki.annotations.AnnotationExample'</span>))</span><br><span class="line">         <span class="comment">//获得AnnotationExample类的Class后调用getMethods()获取该类的所有的public方法</span></span><br><span class="line">        .getMethods()) &#123;</span><br><span class="line">        <span class="comment">//判断该方法上的MethodInfo注解是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (method.isAnnotationPresent(com.journaldev.annotations.MethodInfo.class)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (Annotation anno : method.getDeclaredAnnotations()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">'Annotation in Method '</span><span class="string">'+ method + '</span><span class="string">' : '</span> + anno);</span><br><span class="line">                    &#125;</span><br><span class="line">                MethodInfo methodAnno = method.getAnnotation(MethodInfo.class);</span><br><span class="line">                <span class="keyword">if</span> (methodAnno.revision() == <span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">'Method with revision no 1 = '</span>+ method);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li></ul>]]></content>
    
    <summary type="html">
    
      这次我更加深入的理解了泛型，多线程和IO处理，还有就是Java的类加载，反射和注解的知识
    
    </summary>
    
      <category term="Java" scheme="https://barry215.github.io/categories/Java/"/>
    
    
      <category term="java" scheme="https://barry215.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java 基础</title>
    <link href="https://barry215.github.io/2016/10/12/Java-foundation/"/>
    <id>https://barry215.github.io/2016/10/12/Java-foundation/</id>
    <published>2016-10-12T11:13:26.000Z</published>
    <updated>2017-08-29T15:28:55.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本数据类型和运算符"><a href="#基本数据类型和运算符" class="headerlink" title="基本数据类型和运算符"></a>基本数据类型和运算符</h3><ul><li>byte</li><li>short</li><li>int</li><li>int[]</li><li>long</li><li>boolean</li><li>char</li><li>char[]</li><li>float</li><li>double</li><li>!</li><li>%</li><li>&amp;&amp;</li><li>||</li><li>+</li><li>//</li><li>++</li><li>- -</li></ul><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><table><thead><tr><th style="text-align:left">数据类型</th><th>封装类</th><th>特点</th></tr></thead><tbody><tr><td style="text-align:left">int</td><td>Integer</td><td>int初始化是0，Integer初始化是null。Integer是int的封装类，可以实现和字符串的转换</td></tr><tr><td style="text-align:left">char</td><td>Character</td><td>char初始化是_，Character初始化是null</td></tr><tr><td style="text-align:left">long</td><td>Long</td><td>long初始化是0，Long初始化是null</td></tr><tr><td style="text-align:left">byte</td><td>Byte</td><td>byte初始化是0，Byte初始化是null</td></tr><tr><td style="text-align:left">short</td><td>Short</td><td>short初始化是0，Short初始化是null</td></tr><tr><td style="text-align:left">float</td><td>Float</td><td>float初始化是0.0，Float初始化是null</td></tr><tr><td style="text-align:left">double</td><td>Double</td><td>double初始化是0.0，Double初始化是null</td></tr><tr><td style="text-align:left">boolean</td><td>Boolean</td><td>boolean初始化是false，Boolean初始化是null</td></tr></tbody></table><blockquote><p> PS：泛型定义时也不支持数据类型，只能是类</p><p> 如<code>List&lt;int&gt;</code>就不行，但是<code>List&lt;Integer&gt;</code>可以</p></blockquote><h4 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h4><p>在自动装箱的时候，Java虚拟机会自动调用Integer的valueOf方法；<br>在自动拆箱的时候，Java虚拟机会自动调用Integer的intValue方法。</p><p>Byte、Short、Integer、Long、Char这几个装箱类的valueOf()方法是以128位分界线做了缓存的，假如是[-128,127]区间的值是会取缓存里面的引用的，以Integer为例，其valueOf(int i)的源代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high=<span class="number">127</span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Integer 在静态代码块中缓存了-128 ~ 127 之间的数字（IntegerCache），范围外的就只能去new了，所以integer在比较这个区间内的地址是相同的</p></blockquote><p>参考路径</p><p><a href="http://www.jianshu.com/p/946b3c4a5db6" target="_blank" rel="noopener">http://www.jianshu.com/p/946b3c4a5db6</a></p><h3 id="判断，筛选和循环"><a href="#判断，筛选和循环" class="headerlink" title="判断，筛选和循环"></a>判断，筛选和循环</h3><ul><li>if</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">say</span><span class="params">(<span class="keyword">int</span> word)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = word;</span><br><span class="line">  <span class="keyword">if</span>(a == <span class="number">1</span>)&#123;</span><br><span class="line">      a = <span class="number">0</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      a = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>switch</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(a)&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>for</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">  System.out.println(<span class="string">"我循环啦！"</span>);</span><br><span class="line">  <span class="keyword">if</span>(i == <span class="number">3</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">"跳出循环"</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(<span class="string">"C要大写！"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>while</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = key;</span><br><span class="line">  <span class="keyword">while</span>(a&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    a--;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">5</span>)&#123;</span><br><span class="line">      System.out.println(<span class="string">"跳出循环"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">1</span>)&#123;</span><br><span class="line">      System.out.println(<span class="string">"结束方法"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>foreach</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] bbs = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> bb : bbs)&#123;</span><br><span class="line">  System.out.println(bb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>do while</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  a--;</span><br><span class="line">  System.out.println(<span class="string">"循环"</span>);</span><br><span class="line">&#125;<span class="keyword">while</span>(a&gt;<span class="number">3</span>);</span><br></pre></td></tr></table></figure><ul><li>5 &gt; 4 ? “y” : “n”   返回的是y</li></ul><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><ul><li>思想<ul><li>万事万物都是对象</li><li>每个对象都具有各自的状态特征（也可以称为属性）及行为特征（方法）</li><li>比如我们考虑一只狗，那么它的     状态是：名称，品种，颜色      行为：吠叫，摇摆，跑等</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String breed;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">   <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">barking</span><span class="params">()</span></span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hungry</span><span class="params">()</span></span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleeping</span><span class="params">()</span></span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li>介绍<ul><li>构造方法是一种特殊的方法</li><li>构造方法的方法名必须与类名相同</li><li>构造方法没有返回类型，也不能定义为void，在方法名前面不声明方法类型</li><li>构造方法的主要作用是<strong>完成对象的初始化工作</strong>，它能够把定义对象时的参数传给对象的域</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Puppy</span></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Puppy</span><span class="params">()</span></span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Puppy</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="值引用"><a href="#值引用" class="headerlink" title="值引用"></a>值引用</h3><p>java中方法参数传递方式是按值传递。<br>如果参数是基本类型，传递的是基本类型的字面量值的拷贝。<br>如果参数是引用类型，传递的是该参量所引用的对象在堆中地址值的拷贝。</p><p>参考路径</p><p><a href="https://www.zhihu.com/question/31203609" target="_blank" rel="noopener">java到底是值传递还是引用传递？</a></p><h3 id="Clone"><a href="#Clone" class="headerlink" title="Clone"></a>Clone</h3><blockquote><p>clone是对对象进行复制，是一维层面的深拷贝，会产生一个新对象，但是对象里的引用还是指向同一个，方法是native方法，效率高。</p></blockquote><h4 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h4><ul><li>clone的对象必须要实现Cloneable接口，不然CloneNotSupportedException异常，clone实现的是浅拷贝，如果要深拷贝，需要重写方法，注意重写后的方法的返回值可以是Object的子类</li><li>数组的clone，复制的仅仅是数组中的元素，比如数组中元素为引用类型，那仅仅复制引用。若clone的对象中含有链表，则应单独对链表进行循环复制</li></ul><h3 id="arraycopy"><a href="#arraycopy" class="headerlink" title="arraycopy"></a>arraycopy</h3><blockquote><p>System.arraycopy是复制一个数组，也是native方法</p></blockquote><h4 id="二维数组或对象数组"><a href="#二维数组或对象数组" class="headerlink" title="二维数组或对象数组"></a>二维数组或对象数组</h4><p>arraycopy 也只能实现浅拷贝，因为java没有二维数组的概念，他是数组的数组，所以arraycopy 拷贝二维数组只能是拷贝引用，arraycopy拷贝对象数组也是只能拷贝引用。arraycopy只要拷贝一维数组的基础类型时才是深拷贝</p><h3 id="HashCode"><a href="#HashCode" class="headerlink" title="HashCode"></a>HashCode</h3><h4 id="hashcode和equal的区别"><a href="#hashcode和equal的区别" class="headerlink" title="hashcode和equal的区别"></a>hashcode和equal的区别</h4><p>hashcode能大概区分是否是同一对象，equal是能准确区别对象<br>hashcode不同，则两个对象不同<br>hashcode相同，则对象不一定相同，需要进一步equal比较</p><h4 id="注意点-2"><a href="#注意点-2" class="headerlink" title="注意点"></a>注意点</h4><ul><li>设计hashCode()时最重要的因素就是：无论何时，对同一个对象调用hashCode()都应该产生同样的值。如果在讲一个对象用put()添加进HashMap时产生一个hashCdoe值，而用get()取出时却产生了另一个hashCode值，那么就无法获取该对象了。所以如果你的hashCode方法依赖于对象中易变的数据，用户就要当心了，因为此数据发生变化时，hashCode()方法就会生成一个不同的散列码</li><li>重写equal方法后，一定也要重写hashcode，否则不能使用hashmap了</li></ul><h4 id="分装类实现"><a href="#分装类实现" class="headerlink" title="分装类实现"></a>分装类实现</h4><blockquote><p>我会基本列举下面封装类的所有构造方法</p></blockquote><p>在String类中的hashCode是根据String类中包含的字符串获取的，根据哈希算法获取到一个哈希码，那么只要我的字符内容是相等的，我的哈希码也是相同的。</p><blockquote><p>new String(“”)和直接赋值的区别，在于new String(“”)创建两个String对象，直接赋值创建一个</p><p>更多区别参考：<a href="http://blog.csdn.net/fullstack/article/details/**23885879" target="_blank" rel="noopener">String和New String()的区别</a>、<a href="https://segmentfault.com/q/1010000008746502" target="_blank" rel="noopener">String s=new String()与String s = “”的区别</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">String a = <span class="string">"cx"</span>;  </span><br><span class="line">  String aa = <span class="string">"cx"</span></span><br><span class="line">String b = <span class="keyword">new</span> String(<span class="string">"cx"</span>);  </span><br><span class="line">  <span class="keyword">char</span>[] p = &#123;<span class="string">'a'</span>,<span class="string">'b'</span>&#125;;</span><br><span class="line">String c = <span class="keyword">new</span> String(p);</span><br><span class="line"><span class="keyword">int</span>[] i = &#123;<span class="number">97</span>,<span class="number">98</span>&#125;;</span><br><span class="line">String d = <span class="keyword">new</span> String(i,<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">System.out.println(b.hashCode()==a.hashCode());  </span><br><span class="line">System.out.println(d.hashCode()==c.hashCode());  </span><br><span class="line">  System.out.println(a == b);</span><br><span class="line">  System.out.println(a == aa);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//false 两个对象的内存地址是不同的</span></span><br><span class="line"><span class="comment">//true 引用的常量池字符串的地址是相同的</span></span><br></pre></td></tr></table></figure><p>Integer类中的hashCode和String是一样的，也是根据类中包含的值去生成的哈希码。两个相同大小的integer值，那么它的hashCode也是相等的。这里不用考虑127这个分界线</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">Integer a = <span class="keyword">new</span> Integer(<span class="number">1234</span>);  </span><br><span class="line">Integer b = <span class="keyword">new</span> Integer(<span class="number">1234</span>); </span><br><span class="line">Integer c = <span class="keyword">new</span> Integer(<span class="string">"1234"</span>); </span><br><span class="line">Integer d = <span class="keyword">new</span> Integer(<span class="string">"1234"</span>); </span><br><span class="line">System.out.println(b.hashCode()==a.hashCode());  </span><br><span class="line">System.out.println(d.hashCode()==c.hashCode());  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>Character类也是一样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Character a = <span class="keyword">new</span> Character(<span class="string">'a'</span>);</span><br><span class="line">    Character b = <span class="string">'a'</span>;</span><br><span class="line">  <span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br><span class="line">  <span class="keyword">char</span> d = <span class="number">97</span>;</span><br><span class="line">  <span class="comment">//基本类型没有hashcode方法</span></span><br><span class="line">    System.out.println(b.hashCode()==a.hashCode());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>Object类中的hashCode则和之前的不一样了，他是根据对象的内存地址经过哈希算法之后获取到的哈希码，由于每个对象的内存地址不相同，所以hashCode是不同的。</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><p>是指把对象转成字符串的方法。</p><ul><li>当使用+的时候</li><li>用println方法的时候</li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>不要在toString方法中用‘+this’这种操作，这样会不断调用toString方法，导致死循环</p><p>速学路径</p><p><a href="http://www.voidcn.com/blog/u012413167/article/p-5978865.html" target="_blank" rel="noopener">http://www.voidcn.com/blog/u012413167/article/p-5978865.html</a></p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li>介绍<ul><li>继承一个类，子类会获得父类的所有成员变量和成员方法</li><li>一个类只能继承一个父类，但是可以被多个子类继承</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> age = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">public</span> String name = <span class="string">"dog"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">    Dog d1 = <span class="keyword">new</span> Dog();</span><br><span class="line">    System.out.println(d1.getName());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把父类实例赋给子类变量——相当于说动物是狗</span></span><br><span class="line">    <span class="comment">//把子类实例赋给父类变量——相当于说狗是动物</span></span><br><span class="line">    </span><br><span class="line">    Dog d2 = <span class="keyword">new</span> Animal(); <span class="comment">//变量其实只是给你的实例起个名字而已，这里类型转化后，还是Animal类型</span></span><br><span class="line">    d2.setName(<span class="number">30</span>); <span class="comment">//程序报错，因为d2的类型还是Animal，Animal没有setName的方法</span></span><br><span class="line">    </span><br><span class="line">     <span class="comment">//父类对象由子类实例化</span></span><br><span class="line">    Animal animal = <span class="keyword">new</span> Dog();</span><br><span class="line">    System.out.println(animal.age);</span><br><span class="line">    System.out.println(animal.getAge());</span><br><span class="line">    <span class="comment">//System.out.println(animal.getName()); 错误，Animal没有getName的方法</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">结果：   <span class="comment">//animal变量访问变量是看 声明的类型，访问方法是看 实例的方法！</span></span><br><span class="line">dog</span><br><span class="line">  <span class="number">40</span></span><br><span class="line"><span class="number">18</span></span><br></pre></td></tr></table></figure><ul><li>instanceof 运算符<ul><li>左面的对象是右面的类创建的对象时,该运算符运算的结果是true,否则是false </li><li>instanceof左边操作元显式声明的类型与右边操作元必须是同种类或右边是左边父类的继承关系</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">      Animal a = <span class="keyword">new</span> Animal();</span><br><span class="line">      Dog d = <span class="keyword">new</span> Dog();</span><br><span class="line"></span><br><span class="line">      System.out.println(a <span class="keyword">instanceof</span> Animal);</span><br><span class="line">      System.out.println(d <span class="keyword">instanceof</span> Animal);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">结果：</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><ul><li>重写<ul><li>在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。方法重写又称方法覆盖。</li></ul></li></ul><h4 id="向上转型-amp-向下转型"><a href="#向上转型-amp-向下转型" class="headerlink" title="向上转型&amp;向下转型"></a>向上转型&amp;向下转型</h4><p><strong>向上转型</strong>：子类引用的对象转换为父类类型称为向上转型。通俗地说就是是将子类对象转为父类对象。此处父类对象可以是接口</p><p><strong>向下转型</strong>：父类引用的对象转换为子类类型称为向下转型。</p><p>前者是一个向上转型，Animal dog 引用指向new Dog();子类对象当成父类对象，只能调用父类的成员，如果子类重写了父类的方法就根据这个引用指向调用子类重写的这个方法（这个方法就是覆盖override）。这个调用过程就称为“动态绑定”。</p><p>在向下转型过程中，分为两种情况：</p><ul><li>如果父类引用的对象如果引用的是指向的子类对象，那么在向下转型的过程中是安全的。也就是编译是不会出错误的。</li><li>如果父类引用的对象是父类本身，那么在向下转型的过程中是不安全的，编译不会出错，但是运行时会出现java.lang.ClassCastException错误。它可以使用instanceof来避免出错此类错误。</li></ul><p><a href="http://blog.csdn.net/qq_35101189/article/details/53897341" target="_blank" rel="noopener">Java向上转型和向下转型</a></p><h3 id="修饰词"><a href="#修饰词" class="headerlink" title="修饰词"></a>修饰词</h3><table><thead><tr><th>类型</th><th>同类</th><th>同包</th><th>不同包子类</th><th>不同包非子类</th></tr></thead><tbody><tr><td>private</td><td>yes</td><td></td><td></td><td></td></tr><tr><td>default</td><td>yes</td><td>yes</td><td></td><td></td></tr><tr><td>protected</td><td>yes</td><td>yes</td><td>yes</td><td></td></tr><tr><td>public</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td></tr></tbody></table><ul><li>private<ul><li>除了class自己之外，任何人都不可以直接使用</li></ul></li><li>default<ul><li>类可以访问在同一个包中的其他类(朋友)的成员</li></ul></li><li>protected<ul><li>只有相同的包下的类(朋友)和自己的子类(子女)才能访问</li></ul></li><li>public<ul><li>该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用</li></ul></li><li>final<ul><li>final类不能被继承，没有子类，final类中的方法默认是final的</li><li>final方法不能被子类的方法覆盖，但可以被继承。</li><li>final成员变量或参数表示常量，只能被赋值一次，赋值后值不再改变。</li><li>final不能用于修饰构造方法。</li></ul></li><li>static<ul><li>static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块</li><li>被static修饰的成员变量和成员方法独立于该类的任何对象，即<strong>不需要实例化对象就能用类名.变量(方法)来使用</strong></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String StaticFinalVar = <span class="string">"aaa"</span>;</span><br></pre></td></tr></table></figure><ul><li>this<ul><li>this是对象，this.成员变量，this.函数（哪个对象调用的，this就代表该对象）</li><li>函数的参数与成员变量重名时，赋值语句使用 this.name = name; </li><li>this(name); 根据this所带的参数判断调用哪个构造函数。</li></ul></li><li>super<ul><li>super();  调用父类构造函数 </li><li>super.成员函数； 调用父类成员函数或变量</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">char</span> c;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//无参构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//一个参数的构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.num = num;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//两个参数的构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">    <span class="comment">//这里调用了第一个构造方法，并且必须放在新的构造方法的第一行</span></span><br><span class="line">    <span class="keyword">this</span>(num);</span><br><span class="line">    c = ch;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.num = num;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span> </span>&#123;</span><br><span class="line">        test t = <span class="keyword">new</span> test(<span class="number">8</span>);</span><br><span class="line">System.out.println(t.getNum());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">exam</span> <span class="keyword">extends</span> <span class="title">test</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> grade;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">exam</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">exam</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(num);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> gradeSheet)</span></span>&#123;</span><br><span class="line">    <span class="comment">//super.num = gradeSheet;</span></span><br><span class="line">    <span class="keyword">super</span>.setNum(gradeSheet);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.getNum();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">exam e = <span class="keyword">new</span> exam(<span class="number">3</span>);</span><br><span class="line">System.out.println(e.getNum());</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sheet = <span class="number">95</span>;</span><br><span class="line">e.query(sheet);</span><br><span class="line">System.out.println(e.getNum());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">  <span class="number">3</span></span><br><span class="line">  <span class="number">95</span></span><br></pre></td></tr></table></figure><h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><ul><li>static<ul><li>静态代码块里的使用的变量和方法也必须是static的</li><li>静态代码块是在类加载时自动执行的，非静态代码块是在创建对象时自动执行的代码，不创建对象就不会执行该类的非静态代码块</li><li>执行顺序：静态代码块——非静态代码块—-构造函数</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticBlock</span> </span>&#123;</span><br><span class="line"><span class="comment">//静态代码块</span></span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">"静态块"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">  <span class="comment">//非静态代码块</span></span><br><span class="line">     &#123;</span><br><span class="line">         System.out.println(<span class="string">"构造块，在类中定义"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">StaticBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"构造方法执行"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">new</span> StaticBlock();</span><br><span class="line">         <span class="keyword">new</span> StaticBlock();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">  静态块 </span><br><span class="line">  构造块，在类中定义 </span><br><span class="line">  构造方法执行 </span><br><span class="line">  构造块，在类中定义 </span><br><span class="line">  构造方法执行</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloA</span><span class="params">()</span></span>&#123;<span class="comment">//构造函数</span></span><br><span class="line">        System.out.println(<span class="string">"A的构造函数"</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">    &#123;<span class="comment">//构造代码块</span></span><br><span class="line">        System.out.println(<span class="string">"A的构造代码块"</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;<span class="comment">//静态代码块</span></span><br><span class="line">        System.out.println(<span class="string">"A的静态代码块"</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloB</span> <span class="keyword">extends</span> <span class="title">HelloA</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloB</span><span class="params">()</span></span>&#123;<span class="comment">//构造函数</span></span><br><span class="line">        System.out.println(<span class="string">"B的构造函数"</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">    &#123;<span class="comment">//构造代码块</span></span><br><span class="line">        System.out.println(<span class="string">"B的构造代码块"</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;<span class="comment">//静态代码块</span></span><br><span class="line">        System.out.println(<span class="string">"B的静态代码块"</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloB b=<span class="keyword">new</span> HelloB();        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">A的静态代码块</span><br><span class="line">B的静态代码块</span><br><span class="line">A的构造代码块</span><br><span class="line">A的构造函数</span><br><span class="line">B的构造代码块</span><br><span class="line">B的构造函数</span><br></pre></td></tr></table></figure><ul><li>原理<ul><li>实例化有两个步骤：1、类加载  2、new 对象</li><li>一个类在第一次被使用的时候会被类加载，然后在整个应用程序的生命周期当中不会再次被加载了，就加载这一次</li><li>因为static{}是在类加载时候被加载的，所以static{}也只会被加载一次</li></ul></li><li>内部类与静态内部类的区别<ul><li>静态内部类相对与外部类是独立存在的，静态内部类中无法直接访问外部类中变量、方法。如果要访问的话，必须要new一个外部类的对象，使用new出来的对象来访问。但是可以直接访问静态的变量、调用静态的方法</li><li>普通内部类作为外部类一个成员而存在，在普通内部类中可以直接访问外部类属性，调用外部类的方法</li><li>如果外部类要访问内部类的属性或者调用内部类的方法，必须要创建一个内部类的对象，使用该对象访问属性或者调用方法</li><li>如果其他的类要访问普通内部类的属性或者调用普通内部类的方法，必须要在外部类中创建一个普通内部类的对象作为一个属性，外同类可以通过该属性调用普通内部类的方法或者访问普通内部类的属性</li></ul></li></ul><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类不能访问外部类方法中的局部变量，除非变量被声明为final类型　</p><ol><li>这里所说的“匿名内部类”主要是指在其外部类的成员方法内定义，同时完成实例化的类，若其访问该成员方法中的局部变量，局部变量必须要被final修饰。　　</li><li>原因是编译程序实现上的困难：内部类对象的生命周期会超过局部变量的生命周期。局部变量的生命周期：当该方法被调用时，该方法中的局部变量在栈中被创建，当方法调用结束时，退栈，这些局部变量全部死亡。而内部类对象生命周期与其它类一样：自创建一个匿名内部类对象，系统为该对象分配内存，直到没有引用变量指向分配给该对象的内存，它才会死亡(被JVM垃圾回收)。所以完全可能出现的一种情况是：成员方法已调用结束，局部变量已死亡，但匿名内部类的对象仍然活着。　　</li><li>如果匿名内部类的对象访问了同一个方法中的局部变量，就要求只要匿名内部类对象还活着，那么栈中的那些它要所访问的局部变量就不能“死亡”。　　</li><li>解决方法：匿名内部类对象可以访问同一个方法中被定义为final类型的局部变量。定义为final后，编译程序的实现方法：对于匿名内部类对象要访问的所有final类型局部变量，都拷贝成为该对象中的一个数据成员。这样，即使栈中局部变量已死亡，但被定义为final类型的局部变量的值永远不变，因而匿名内部类对象在局部变量死亡后，照样可以访问final类型的局部变量，因为它自己拷贝了一份，且与原局部变量的值始终一致。　　</li><li>最后，Java 8更加智能：如果局部变量被匿名内部类访问，那么该局部变量相当于自动使用了final修饰。此外，Java 8的λ表达式也与此类似只能访问final外部变量但不要求用final修饰，不过，变量同样不能被重新赋值。</li></ol><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>  <img src="Java-foundation/collection.png" alt="collection"></p><ul><li>Collection (接口)</li><li>List (接口)<ul><li>ArrayList (实现类)<ul><li>非线程安全</li></ul></li><li>Vector (实现类)<ul><li>线程安全</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; objectList = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">Object object1 = <span class="keyword">new</span> Object();</span><br><span class="line">Object object2 = <span class="keyword">new</span> Object();</span><br><span class="line">objectList.add(object1);</span><br><span class="line">object2 = objectList.get(<span class="number">0</span>);</span><br><span class="line">objectList.remove(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li>Set (接口)<ul><li>HashSet (实现类)<ul><li>不能有重复的元素</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collection books = <span class="keyword">new</span> HashSet();</span><br><span class="line">books.add(<span class="string">"01"</span>);</span><br><span class="line">books.add(<span class="string">"02"</span>);</span><br></pre></td></tr></table></figure><ul><li>Iterator (接口)<ul><li><strong>只能用于Collection的遍历</strong></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator it = books.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">  String book = (String)it.next();</span><br><span class="line">  it.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="排序函数"><a href="#排序函数" class="headerlink" title="排序函数"></a>排序函数</h4><ul><li>实现Comparable接口</li><li>重载比较函数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> guwh </span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> 创建时间：2011-11-3 上午10:49:36 </span></span><br><span class="line"><span class="comment">* 类说明 </span></span><br><span class="line"><span class="comment">*/</span>   </span><br><span class="line"><span class="keyword">package</span> com.jabberchina.test;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;  </span><br><span class="line"><span class="keyword">import</span> java.util.Collections;  </span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;  </span><br><span class="line"><span class="keyword">import</span> java.util.List;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortTest</span> </span>&#123;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        List&lt;String&gt; lists = <span class="keyword">new</span> ArrayList&lt;String&gt;();  </span><br><span class="line">        List&lt;A&gt; list = <span class="keyword">new</span> ArrayList&lt;A&gt;();  </span><br><span class="line">        List&lt;B&gt; listB = <span class="keyword">new</span> ArrayList&lt;B&gt;();  </span><br><span class="line">        lists.add(<span class="string">"5"</span>);  </span><br><span class="line">        lists.add(<span class="string">"2"</span>);  </span><br><span class="line">        lists.add(<span class="string">"9"</span>);  </span><br><span class="line">        <span class="comment">//lists中的对象String 本身含有compareTo方法，所以可以直接调用sort方法，按自然顺序排序，即升序排序  </span></span><br><span class="line">        Collections.sort(lists);  </span><br><span class="line">          </span><br><span class="line">        A aa = <span class="keyword">new</span> A();  </span><br><span class="line">        aa.setName(<span class="string">"aa"</span>);  </span><br><span class="line">        aa.setOrder(<span class="number">1</span>);  </span><br><span class="line">        A bb = <span class="keyword">new</span> A();  </span><br><span class="line">        bb.setName(<span class="string">"bb"</span>);  </span><br><span class="line">        bb.setOrder(<span class="number">2</span>);  </span><br><span class="line">        list.add(bb);  </span><br><span class="line">        list.add(aa);  </span><br><span class="line">        <span class="comment">//list中的对象A实现Comparable接口  </span></span><br><span class="line">        Collections.sort(list);  </span><br><span class="line">          </span><br><span class="line">        B ab = <span class="keyword">new</span> B();  </span><br><span class="line">        ab.setName(<span class="string">"ab"</span>);  </span><br><span class="line">        ab.setOrder(<span class="string">"1"</span>);  </span><br><span class="line">        B ba = <span class="keyword">new</span> B();  </span><br><span class="line">        ba.setName(<span class="string">"ba"</span>);  </span><br><span class="line">        ba.setOrder(<span class="string">"2"</span>);  </span><br><span class="line">        listB.add(ba);  </span><br><span class="line">        listB.add(ab);  </span><br><span class="line">        <span class="comment">//根据Collections.sort重载方法来实现  </span></span><br><span class="line">        Collections.sort(listB,<span class="keyword">new</span> Comparator&lt;B&gt;()&#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(B b1, B b2)</span> </span>&#123;  </span><br><span class="line">                <span class="keyword">return</span> b1.getOrder().compareTo(b2.getOrder());  </span><br><span class="line">            &#125;  </span><br><span class="line">              </span><br><span class="line">        &#125;);  </span><br><span class="line">          </span><br><span class="line">        System.out.println(lists);  </span><br><span class="line">        System.out.println(list);  </span><br><span class="line">        System.out.println(listB);  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">A</span>&gt;</span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> Integer order;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getOrder</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> order;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrder</span><span class="params">(Integer order)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.order = order;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"name is "</span>+name+<span class="string">" order is "</span>+order;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(A a)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.order.compareTo(a.getOrder());  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> String order;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getOrder</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> order;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrder</span><span class="params">(String order)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.order = order;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"name is "</span>+name+<span class="string">" order is "</span>+order;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">打印的结果为：  </span><br><span class="line"> [<span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>]  </span><br><span class="line">[name is aa order is <span class="number">1</span>, name is bb order is <span class="number">2</span>]  </span><br><span class="line">[name is ab order is <span class="number">1</span>, name is ba order is <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p> <img src="Java-foundation/map.png" alt="map"></p><ul><li>Map (接口)<ul><li>HashMap (实现类)</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(<span class="string">"boy"</span>,<span class="string">"凯杰"</span>);</span><br><span class="line">map.put(<span class="string">"girl"</span>,<span class="string">"青娜"</span>);</span><br><span class="line"><span class="keyword">if</span>(map.containKey(<span class="string">"boy"</span>))&#123;</span><br><span class="line">  String name = map.get(<span class="string">"boy"</span>);</span><br><span class="line">  <span class="keyword">for</span>(String type : map.keySet())&#123;</span><br><span class="line">    name = map.remove(type);</span><br><span class="line">    System.out.println(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>遍历Map</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">      map.put(<span class="string">"1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">      map.put(<span class="string">"2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">      map.put(<span class="string">"3"</span>, <span class="string">"value3"</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//第一种：普遍使用，二次取值</span></span><br><span class="line">      System.out.println(<span class="string">"通过Map.keySet遍历key和value："</span>);</span><br><span class="line">      <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">       System.out.println(<span class="string">"key= "</span>+ key + <span class="string">" and value= "</span> + map.get(key));</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//第二种</span></span><br><span class="line">      System.out.println(<span class="string">"通过Map.entrySet使用iterator遍历key和value："</span>);</span><br><span class="line">      Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line">      <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">       Map.Entry&lt;String, String&gt; entry = it.next();</span><br><span class="line">       System.out.println(<span class="string">"key= "</span> + entry.getKey() + <span class="string">" and value= "</span> + entry.getValue());</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//第三种：推荐，尤其是容量大时</span></span><br><span class="line">      System.out.println(<span class="string">"通过Map.entrySet遍历key和value"</span>);</span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">       System.out.println(<span class="string">"key= "</span> + entry.getKey() + <span class="string">" and value= "</span> + entry.getValue());</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">//第四种</span></span><br><span class="line">      System.out.println(<span class="string">"通过Map.values()遍历所有的value，但不能遍历key"</span>);</span><br><span class="line">      <span class="keyword">for</span> (String v : map.values()) &#123;</span><br><span class="line">       System.out.println(<span class="string">"value= "</span> + v);</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h3><ul><li>interface<ul><li>接口是抽象方法的集合。一个类实现一个接口，从而继承接口的抽象方法</li><li>不能实例化一个接口</li><li>接口不包含任何构造函数</li><li>所有在接口中的方法都是抽象的</li><li>一个接口可以扩展多个接口</li><li>在接口中的每个方法也隐式抽象的，所以abstract关键字不需要</li><li>在接口中的方法是隐式公开的，即默认是public，不能写成private</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//定义一个接口类型的成员变量</span></span><br><span class="line">    <span class="keyword">private</span> ConnectToUsb connectToUsb;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//获得接口对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConnectToUsb <span class="title">getConnectToUsb</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> connectToUsb;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//赋值给接口  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConnectToUsb</span><span class="params">(ConnectToUsb connectToUsb)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.connectToUsb = connectToUsb;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//调用接口的方法</span></span><br><span class="line">        connectToUsb.connect();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//USB接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConnectToUsb</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MP3实现了USB接口的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MpThree</span> <span class="keyword">implements</span> <span class="title">ConnectToUsb</span></span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"MP3 To Connect!"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Computer c = <span class="keyword">new</span> Computer();  </span><br><span class="line">        MpThree m = <span class="keyword">new</span> MpThree();  </span><br><span class="line">        c.setConnectToUsb(m);  </span><br><span class="line">        c.connect();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">结果：MP3 To Connect!</span><br></pre></td></tr></table></figure><ul><li>abstract<ul><li>如果我们要定义的一个类的时候，没有足够的信息来描述一个具体的对象，还需要其他的具体类来支持</li><li>这个时候我们可以考虑使用抽象类。在类定义的前面增加abstract关键字，就表明一个类是抽象类。</li><li>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</li><li>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//形状父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shapes</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> width, height;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shapes</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.x = x;</span><br><span class="line">       <span class="keyword">this</span>.y = y;</span><br><span class="line">       <span class="keyword">this</span>.width = width;</span><br><span class="line">       <span class="keyword">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算面积</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//计算周长</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getPerimeter</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shapes</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> r;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (r * r * Math.PI);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPerimeter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (<span class="number">2</span> * Math.PI * r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> width, <span class="keyword">int</span> heigh)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//调用父类构造函数</span></span><br><span class="line">       <span class="keyword">super</span>(x, y, width, heigh);</span><br><span class="line">       r = (<span class="keyword">double</span>) width / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>区别<ul><li>接口作用<ul><li>在业务逻辑设计的时候，可以只关注逻辑，不去写具体实现。等到接口写完后，你完全可以把具体实现交给其他人做，其他人按照你的业务逻辑就能完成。</li><li>当知道<strong>一件事肯定要多次被做</strong>或者<strong>将来功能扩展的时候会被做</strong>，但是每次做的方法都不一样的时候，你可以写个接口，相当于声明了这个方法，而具体实现可以等用的时候再写，这样可以使代码更加简洁明了。</li></ul></li><li>抽象类作用<ul><li>多个类把共同的代码片段的抽取出来，做成一个基类。</li><li>相同行为，不同代码的成员方法，可以用抽象方法来代替，不去具体实现。</li><li>相同的代码，基类可以统一来具体实现了，节约了子类的代码</li></ul></li><li>两者区别<ul><li>接口更加零散，他专注于概括不同的方法。抽象类更加像一个基类，为不同的子类做一个总的基础。</li><li>抽象类是对<strong>类</strong>的抽象，而接口是对<strong>行为</strong>的抽象</li></ul></li></ul></li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><blockquote><p>多态是同一个行为具有多个不同表现形式或形态的能力</p></blockquote><ul><li>多态的思想<ul><li>继承，接口实现<ul><li>狗是动物，猫是动物，鱼是动物</li><li>吃可以是吃饭，吃零食，吃大餐</li></ul></li><li>重载<ul><li>被重载的方法必须改变参数列表（参数类型不同，或参数个数不同）</li><li>或是不同的返回类型，但方法名要一样</li><li>可以改变访问修饰符</li></ul></li><li>运算符重载<ul><li>运算符两边的东西不一样，作用也不一样</li></ul></li></ul></li><li>示例<ul><li>例子太多，就不举啦😀</li></ul></li></ul><h3 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h3><ul><li>String和char[]</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"GG"</span>;</span><br><span class="line"><span class="keyword">char</span>[] bm;</span><br><span class="line">bm = str.toCharArray();</span><br><span class="line"><span class="comment">//将 String 字符串 str 转换成数组</span></span><br><span class="line">str = String.valueOf(bm);</span><br><span class="line"><span class="comment">//将 char 数组 bm 转换成字符串</span></span><br></pre></td></tr></table></figure><ul><li>String是一个引用类型，不是基本数据类型</li><li>StringBuffer<ul><li>线程安全的</li></ul></li><li>StringBuilder<ul><li>线程非安全的，会造成死锁</li></ul></li><li>StringBuffer与StringBuilder<ul><li>StringBuilder &gt;  StringBuffer</li><li>他们是字符串变量，是可改变的对象，每当我们用它们对字符串做操作时，实际上是在一个对象上操作的，不像String一样创建一些对象进行操作，所以速度就快了。</li><li>如果要操作少量的数据用 = String</li><li>如果单线程操作字符串缓冲区 下操作大量数据 = StringBuilder</li><li>如果多线程操作字符串缓冲区 下操作大量数据 = StringBuffer</li></ul></li></ul><ul><li>StringAPI</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="comment">//返回指定索引处的 char 值。</span></span></span><br><span class="line"><span class="function">String <span class="title">concat</span><span class="params">(String str)</span> <span class="comment">//将指定字符串连接到此字符串的结尾。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span><span class="title">contains</span><span class="params">(CharSequence s)</span> <span class="comment">//当且仅当此字符串包含指定的 char 值序列时，返回 true。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span><span class="title">equals</span><span class="params">(Object anObject)</span> <span class="comment">//将此字符串与指定的对象比较。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span><span class="title">indexOf</span><span class="params">(String str)</span> <span class="comment">//返回指定字符在此字符串中第一次出现处的索引(从0开始)。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastindexOf</span><span class="params">(String str)</span> <span class="comment">//返回指定字符在此字符串中最后一次出现处的索引。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span><span class="title">isEmpty</span><span class="params">()</span> <span class="comment">//当且仅当 length() 为 0 时返回 true。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span><span class="title">length</span><span class="params">()</span> <span class="comment">//返回此字符串的长度。</span></span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span> <span class="comment">// 返回一个新的字符串，替换此字符串中出现的所有oldChar</span></span></span><br><span class="line"><span class="function">String <span class="title">trim</span><span class="params">()</span> <span class="comment">//返回字符串的副本，忽略前导空白和尾部空白。</span></span></span><br></pre></td></tr></table></figure><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><ul><li>enum</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color &#123;  </span><br><span class="line">  RED, GREEN, BLANK, YELLOW  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Signal &#123;</span><br><span class="line">  GREEN, YELLOW, RED</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrafficLight</span> </span>&#123;</span><br><span class="line">Signal color = Signal.RED;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (color) &#123;</span><br><span class="line"><span class="keyword">case</span> RED:</span><br><span class="line">color = Signal.GREEN;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> YELLOW:</span><br><span class="line">color = Signal.RED;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> GREEN:</span><br><span class="line">color = Signal.YELLOW;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color &#123;</span><br><span class="line">  <span class="comment">//实例的对象</span></span><br><span class="line">RED(<span class="string">"红色"</span>, <span class="number">1</span>), GREEN(<span class="string">"绿色"</span>, <span class="number">2</span>), BLANK(<span class="string">"白色"</span>, <span class="number">3</span>), YELLO(<span class="string">"黄色"</span>, <span class="number">4</span>);<span class="comment">//注意封号</span></span><br><span class="line"><span class="comment">// 成员变量</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Color</span><span class="params">(String name, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.index = index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getName</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Color c : Color.values()) &#123;</span><br><span class="line"><span class="keyword">if</span> (c.getIndex() == index) &#123;</span><br><span class="line"><span class="keyword">return</span> c.name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get set 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.index = index;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Color c = Color.RED;</span><br><span class="line">System.out.println(c.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">结果：</span><br><span class="line">红色</span><br></pre></td></tr></table></figure><h3 id="时间类"><a href="#时间类" class="headerlink" title="时间类"></a>时间类</h3><ul><li>Date</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(d.getTime()); <span class="comment">//1970年到现在的毫秒数</span></span><br><span class="line">System.out.println(d.getDate()); <span class="comment">//今天的日期</span></span><br><span class="line">System.out.println(d.getDay()); <span class="comment">//今天的星期号</span></span><br><span class="line">System.out.println(d.getHours()); <span class="comment">//现在的小时数</span></span><br><span class="line">      ······</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">结果：</span><br><span class="line"><span class="number">1477131413252</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">18</span></span><br></pre></td></tr></table></figure><ul><li>SimpleDateFormat<ul><li>一个格式化的时间工具类</li></ul></li><li>String转Date</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String dateString = <span class="string">"2016-10-22 19:43:00"</span>;</span><br><span class="line">DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">Date date = df.parse(dateString);</span><br><span class="line">      System.out.println(date);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Sat Oct 22 19:43:00 CST 2016</span></span><br></pre></td></tr></table></figure><ul><li>Date转String</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String time = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">System.out.println(time);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2016-10-22 18:25:49</span></span><br></pre></td></tr></table></figure><h3 id="加密类"><a href="#加密类" class="headerlink" title="加密类"></a>加密类</h3><ul><li>Hash 算法<ul><li>它的算法的特征是不可逆性，并且在计算的时候所有的数据都参与了运算，其中任何一个数据变化了都会导致计算出来的Hash值完全不同，所以通常用来校验数据是否正确或用作身份验证。</li></ul></li><li>MD5<ul><li>最常用的哈希算法</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getMD5</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> hexDigits[]&#123;<span class="string">'0'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'F'</span>&#125;;  </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] btInput = s.getBytes(<span class="string">"utf-8"</span>);</span><br><span class="line">            MessageDigest mdInst = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">            mdInst.update(btInput);</span><br><span class="line">            <span class="keyword">byte</span>[] md = mdInst.digest();</span><br><span class="line">            <span class="keyword">int</span> j = md.length;</span><br><span class="line">            <span class="keyword">char</span> str[] = <span class="keyword">new</span> <span class="keyword">char</span>[j * <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; i++) &#123;</span><br><span class="line">                <span class="keyword">byte</span> byte0 = md[i];</span><br><span class="line">                str[k++] = hexDigits[byte0 &gt;&gt;&gt; <span class="number">4</span> &amp; <span class="number">0xf</span>];</span><br><span class="line">                str[k++] = hexDigits[byte0 &amp; <span class="number">0xf</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(str);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>SHA <ul><li>SHA加密原理又叫安全哈希加密技术，是当今世界最先进的加密算法</li></ul></li><li>MD5和SHA的区别<ul><li>MD5比SHA快，SHA比MD5强度高，更安全</li></ul></li><li>salt 盐值<ul><li>混淆原数据的值</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      回顾了Java的基础知识，包括java的基础类型，面向对象，继承，集合，接口和抽象类，以及多态，希望自己所学的知识也能够帮助到其他人
    
    </summary>
    
      <category term="Java" scheme="https://barry215.github.io/categories/Java/"/>
    
    
      <category term="java" scheme="https://barry215.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://barry215.github.io/2016/04/05/hello-world/"/>
    <id>https://barry215.github.io/2016/04/05/hello-world/</id>
    <published>2016-04-05T06:16:00.000Z</published>
    <updated>2016-12-28T04:17:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><h3 id="most-use"><a href="#most-use" class="headerlink" title="most use"></a>most use</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo s</span><br><span class="line">$ hexo d</span><br><span class="line">$ hexo d -g</span><br><span class="line">$ hexo n filename</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Hexo 命令使用
    
    </summary>
    
      <category term="Other" scheme="https://barry215.github.io/categories/Other/"/>
    
    
      <category term="init" scheme="https://barry215.github.io/tags/init/"/>
    
  </entry>
  
</feed>
