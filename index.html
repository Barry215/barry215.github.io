<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.1.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="总有一天你是我的">
<meta property="og:type" content="website">
<meta property="og:title" content="麦金">
<meta property="og:url" content="https://barry215.github.io/index.html">
<meta property="og:site_name" content="麦金">
<meta property="og:description" content="总有一天你是我的">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="麦金">
<meta name="twitter:description" content="总有一天你是我的">



  <link rel="alternate" href="/atom.xml" title="麦金" type="application/atom+xml">



  
  
  <link rel="canonical" href="https://barry215.github.io/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>麦金</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">麦金</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">麦金的博客</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">

    
    
    
      
    

    

    <a href="/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>日程表</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-sitemap">

    
    
    
      
    

    

    <a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>站点地图</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-commonweal">

    
    
    
      
    

    

    <a href="/404/" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>公益 404</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://barry215.github.io/2018/02/06/computer-foundation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="frank">
      <meta itemprop="description" content="总有一天你是我的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="麦金">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/02/06/computer-foundation/" class="post-title-link" itemprop="url">计算机组成原理基础知识</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-02-06 13:34:06" itemprop="dateCreated datePublished" datetime="2018-02-06T13:34:06+08:00">2018-02-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-04-30 17:58:00" itemprop="dateModified" datetime="2018-04-30T17:58:00+08:00">2018-04-30</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Computer/" itemprop="url" rel="index"><span itemprop="name">Computer</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://pic4.zhimg.com/8bf6ef80ddbcd9ed5984fe9a51bb5b78_r.jpg" alt></p>
<h4 id="计算机之父"><a href="#计算机之父" class="headerlink" title="计算机之父"></a>计算机之父</h4><p>冯诺依曼   计算机由CPU处理器、运算器、存储器（ RAM， ROM等 ）输入设备、输出设备五部分组成</p>
<p>图灵提出了计算机的理论模型和图灵机概念</p>
<h4 id="逻辑地址和物理地址"><a href="#逻辑地址和物理地址" class="headerlink" title="逻辑地址和物理地址"></a>逻辑地址和物理地址</h4><p>为了解决使用物理地址不连续的问题，逻辑地址可以连续，而且映射到物理地址时，是不连续的。</p>
<p>需要页表来储存逻辑页和物理页的对应号关系，页表是页码，储存在内存，而段表储存在内存或寄存器</p>
<h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><ol>
<li>为了让CPU的利用率提高，就需要增加更多的进程给CPU，但是进程需要内存空间，所以会导致内存不够，需要利用磁盘等空间，虚拟化内存，利用某种算法，把暂时不用的信息放在磁盘，有可能会用到的信息放内存中。这样在某进程处理IO操作时，CPU可以即时切换到另一个进程。</li>
<li>如果计算机内存不够，则需要利用虚拟内存在逻辑上进行容量扩展。而实际上，它通常被分割成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换，即磁盘转内存。</li>
<li>虚拟地址可以保证每个进程的地址独立，并且可以保证连续性，映射到物理内存就可以不连续，可以被分成很细小的一页一页</li>
</ol>
<h4 id="页和段的区别"><a href="#页和段的区别" class="headerlink" title="页和段的区别"></a>页和段的区别</h4><p>页是信息的物理单位，是出于系统内存利用率的角度提出的离散分配机制；段是信息的逻辑单位，每个段含有一组意义完整的信息，是出于用户角度提出的内存管理机制。</p>
<p>页的大小是固定的，由系统决定；段的大小是不确定的，由用户决定</p>
<p>页地址空间是一维的，段地址空间是二维的。</p>
<p>因为页表也是在内存中，需要很占空间，所以产生了两级页表，这样可以在需要的时候再分配页表空间。</p>
<h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><p>进程有就绪、执行、阻塞3种状态</p>
<h4 id="SRAM和DRAM区别"><a href="#SRAM和DRAM区别" class="headerlink" title="SRAM和DRAM区别"></a>SRAM和DRAM区别</h4><blockquote>
<p>SRAM是英文Static RAM的缩写，它是一种具有静志存取功能的内存，不需要刷新电路即能保存它内部存储的数据。不像DRAM内存那样需要刷新电路，每隔一段时间，固定要对DRAM刷新充电一次，否则内部的数据即会消失，因此SRAM具有较高的性能，但是SRAM也有它的缺点，即它的集成度较低，相同容量的DRAM内存可以设计为较小的体积，但是SRAM却需要很大的体积，所以在主板上SRAM存储器要占用一部分面积。</p>
</blockquote>
<p>DRAM，动态随机存取存储器，需要不断的刷新，才能保存数据。而且是行列地址复用的，许多都有页模式。<br>SRAM，静态的随机存取存储器，加电情况下，不需要刷新，数据不会丢失，而且，一般不是行列地址复用的。<br>SDRAM，同步的DRAM，即数据的读写需要时钟来同步。</p>
<p>SRAM用作于置于CPU与主存间的高速缓存(cache)。<br>DRAM用作于内存。</p>
<h4 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h4><p>高速缓存(Cache)是位于CPU与主内存间的一种容量较小但速度很高的存储器。由于CPU的速度远高于主内存，CPU直接从内存中存取数据要等待一定时间周期，Cache中保存着CPU刚用过或循环使用的一部分数据，即也就是用于暂时存放内存中的数据，若果寄存器要取内存中的一部分数据时，可直接从缓存中取到，这样可以调高速度。高速缓存是内存的部分拷贝。Cache又分为一级Cache(L1 Cache)和二级Cache(L2 Cache)。</p>
<h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p>寄存器(Register)是中央处理器(CPU)内的组成部份，拥有非常高的读写速度。寄存器是有限存贮容量的高速存贮部件，它们可用来暂存<strong>指令、数据和位址</strong>。在中央处理器的控制部件中，包含的寄存器有指令寄存器(IR)和程序计数器(PC)。在中央处理器的算术及逻辑部件中，包含的寄存器有累加器(ACC)。</p>
<p>寄存器的工作方式很简单，只有两步：（1）找到相关的位，（2）读取这些位。</p>
<p>总体来说：CPU  <---> 寄存器<---> 缓存<--->内存</---></---></---></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://barry215.github.io/2017/07/16/http-socket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="frank">
      <meta itemprop="description" content="总有一天你是我的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="麦金">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/16/http-socket/" class="post-title-link" itemprop="url">Socket和Websocket的关系</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-16 20:23:28 / 修改时间：22:16:32" itemprop="dateCreated datePublished" datetime="2017-07-16T20:23:28+08:00">2017-07-16</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Http/" itemprop="url" rel="index"><span itemprop="name">Http</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>之前一直被误导的同学注意了，它们的关系就像Java和JavaScript根本没有sm关系</p>
</blockquote>
<p><img src="http-socket/RelationShip.png" alt></p>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><blockquote>
<p>Socket其实并不是一个协议，它是对传输层 TCP/IP 协议的抽象层，它是一组接口，提供一套调用TCP/IP协议的API</p>
</blockquote>
<p>如果你要使用HTTP来构建服务，那么就不需要关心Socket，如果你想基于TCP/IP来构建服务，那么就要使用Socket的API了</p>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><blockquote>
<p>WebSocket是HTML5中的协议，支持页面使用WebSocket协议与远程主机进行全双工的通信。</p>
</blockquote>
<p>WebSocket和Http一样，都是应用层协议，只是WebSocket是通过在客户端与服务器之间HTTP协议的初始握手阶段将其升级到WebSocket协议来建立的，不过其底层仍是TCP连接。</p>
<h4 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h4><p>websocket 建立连接先通过 Http 协议与服务器进行握手，服务器解析相应的 Http 协议，确认出本次连接是 Http 还是 websocket连接，如果是 websocket 连接，则双端直接进入 TCP/IP 常规的三次握手阶段，建立TCP连接，进行双向数据通信。</p>
<h4 id="WebSocket好处"><a href="#WebSocket好处" class="headerlink" title="WebSocket好处"></a>WebSocket好处</h4><ul>
<li>Http协议的单向行导致服务器只能被动的返回信息，WebSocket协议可以让服务器主动返回信息。</li>
<li>传统的轮询方式（即采用Http协议不断发送请求）有很多缺点，比如<strong>浪费流量</strong>（Http请求头比较大）、<strong>浪费资源</strong>（没有更新也要请求）、<strong>消耗服务器CPU占用</strong>（没有信息也要接收请求）</li>
<li>http1.1之后，浏览器默认开启keep-alive connection ，虽然这样可以在一次 Http连接中可以发送多个Request，接收多个Response，但是对每个请求仍然要单独发 header；然而websocket是基于回调设计的，不是request和response的形式，用于协议控制的数据包头部相对较小。如果请求频繁的话，就极大的减少了不必要的网络流量与延迟。</li>
</ul>
<h3 id="常用名词总结"><a href="#常用名词总结" class="headerlink" title="常用名词总结"></a>常用名词总结</h3><ol>
<li><p><strong>轮询</strong>：客户端定时向服务器发送Ajax请求，服务器接到请求后马上返回响应信息并关闭连接。<br>优点：后端程序编写比较容易。<br>缺点：请求中有大半是无用，浪费带宽和服务器资源。<br>实例：适于小型应用。</p>
</li>
<li><p><strong>长轮询</strong>：客户端向服务器发送Ajax请求，服务器接到请求后hold住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。<br>优点：在无消息的情况下不会频繁的请求。<br>缺点：服务器hold连接会消耗资源。<br>实例：WebQQ、Hi网页版、Facebook IM。</p>
</li>
<li><p><strong>长连接</strong>：在页面里嵌入一个隐蔵iframe，将这个隐蔵iframe的src属性设为对一个长连接的请求，服务器端就能源源不断地往客户端输入数据。<br>优点：消息即时到达，不发无用请求。<br>缺点：服务器维护一个长连接会增加开销。<br>实例：Gmail聊天</p>
</li>
<li><p><strong>WebSocket</strong>：客户端发送一次http(websocket协议升级)请求，服务器响应请求，三次握手后，双方建立持久连接，并进行双向数据传输，后面不进行HTTP连接，而是使用TCP连接。</p>
<p>优点：<strong>双向通信</strong>，<strong>减小服务器开销</strong>，<strong>更强的实时性</strong>，<strong>保持连接状态</strong></p>
<p>缺点：一旦服务器故障，连接就会中断，过老浏览器不支持WebSocket</p>
<p>实例：网页游戏</p>
</li>
<li><p>Http的无状态短连接：每次请求结束后，TCP连接就关闭，相关的内容就释放了，记不住任何状态。</p>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://barry215.github.io/2017/05/16/algorithmList/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="frank">
      <meta itemprop="description" content="总有一天你是我的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="麦金">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/05/16/algorithmList/" class="post-title-link" itemprop="url">算法练习(不断更新中)</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-05-16 14:29:52" itemprop="dateCreated datePublished" datetime="2017-05-16T14:29:52+08:00">2017-05-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-02-27 20:30:57" itemprop="dateModified" datetime="2018-02-27T20:30:57+08:00">2018-02-27</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>求链表环的入口结点</p>
<blockquote>
<p>先用快慢指针判断是否为环，然后快慢指针相交的点就是在环内，然后让慢指针不动，快指针到起点改为每次一步，慢指针也每次一步，继续遍历，（更麻烦的方法：然后再走一圈环回到相交点，就是这个环的长度。有了环的长度，则让两个指针相隔这个长度，然后前进，一旦后一个指针进入环，这两个指针就一定会相遇。）相遇的这个点就是入口结点</p>
</blockquote>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>一个排好序的数组，找出两数之和为m的所有组合</p>
<blockquote>
<p>从数组两边进行推进，如果两数之和小就把前指针往后移，反之也如此，直到找到之后，就可以两边同时缩紧</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params"> array, m </span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> j = array.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> ret = [];</span><br><span class="line">  <span class="keyword">while</span>( i &lt;= j ) &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = array[i] + array[j];</span><br><span class="line">    <span class="keyword">if</span> ( sum &gt; m ) &#123;</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( sum &lt; m ) &#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      ret.push( [ i, j, array[i], array[j] ] );</span><br><span class="line">      i++;</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自然数序列，找出任意连续之和等于n的所有子序列</p>
<blockquote>
<p>从0开始累加，如果到一个点累加的值比n大，就把这个累加数组从最小开始循环移出元素，直至找到匹配</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">total_sum = <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_seq</span><span class="params">(lst)</span>:</span></span><br><span class="line">    seq = []</span><br><span class="line">    ct = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> lst:</span><br><span class="line">        seq.append(x)</span><br><span class="line">        ct += x</span><br><span class="line">        <span class="keyword">if</span> ct == total_sum:</span><br><span class="line">            <span class="keyword">print</span> seq</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> ct &lt; total_sum:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> ct &gt; total_sum:</span><br><span class="line">            seq_len = len(seq)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(seq_len):</span><br><span class="line">                tr = seq.pop(<span class="number">0</span>)</span><br><span class="line">                ct -= tr</span><br><span class="line">                <span class="keyword">if</span> ct &lt; total_sum:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> ct == total_sum:</span><br><span class="line">                    <span class="keyword">print</span> seq</span><br><span class="line"></span><br><span class="line">sum_seq(lst)</span><br></pre></td></tr></table></figure>
<p>判断数组内是否有重复元素</p>
<blockquote>
<p>总体思想都是利用额外的数据结构的方式减少时间复杂度，比如辅助数组和哈希表</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种</span></span><br><span class="line"><span class="comment">//利用js对象是字典类型的结构(或者Java的Map)，判断是否存在key就好了，时间复杂度为O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isRepeat</span>(<span class="params">arr</span>)</span>&#123;  </span><br><span class="line">     <span class="keyword">var</span> hash = &#123;&#125;;  </span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> arr) &#123;  </span><br><span class="line">         <span class="keyword">if</span>(hash[arr[i]])  </span><br><span class="line">              <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">         hash[arr[i]] = <span class="literal">true</span>;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="comment">//如果数组里都是数字，而且都在一个范围内，那么可以用辅助数组的下标形式判断</span></span><br><span class="line"><span class="comment">//代码略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种</span></span><br><span class="line"><span class="comment">//如果数组里不是数字，那么可以利用HashMap的思想，利用hashcode%数组长度为数组下标+相同hashcode加链表的方式判重</span></span><br><span class="line"><span class="comment">//代码略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第四种</span></span><br><span class="line"><span class="comment">//先排序，然后判断相邻是否为重复元素，时间复杂度为排序的复杂度</span></span><br><span class="line"><span class="keyword">var</span> ary = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"111"</span>,<span class="string">"22"</span>,<span class="string">"33"</span>,<span class="string">"111"</span>);  </span><br><span class="line"><span class="keyword">var</span> nary=ary.sort();   </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;ary.length;i++)&#123;    </span><br><span class="line">	<span class="keyword">if</span> (nary[i]==nary[i+<span class="number">1</span>])&#123;  </span><br><span class="line">		alert(<span class="string">"数组重复内容："</span>+nary[i]);</span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>寻找从小到大的第1500个丑数（只包含2，3，5为因子的数是丑数，如4，6，8）</p>
<blockquote>
<p>利用空间换时间，保存1500个丑数就好了，关键是如果有序地生成丑数。</p>
<p>因为丑数肯定是丑数*(2,3,5)，我们可以根据已有丑数数组来算，把列表的丑数读乘2，比较是否大于数组里最大的丑数，然后选最小的那个大于数作为后一位丑数，如果都小于，则再试乘3，一次类推</p>
</blockquote>
<p>求连续子数组的的最大和，数组里面有正数也有负数。如{1,-2,3,10,-4,7,2,-5}中和最大的子数组是{3,10,-4,7,2}</p>
<blockquote>
<p>问题的原型好像就是找出一段和最大的数组。我们可以先从起点开始，保持一个最大数，一直累加，如果累加后一位的时候，发现是负数，则还是保持之前的最大数，如果累加得到的值比当前这个数还小，则累加起点变成这个点，然后最大数变成这个数的值。</p>
</blockquote>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>求二叉查找树中的两个结点的最低公共祖先</p>
<blockquote>
<p>从上往下进行遍历，如果结点的值比这两个结点都大或小，则进入他的左子树或右子树，然后如果碰到的结点大小刚好在两个结点的中间，则这个结点就是最低公共祖先。如果遇到刚好等于其中一个结点的值，那么这个结点就是最低公共祖先</p>
</blockquote>
<p>求普通二叉树的两个结点的最低公共祖先</p>
<blockquote>
<p>既然不是排序树，则判断是否有指向父节点的指针，如果有，可以转化为链表求第一个公共节点的问题；如果还是没有指向父节点的指针，用两个链表分别保存从根节点到输入的两个节点的路径，然后把问题转换成两个链表的最后公共节点</p>
</blockquote>
<p><img src="/2017/05/16/algorithmList/ordinaryTree.png" alt></p>
<p>我们首先得到一条从根结点到树中某一结点的路径，这就要求在遍历的时候，有一个辅助内存来保存路径．比如我们用前序遍历的方法来得到从根结点到H的路径的过程是这样的：（ 1 ）遍历到A，把A 存放到路径中去，路径中只有一个结点A; ( 2 ）遍历到B，把B 存到路径中去，此时路径为A-&gt;B; ( 3 ）遍历到D，把D 存放到路径中去，此，时路径为A-&gt;B-&gt;D; ( 4 ） ：遍历到F，把F 存放到路径中去，此时路径为A-&gt;B-&gt;D-&gt;F;( 5) F 已经没有子结点了，因此这条路径不可能到这结点H. 把F 从路径中删除，变成A-&gt;B-&gt;D; ( 6 ）遍历G. 和结点F 一样，这条路径也不能到达H. 边历完G 之后，路径仍然是A-&gt;B-&gt;D; ( 7 ）由于D 的所有子结点都遍历过了，不可能到这结点H，因此D 不在从A 到H 的路径中，把D 从路径中删除，变成A-&gt;B; ( 8 ）遥历E，把E 加入到路径中，此时路径变成A-&gt;B-&gt;E, ( 9 ）遍历H，已经到达目标给点， A-&gt;B-&gt;E 就是从根结点开始到达H 必须经过的路径。</p>
<p>从上到下打印二叉树</p>
<p><img src="/2017/05/16/algorithmList/printTree.png" alt></p>
<p>效果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">6 10</span><br><span class="line">5 7 9 11</span><br></pre></td></tr></table></figure>
<blockquote>
<p>利用栈的思想，压入从左到右，从上到下的结点，再保持两个变量，一个是下层要打印的节点数，一个是当前层要打印的结点数。比如顶点8，先压栈8，打印后，8出栈，此层打完了就打换行符，再压栈6和10。接着打印6，压栈5和7，6出栈，再打印10，压栈9和11，10出栈，最后打印5，7，9，11</p>
</blockquote>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>十进制转十六进制</p>
<blockquote>
<p>先算出他有几个16次方，然后每次都转换成一个十六进制符号</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toHex</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> divisor = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>[] table = <span class="string">"0123456789ABCDEF"</span>.toCharArray();</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">while</span> (divisor * base &lt;= num) &#123;</span><br><span class="line">        divisor *= base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; divisor &gt;= <span class="number">1</span>; divisor /= base) &#123;</span><br><span class="line">        result.append(table[num/divisor]);</span><br><span class="line">        num %= divisor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(toHex(<span class="number">1220</span>,<span class="number">16</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>十六进制转十进制</p>
<blockquote>
<p>从字符串的头开始算，然后每次都乘转换数，比如16，然后累加</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">stoi</span><span class="params">(String src, <span class="keyword">int</span> base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> digit, result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; src.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = src.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (c &gt;= <span class="string">'a'</span>) &#123;</span><br><span class="line">            digit = c - <span class="string">'a'</span> + <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">'A'</span>) &#123;</span><br><span class="line">            digit = c - <span class="string">'A'</span> + <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            digit = c - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result = base*result + digit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(stoi(<span class="string">"4C4"</span>,<span class="number">16</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>约瑟夫环问题：已知n个人（以编号1，2，3…n分别表示）围坐在一张圆桌周围。从编号为k的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人又出列；依此规律重复下去，直到圆桌周围的人全部出列，求出列人的顺序编号</p>
<blockquote>
<p>关键在于获取每次出列的人的index，其实index=startNum+countNum（开始的序号‘‘0~1’’+规定的长度-1），如果index大于列表总长了，就要用%取余，获取到index后，就remote它，接着开始的序号就变成刚刚remote的index了</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yue</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line"><span class="comment">//        Scanner scanner = new Scanner(System.in);  </span></span><br><span class="line"><span class="comment">//        System.out.print("请输入总人数：");  </span></span><br><span class="line"><span class="comment">//        int totalNum = scanner.nextInt();  </span></span><br><span class="line"><span class="comment">//        System.out.print("请输入报数的大小：");  </span></span><br><span class="line"><span class="comment">//        int cycleNum = scanner.nextInt();  </span></span><br><span class="line"><span class="comment">//        System.out.print("请输入开始编号：");  </span></span><br><span class="line"><span class="comment">//        int  startNO= scanner.nextInt();  </span></span><br><span class="line"><span class="comment">//        yuesefu(totalNum, cycleNum,startNO);  </span></span><br><span class="line">        yuesefu(<span class="number">5</span>, <span class="number">2</span>,<span class="number">3</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">yuesefu</span><span class="params">(<span class="keyword">int</span> totalNum, <span class="keyword">int</span> countNum,<span class="keyword">int</span> startNO)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 初始化人数  </span></span><br><span class="line">        List&lt;Integer&gt; start = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= totalNum; i++) &#123;  </span><br><span class="line">            start.add(i);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//从下标为K开始计数  </span></span><br><span class="line">        <span class="keyword">int</span> k = startNO-<span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">while</span> (start.size() &gt;<span class="number">0</span>) &#123;  </span><br><span class="line">            System.out.println(start);</span><br><span class="line">            <span class="comment">//第m人的索引位置</span></span><br><span class="line">            k = (k + countNum) % (start.size()) - <span class="number">1</span>;  </span><br><span class="line">           <span class="comment">// 判断是否到队尾  到队尾时候k=-1</span></span><br><span class="line">            <span class="keyword">if</span> (k &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">                System.out.println(start.get(start.size()-<span class="number">1</span>));  </span><br><span class="line">                start.remove(start.size() - <span class="number">1</span>);  </span><br><span class="line">                k = <span class="number">0</span>;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                System.out.println(start.get(k));  </span><br><span class="line">                start.remove(k);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考路径</p>
<p><a href="http://www.jianshu.com/p/8e794879dd29" target="_blank" rel="noopener">http://www.jianshu.com/p/8e794879dd29</a></p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>求找钱的所有方法数</p>
<p><img src="/2017/05/16/algorithmList/zhaoqian.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findNum</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span> || aim == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> process(arr, <span class="number">0</span>, aim);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过递归来切换arr的index，内部循环来进行枚举</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> aim)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (index == arr.length)&#123;</span><br><span class="line">        num = aim == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; arr[index] * i &lt;= aim; i++)&#123;</span><br><span class="line">            num += process(arr, index + <span class="number">1</span>, aim - arr[index]*i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">10</span>,<span class="number">25</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> aim = <span class="number">15</span>;</span><br><span class="line">    System.out.println(findNum(arr,aim));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汉诺塔</p>
<p>汉诺塔有3个柱子，求把n个叠在左侧的塔全移到右侧和搬运的次数，要求一次只能移一个塔，并且小的不能在大的下面</p>
<blockquote>
<p>通过递归的方式，寻找抽象的动作，每次都有一个起点，暂放点和重点，可以抽象地从搬多个可以递归到搬一个</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> move(n, <span class="string">"left"</span>, <span class="string">"right"</span>, <span class="string">"mid"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> n, String from, String to, String helper)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)&#123;</span><br><span class="line">        System.out.println(from + <span class="string">" move to "</span> + to);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    num += move(n-<span class="number">1</span>, from, helper, to);</span><br><span class="line">    System.out.println(from + <span class="string">" move to "</span> + to);</span><br><span class="line">    num ++;</span><br><span class="line">    num += move(n-<span class="number">1</span>, helper, to, from);</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(hanoi(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>深度优先遍历</p>
<p>假设在一个9 × 9的格子里，每一步可以往正上、正下、正左、正右、左上、左下、右上、右下八个方向走，但是空白区域不能走，走过的点不能再走。求能吃最多果实的路线。</p>
<p><img src="http://o7x0ygc3f.bkt.clouddn.com/%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98-9.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pos</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;  <span class="comment">// 横坐标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;  <span class="comment">// 纵坐标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// get、set、construct方法省略</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"Pos&#123;"</span>);</span><br><span class="line">        sb.append(<span class="string">"x="</span>).append(x);</span><br><span class="line">        sb.append(<span class="string">", y="</span>).append(y);</span><br><span class="line">        sb.append(<span class="string">'&#125;'</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Pos pos = (Pos) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x == pos.x &amp;&amp; y == pos.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = x;</span><br><span class="line">        result = <span class="number">31</span> * result + y;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sdbl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过深度优先搜索算法获取最长路径</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map        地图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start      起点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> moveOffset 移动偏移量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 最长路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Pos&gt; <span class="title">getLongestPathByDFS</span><span class="params">(<span class="keyword">int</span>[][] map, Pos start, Pos[] moveOffset)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Pos&gt; longestPath = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(start, map, <span class="keyword">new</span> ArrayList&lt;&gt;(), longestPath, moveOffset);</span><br><span class="line">        <span class="keyword">return</span> longestPath;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归实现深度优先搜索</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Pos pos, <span class="keyword">int</span>[][] map, List&lt;Pos&gt; oldPath, List&lt;Pos&gt; result, Pos[] moveOffset)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录当前位置向周围格子移动的记录</span></span><br><span class="line">        List&lt;Pos&gt; visited = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 依次向周围移动</span></span><br><span class="line">        <span class="keyword">for</span> (Pos aMoveOffset : moveOffset) &#123;</span><br><span class="line">            Pos next = <span class="keyword">new</span> Pos(pos.getX() + aMoveOffset.getX(), pos.getY() + aMoveOffset.getY());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (inMap(map, next) &amp;&amp; !oldPath.contains(next) &amp;&amp; map[next.getX()][next.getY()] == <span class="number">1</span>) &#123;</span><br><span class="line">                oldPath.add(next);</span><br><span class="line">                visited.add(next);</span><br><span class="line">                dfs(next, map, oldPath, result, moveOffset);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若在当前位置下，没有向周围的格子移动过时，保存最长路径</span></span><br><span class="line">        <span class="keyword">if</span> (visited.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldPath.size() &gt; result.size()) &#123;</span><br><span class="line">                result.clear();</span><br><span class="line">                result.addAll(oldPath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 周围的格子都不可以移动时回退到上一格子</span></span><br><span class="line"><span class="comment">//        for (Pos neighbour : neighbours) &#123;</span></span><br><span class="line"><span class="comment">//            if (canPath(map, oldPath, neighbour, visited)) &#123;</span></span><br><span class="line"><span class="comment">//                System.out.println("我到了 "+neighbour);</span></span><br><span class="line"><span class="comment">//                return;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        oldPath.remove(pos);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断格子是否可以移动</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canPath</span><span class="params">(<span class="keyword">int</span>[][] map, List&lt;Pos&gt; path, Pos pos, List&lt;Pos&gt; visited)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不在地图里，不能移动</span></span><br><span class="line">        <span class="keyword">if</span> (!inMap(map, pos)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 空白格子，不能移动</span></span><br><span class="line">        <span class="keyword">if</span> (map[pos.getY()][pos.getX()] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 已经在路径中或经过，不能移动</span></span><br><span class="line">        <span class="keyword">if</span> (path.contains(pos) || visited.contains(pos)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断格子是否在地图内</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">inMap</span><span class="params">(<span class="keyword">int</span>[][] map, Pos pos)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pos.getY() &lt; <span class="number">0</span> || pos.getY() &gt;= map.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pos.getX() &lt; <span class="number">0</span> || pos.getX() &gt;= map[<span class="number">0</span>].length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化参数</span></span><br><span class="line">        <span class="keyword">int</span>[][] simpleMap = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Pos[] moveOffset = <span class="keyword">new</span> Pos[]&#123;</span><br><span class="line">                <span class="keyword">new</span> Pos(-<span class="number">1</span>, <span class="number">0</span>),    <span class="comment">// 向左移动</span></span><br><span class="line">                <span class="keyword">new</span> Pos(-<span class="number">1</span>, -<span class="number">1</span>),    <span class="comment">// 向左上移动</span></span><br><span class="line">                <span class="keyword">new</span> Pos(<span class="number">0</span>, -<span class="number">1</span>),    <span class="comment">// 向上移动</span></span><br><span class="line">                <span class="keyword">new</span> Pos(<span class="number">1</span>, -<span class="number">1</span>),    <span class="comment">// 向右上移动</span></span><br><span class="line">                <span class="keyword">new</span> Pos(<span class="number">1</span>, <span class="number">0</span>),    <span class="comment">// 向右移动</span></span><br><span class="line">                <span class="keyword">new</span> Pos(<span class="number">1</span>, <span class="number">1</span>),    <span class="comment">// 向右下移动</span></span><br><span class="line">                <span class="keyword">new</span> Pos(<span class="number">0</span>, <span class="number">1</span>),    <span class="comment">// 向下移动</span></span><br><span class="line">                <span class="keyword">new</span> Pos(-<span class="number">1</span>, <span class="number">1</span>)     <span class="comment">// 向左下移动</span></span><br><span class="line">        &#125;;</span><br><span class="line">        Pos start = <span class="keyword">new</span> Pos(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行深度优先算法</span></span><br><span class="line">        List&lt;Pos&gt; longestPath = getLongestPathByDFS(simpleMap, start, moveOffset);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印路径</span></span><br><span class="line">        System.out.println(longestPath);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>你正在爬n层的楼梯，但每次你只能爬一步或者两步，你能有多少种不同的方法爬到楼顶部？</p>
<blockquote>
<p>已知爬1层和2层的方法数，在前面的基础上，可以知道爬3层的数方法数，同理4层只能是通过2层的基础+2步或3层的基础+1步来实现的，而前面已经知道2层和3层的方法数了，相加就好了，这个是动态规划的思想</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">climb</span>(<span class="params">floor</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(floor &lt; <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> plans = [];</span><br><span class="line"></span><br><span class="line">	plans[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	plans[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> cur = <span class="number">3</span>; cur &lt;= floor; cur++)&#123;</span><br><span class="line">		plans[cur] = plans[cur - <span class="number">1</span>] + plans[cur - <span class="number">2</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> plans[floor];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>矩阵求从[0,0]路径[3,3]点的最小值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 5 4 8</span><br><span class="line">1 4 2 6</span><br><span class="line">9 2 5 7</span><br><span class="line">0 2 8 2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>先求上面一行和左边一行的路径最小值</p>
<p>2 7 11 19<br>3<br>12<br>12</p>
<p>然后可以开始遍历剩余的点，左边和上边选一个最小值，再加上自己的值就是这个点的最小路径值，直到遍历到[3,3]点</p>
</blockquote>
<p><img src="/2017/05/16/algorithmList/juzheng1.png" alt></p>
<p>最长递增子序列（不连续）</p>
<blockquote>
<p>先从末尾分析，如果n位大于n-1位，则dp(n) = dp(n-1)+1，然后从0位开始积累dp数组</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lis</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxLength = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//例如dp[3]是前4位序列包含的最长递增子序列的值</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    <span class="comment">//第一个数，自己是自己的最长递增子序列，初始值为1</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">//不去考虑之前的值，的确初始值为1</span></span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="comment">//找出前面dp大于当前dp的位置 并且 要求之前序列的最后位的值小于当前值才符合条件</span></span><br><span class="line">            <span class="keyword">if</span> (dp[j] &gt;= dp[i] &amp;&amp; arr[j] &lt; arr[i]) &#123;</span><br><span class="line">                dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                System.out.println(<span class="string">"d["</span>+i+<span class="string">"] 找前面的值是:d["</span>+j+<span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">              <span class="comment">//if (arr[j] &lt; arr[i]) &#123;</span></span><br><span class="line">              <span class="comment">//  dp[i] = dp[j] + 1;</span></span><br><span class="line">              <span class="comment">//  System.out.println("d["+i+"] 找前面的值是:d["+j+"]");</span></span><br><span class="line">              <span class="comment">//  break;</span></span><br><span class="line">              <span class="comment">//&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] &gt; maxLength) &#123;</span><br><span class="line">            maxLength = dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最长公共子序列（不连续）</p>
<blockquote>
<p>从末尾分析，如果<code>X[i]==Y[j]</code>，则<code>c[i][j] = c[i-1][j-1]+1</code>;如果<code>X[i]!=Y[j]</code>，则<code>c[i][j] = Math.max(c[i][j-1],c[i-1][j])</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] lengthofLCS(<span class="keyword">char</span>[] X, <span class="keyword">char</span>[] Y)&#123;</span><br><span class="line">    <span class="comment">/* 构造二维数组c[][]记录X[i]和Y[j]的LCS长度 (i,j)是前缀</span></span><br><span class="line"><span class="comment">     * c[i][j]=0; 当 i = j = 0;</span></span><br><span class="line"><span class="comment">     * c[i][j]=c[i-1][j-1]+1; 当 i = j &gt; 0; Xi == Y[i]</span></span><br><span class="line"><span class="comment">     * c[i][j]=max(c[i-1][j],c[i][j+1]); 当 i = j &gt; 0; Xi </span></span><br><span class="line"><span class="comment">     * 需要计算 m*n 个子问题的长度 即 任意c[i][j]的长度</span></span><br><span class="line"><span class="comment">     * -- 填表过程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span>[][]c = <span class="keyword">new</span> <span class="keyword">int</span>[X.length+<span class="number">1</span>][Y.length+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 动态规划计算所有子问题</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=X.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=Y.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(X[i-<span class="number">1</span>]==Y[j-<span class="number">1</span>])&#123;</span><br><span class="line">                c[i][j] = c[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                c[i][j] = Math.max(c[i][j-<span class="number">1</span>],c[i-<span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印C数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=X.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=Y.length;j++)&#123;</span><br><span class="line">            System.out.print(c[i][j]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最长公共子串（连续）</p>
<blockquote>
<p>和上面的基本一样，但是如果<code>X[i]!=Y[j]</code>，则<code>c[i][j]</code>为0</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthofLCString</span><span class="params">(String X, String Y)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 构造二维数组c[][]记录X[i]和Y[j]的LCS长度 (i,j)是前缀</span></span><br><span class="line"><span class="comment">     * c[i][j]=0; 当 i = j = 0;</span></span><br><span class="line"><span class="comment">     * c[i][j]=c[i-1][j-1]+1; 当 i = j &gt; 0; Xi == Y[i]</span></span><br><span class="line"><span class="comment">     * c[i][j]=0; 当 i = j &gt; 0; Xi != Y[i]</span></span><br><span class="line"><span class="comment">     * 需要计算 m*n 个子问题的长度 即 任意c[i][j]的长度</span></span><br><span class="line"><span class="comment">     * -- 填表过程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span>[][]c = <span class="keyword">new</span> <span class="keyword">int</span>[X.length()+<span class="number">1</span>][Y.length()+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;=X.length();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=Y.length();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(X.charAt(i-<span class="number">1</span>) == Y.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                c[i][j] = c[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(c[i][j] &gt; maxlen)</span><br><span class="line">                &#123;</span><br><span class="line">                    maxlen = c[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxlen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2017/05/16/algorithmList/gongzu.png" alt></p>
<blockquote>
<p>设dp是走到这一步最少要有的血量，先算出最后一行的dp，然后在从下遍历到上一行，因为每一个点的dp是依赖于正下和右边的dp的，所以遍历结束，就知道了<code>dp[0][0]</code>需要多少的初始血量了</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minHP</span><span class="params">(<span class="keyword">int</span>[][] m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="keyword">null</span> || m.length == <span class="number">0</span> || m[<span class="number">0</span>] == <span class="keyword">null</span> || m[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> row = m.length;</span><br><span class="line">    <span class="keyword">int</span> col = m[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">    dp[row-<span class="number">1</span>][col-<span class="number">1</span>] = m[row-<span class="number">1</span>][col-<span class="number">1</span>] &gt; <span class="number">0</span> ? <span class="number">1</span> : -m[row-<span class="number">1</span>][col-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = col - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">        dp[row-<span class="number">1</span>][j] = Math.max(dp[row-<span class="number">1</span>][j+<span class="number">1</span>] - m[row-<span class="number">1</span>][j], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> down = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        dp[i][col-<span class="number">1</span>] = Math.max(dp[i+<span class="number">1</span>][col-<span class="number">1</span>] - m[i][col-<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = col - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            right = Math.max(dp[i][j+<span class="number">1</span>] - m[i][j], <span class="number">1</span>);</span><br><span class="line">            down = Math.max(dp[i+<span class="number">1</span>][j] - m[i][j], <span class="number">1</span>);</span><br><span class="line">            dp[i][j] = Math.min(right,down);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] m1 = &#123;-<span class="number">2</span>,-<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] m2 = &#123;-<span class="number">5</span>,-<span class="number">10</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] m3 = &#123;<span class="number">0</span>,<span class="number">30</span>,-<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[][] n = &#123;m1,m2,m3&#125;;</span><br><span class="line">    System.out.println(minHP(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><blockquote>
<p>尝试一下，如果失败则回退到之前的逻辑</p>
</blockquote>
<p>八皇后</p>
<p>在8*8的棋盘上要求放8个棋子，而且他们互不在同一行同一列同一斜线</p>
<blockquote>
<p>先放8个不同的行，然后遍历放列，每次遍历判断是否和之前的不在同一列同一斜线</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一共有多少个皇后（此时设置为8皇后在8X8棋盘，可以修改此值来设置N皇后问题）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> max = <span class="number">8</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该数组保存结果，第一个皇后摆在array[0]列，第二个摆在array[1]列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> WolfQueen().check(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * n代表当前是第几个皇后</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment"> * 皇后n在array[n]列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//终止条件是最后一行已经摆完，由于每摆一步都会校验是否有冲突，所以只要最后一行摆完，说明已经得到了一个正确解</span></span><br><span class="line">    <span class="keyword">if</span> (n == max) &#123;</span><br><span class="line">        print();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从第一列开始放值，然后判断是否和本行本列本斜线有冲突，如果OK，就进入下一行的逻辑</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">        array[n] = i;</span><br><span class="line">        <span class="keyword">if</span> (judge(n)) &#123;</span><br><span class="line">            check(n + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        System.out.print(array[i] + <span class="number">1</span> + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://barry215.github.io/2017/05/06/git-learn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="frank">
      <meta itemprop="description" content="总有一天你是我的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="麦金">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/05/06/git-learn/" class="post-title-link" itemprop="url">Git命令篇</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-05-06 15:18:24" itemprop="dateCreated datePublished" datetime="2017-05-06T15:18:24+08:00">2017-05-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-12 18:15:40" itemprop="dateModified" datetime="2019-05-12T18:15:40+08:00">2019-05-12</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>虽然公司里面用SVN，但是为了探索更好的团队协作方式，我觉得有必要再把Git弄懂一些。就像是石墨文档一样，提高团队协作效率才是第一生产力嘛。在这篇文章中，我尽可能地记录多数情况下会用到的命令和正确的协作方式</p>
</blockquote>
<h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><p><img src="/2017/05/06/git-learn/git2.png" style="width: 700px;"></p>
<blockquote>
<p>本地的git本地结构由这三个部分组成，第一个是工作目录，第二个是暂存区，第三个本地仓库</p>
</blockquote>
<p>基本命令：</p>
<p>初始化：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看git版本</span></span><br><span class="line">git version</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">创建</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">配置email</span></span><br><span class="line">git config --global user.email "you@example.com" </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">配置用户名</span></span><br><span class="line">git config --global user.name "Name" </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">取消某一配置项</span></span><br><span class="line">git config --unset user.name</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看配置列表</span></span><br><span class="line">git config --list</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看配置</span></span><br><span class="line">cat ~/.gitconfig</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">配置github密钥，生成id_rsa和id_rsa.pub</span></span><br><span class="line">ssh-keygen -t rsa -b 4096 -C "ynkonghao@gmail.com"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">测试ssh通道</span></span><br><span class="line">ssh -T git@github.com</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">全局设置git大小写敏感</span></span><br><span class="line">git config --global core.ignorecase false</span><br></pre></td></tr></table></figure>
<p>克隆：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">克隆本地仓库</span></span><br><span class="line">git clone /path/to/repository</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">克隆远端仓库</span></span><br><span class="line">git clone username@host:/path/to/repository</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">克隆远程某个分支</span></span><br><span class="line">git clone -b 远程分支 git地址</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">git clone .git地址</span><br><span class="line"></span><br><span class="line">git branch -a 先查看当前远端分支情况</span><br><span class="line"></span><br><span class="line">git checkout origin/xxx  选择远端xxx分支</span><br><span class="line"></span><br><span class="line">git branch xxx  创建本地xxx分支</span><br><span class="line"></span><br><span class="line">git checkout xxx  选择新创建的分支就可以了。</span><br></pre></td></tr></table></figure>
<p>添加：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">添加指定文件到暂存区</span></span><br><span class="line">git add &lt;filename&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">添加所有文件到暂存区</span></span><br><span class="line">git add *</span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">显示有变更的文件</span></span><br><span class="line">git status</span><br></pre></td></tr></table></figure>
<p>提交：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">提交文件到本地仓库</span></span><br><span class="line">git commit -m "代码提交信息"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">提交文件到本地仓库，只处理跟踪过的文件，未跟踪过的文件不会提交</span></span><br><span class="line">git commit -a -m "代码提交信息"</span><br></pre></td></tr></table></figure>
<p>删除：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">直接删除已commit的文件</span></span><br><span class="line">git rm [file]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">保留文件，但是删除跟踪</span></span><br><span class="line">git rm --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">强制把已add但是还未commit的删除</span></span><br><span class="line">gir rm -f [file]</span><br></pre></td></tr></table></figure>
<p>远程：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">将你的仓库连接到某个远程服务器</span></span><br><span class="line">git remote add origin [server]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">显示所有远程仓库</span></span><br><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">显示某个远程仓库的信息</span></span><br><span class="line">git remote show [remote]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">增加一个新的远程仓库，并命名</span></span><br><span class="line">git remote add origin git地址</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">删除远程仓库</span></span><br><span class="line">git remote remove origin</span><br></pre></td></tr></table></figure>
<p>更新&amp;推送：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">更新远程仓库的所有变动</span></span><br><span class="line">git fetch [remote]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">取回远程仓库的变化，并与当前分支合并</span></span><br><span class="line">git pull [remote] [branch] = git fetch origin + git merge origin/branch</span><br><span class="line"><span class="meta">#</span><span class="bash">抓取最新版本到本地仓库+把工作区更新合并</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">取回origin主机的next分支，与本地的master分支合并</span></span><br><span class="line">git pull origin next:master</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">从远程拉取分支到本地</span></span><br><span class="line">git pull origin iot:iot</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它</span></span><br><span class="line">git fetch origin + git reset --hard origin/master</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">将该分支推送到远端仓库，如origin</span></span><br><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class="line">git push origin &lt;本地远程名一样&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line">git push [remote] --force</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">强制推送本地master到远程master</span></span><br><span class="line">git push -f master master</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">推送所有分支到远程仓库</span></span><br><span class="line">git push [remote] --all</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">当前分支与远程分支之间建立追踪关系，以后直接git push</span></span><br><span class="line">git push --set-upstream branch origin/branch  </span><br><span class="line">git branch --set-upstream-to=origin/remote_branch  your_branch</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">推送本地分支到远程的remote_branch分支并建立关联</span></span><br><span class="line">git push --set-upstream origin remote_branch</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">设置为默认远程，以后直接git push</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<p>分支：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">列出所有本地分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">列出所有远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -r</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">列出所有本地分支和远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">新建一个分支，但依然停留在当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch [branch-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">删除分支</span></span><br><span class="line">git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">指定master分支追踪origin/next分支</span></span><br><span class="line">git branch --set-upstream master origin/next</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">把本地分支与远程分支关联</span></span><br><span class="line">git branch --set-upstream-to origin/next</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">切换到远程的某一分支</span></span><br><span class="line">git checkout -b dev origin/dev</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看本地远程分支对应情况</span></span><br><span class="line">git branch -vv</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">重命名远程分支对应的本地分支</span></span><br><span class="line">git branch -m oldName newName</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">删除远程分支</span></span><br><span class="line">git push --delete origin oldName</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">上传新命名的本地分支</span></span><br><span class="line">git push origin newName</span><br></pre></td></tr></table></figure>
<p>切换：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">新建一个分支，并切换到该分支</span></span><br><span class="line">git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">如预发布分支是从Develop分支上面分出来的，并切换到该分支</span></span><br><span class="line">git checkout -b release-1.2 develop</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">切换分支，并更新工作区</span></span><br><span class="line">git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">切换到上一个分支</span></span><br><span class="line">git checkout -</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">恢复暂存区的所有文件到工作区</span></span><br><span class="line">git checkout .</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">恢复暂存区的指定文件到工作区，即丢弃工作区修改</span></span><br><span class="line">git checkout -- [file]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">文件从本地仓库复制到工作区</span></span><br><span class="line">git checkout HEAD -- [file]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line">git checkout [commit] [file]</span><br></pre></td></tr></table></figure>
<p>标签：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">列出所有tag</span></span><br><span class="line">git tag</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">新建一个tag在当前commit</span></span><br><span class="line">git tag [tag]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送tag到远端</span></span><br><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure>
<p>合并：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">合并其他分支到你的当前分支</span></span><br><span class="line">git merge [branch]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">取消快进式合并-fast-farward merge</span></span><br><span class="line">git merge --no-ff [branch]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">所有的合并都有可能会有冲突，冲突手动解决之后，需要add以标记合并成功</span></span><br><span class="line">git add &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看本地仓库提交日志</span></span><br><span class="line">git log</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看的同时显示每次提交内容的差异</span></span><br><span class="line">git log -p</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">只看frank作者的提交日志</span></span><br><span class="line">git log --author=frank</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">一个压缩后的每一条提交记录只占一行的输出</span></span><br><span class="line">git log --pretty=oneline</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">通过 ASCII 艺术的树形结构来展示所有的分支</span></span><br><span class="line">git log --graph --oneline --decorate --all</span><br></pre></td></tr></table></figure>
<p>区别：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">显示暂存区和工作区的差异</span></span><br><span class="line">git diff [filepath..]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line">git diff HEAD [filepath..]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">在合并改动之前可以预览分支间的差异</span></span><br><span class="line">git diff &lt;source_branch&gt; &lt;target_branch&gt; [filepath..]</span><br><span class="line">git diff master origin/master [filepath..] </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">比较本地工作区与运程版本库</span></span><br><span class="line">git diff origin/master [filepath..]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">比较暂存区和版本库的差异</span></span><br><span class="line">git diff --cached [filepath..]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">比较暂存区与运程版本库</span></span><br><span class="line">git diff --cached origin/master [filepath..]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">比较工作区与指定commit-id的差异</span></span><br><span class="line">git diff commit-id  [filepath..] </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">比较两个commit-id之间的差异</span></span><br><span class="line">git diff commit-id commit-id</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">比较暂存区与指定commit-id的差异</span></span><br><span class="line">git diff --cached commit-id [filepath..] </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看某次提交内容</span></span><br><span class="line">git show commit-id</span><br></pre></td></tr></table></figure>
<p>撤销：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">重置暂存区，与上一次commit保持一致</span></span><br><span class="line">git reset</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">重置暂存区，但工作区不变</span></span><br><span class="line"><span class="meta">#</span><span class="bash">(HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，往上100个版本写成HEAD~100)</span></span><br><span class="line">git reset HEAD [file]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class="line">git reset --hard</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line">git reset [commit]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line">git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line">git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">仅仅只是撤销已提交的版本库，不会修改暂存区和工作区</span></span><br><span class="line">git reset --soft [commit]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">仅仅只是撤销已提交的版本库和暂存区，不会修改工作区</span></span><br><span class="line">git reset --mixed [commit]</span><br></pre></td></tr></table></figure>
<p>备忘<br>这是让master分支上的改动merge到zhangli分支<br><img src="/2017/05/06/git-learn/merge_rem.png" alt></p>
<p>参考资料</p>
<p><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">常用 Git 命令清单</a></p>
<p><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的Git教程</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://barry215.github.io/2017/04/04/mysql-review/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="frank">
      <meta itemprop="description" content="总有一天你是我的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="麦金">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/04/04/mysql-review/" class="post-title-link" itemprop="url">MySQL持续更新</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-04-04 19:53:23" itemprop="dateCreated datePublished" datetime="2017-04-04T19:53:23+08:00">2017-04-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-24 00:44:33" itemprop="dateModified" datetime="2017-08-24T00:44:33+08:00">2017-08-24</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Mysql/" itemprop="url" rel="index"><span itemprop="name">Mysql</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>MySQL是我比较常用的数据库，要持续刷新对它的认知呀</p>
</blockquote>
<h3 id="数据库事务的四个属性（ACID）"><a href="#数据库事务的四个属性（ACID）" class="headerlink" title="数据库事务的四个属性（ACID）"></a>数据库事务的四个属性（ACID）</h3><p><strong>原子性</strong>是指事务包含的所有操作要么全部成功，要么全部失败回滚</p>
<p><strong>一致性</strong>是指事务必须使数据库从一个一致性状态变换到另一个一致性状态</p>
<p><strong>隔离性</strong>是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p>
<p><strong>持久性</strong>是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
<h3 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h3><p><strong>脏读</strong>是指一个线程中的事务读取到了另外一个线程中未提交的数据。</p>
<p><strong>不可重复读（虚读）</strong>是指一个线程中的事务读取到了另外一个线程中提交的update的数据，两次读的不一样</p>
<p><strong>幻读</strong>是指一个线程中的事务读取到了另外一个线程中提交的insert或delete的数据，两次读的不一样</p>
<p>第1类丢失更新：事务A撤销时，把已经提交的事务B的更新数据覆盖了。</p>
<p>第2类丢失更新：事务A覆盖事务B已经提交的数据，造成事务B所做的操作丢失。</p>
<table>
<thead>
<tr>
<th style="text-align:center">隔离级别</th>
<th style="text-align:center">脏读（Dirty Read）</th>
<th style="text-align:center">不可重复读（NonRepeatable Read）</th>
<th style="text-align:center">幻读（Phantom Read）</th>
<th style="text-align:center">第一类丢失更新</th>
<th style="text-align:center">第二类丢失更新</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">未提交读（Read uncommitted）</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">已提交读（Read committed）</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">可重复读（Repeatable read）</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:center">可串行化（Serializable ）</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
</tbody>
</table>
<p>级别越高，数据越安全，但性能越低，×表示不允许，√表示允许</p>
<p>在MySQL数据库中，支持上面四种隔离级别，默认的为Repeatable read (可重复读)，有可能发现幻读；而在Oracle数据库中，只支持Serializable (串行化)级别和Read committed (读已提交)这两种级别，其中默认的为Read committed级别。</p>
<h4 id="不可重复读（虚读）和幻读的差别"><a href="#不可重复读（虚读）和幻读的差别" class="headerlink" title="不可重复读（虚读）和幻读的差别"></a>不可重复读（虚读）和幻读的差别</h4><p>从总的结果来看, 似乎两者都表现为两次读取的结果不一致.<br>但如果你从控制的角度来看, 两者的区别就比较大：<br>对于前者, 只需要<strong>锁住满足条件的记录</strong><br>对于后者, 要<strong>锁住满足条件及其相近的记录</strong></p>
<h3 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h3><p>第一范式：强调的是列的原子性，即列不能够再分成其他几列</p>
<p>第二范式：一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的其中一部分。</p>
<p>第三范式：非主键列必须直接依赖于主键，不能存在传递依赖</p>
<h3 id="sql优化的经验"><a href="#sql优化的经验" class="headerlink" title="sql优化的经验"></a>sql优化的经验</h3><ul>
<li>SELECT子句中避免使用 <code>*</code></li>
<li>用TRUNCATE替代DELETE</li>
<li>sql语句用大写的；因为oracle总是先解析sql语句，把小写的字母转换成大写的再执行</li>
</ul>
<h3 id="触发器优点和缺点"><a href="#触发器优点和缺点" class="headerlink" title="触发器优点和缺点"></a>触发器优点和缺点</h3><p>优点：自动执行，级联更新</p>
<p>缺点：不好维护，性能一般</p>
<h3 id="存储过程优点和缺点"><a href="#存储过程优点和缺点" class="headerlink" title="存储过程优点和缺点"></a>存储过程优点和缺点</h3><p>优点：可以封装数据逻辑和业务规则，减少sql传输的时间，存储过程在第一次执行时进行语法检查和编译，快速执行</p>
<p>缺点：代码可复用性差</p>
<p>触发器和存储过程在复杂的程序里尽量不要多用</p>
<h3 id="JDBC操作数据库步骤"><a href="#JDBC操作数据库步骤" class="headerlink" title="JDBC操作数据库步骤"></a>JDBC操作数据库步骤</h3><p>下面的代码以连接本机的Oracle数据库为例，演示JDBC操作数据库的步骤。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">加载驱动</span><br><span class="line">Class.forName(<span class="string">"oracle.jdbc.driver.OracleDriver"</span>);</span><br><span class="line"></span><br><span class="line">创建连接</span><br><span class="line">Connection con = DriverManager.getConnection(<span class="string">"jdbc:oracle:thin:@localhost:1521:orcl"</span>, <span class="string">"scott"</span>, <span class="string">"tiger"</span>);</span><br><span class="line"></span><br><span class="line">创建语句</span><br><span class="line">PreparedStatement ps = con.prepareStatement(<span class="string">"select * from emp where sal between ? and ?"</span>);</span><br><span class="line">ps.setInt(<span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">ps.setInt(<span class="number">2</span>, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">执行语句</span><br><span class="line">ResultSet rs = ps.executeQuery();</span><br><span class="line"></span><br><span class="line">处理结果</span><br><span class="line"><span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">    System.out.println(rs.getInt(<span class="string">"empno"</span>) + <span class="string">" - "</span> + rs.getString(<span class="string">"ename"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">关闭资源</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(con != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            con.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Statement和PreparedStatement有什么区别？哪个性能更好？</strong></p>
<p>①PreparedStatement接口代表预编译的语句，它主要的优势在于可以减少SQL的编译错误并增加SQL的安全性，防止注入</p>
<blockquote>
<ol>
<li>在使用参数化查询的情况下，数据库系统（eg:MySQL）不会将参数的内容视为SQL指令的一部分来处理，而是在数据库完成SQL指令的编译后，才套用参数运行，因此就算参数中含有破坏性的指令，也不会被数据库所运行</li>
<li>数据库系统会对sql语句进行预编译处理（如果JDBC驱动支持的话），预处理语句将被预先编译好，这条预编译的sql查询语句能在将来的查询中重用，这样一来，它比Statement对象生成的查询速度更快。</li>
</ol>
</blockquote>
<p>②PreparedStatement中的SQL语句是可以带参数的，采用占位符，避免了用字符串连接拼接SQL语句的麻烦和不安全</p>
<p>③当批量处理SQL或频繁执行相同的查询时，PreparedStatement有明显的性能上的优势，由于数据库可以将编译优化后的SQL语句缓存起来，下次执行相同结构的语句时就会很快（不用再次编译和生成执行计划）</p>
<p><a href="http://www.importnew.com/5006.html" target="_blank" rel="noopener">http://www.importnew.com/5006.html</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreparedStmtExample</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Connection conn = DriverManager.getConnection(<span class="string">"mysql:\\localhost:1520"</span>, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br><span class="line">        PreparedStatement preStatement = conn.prepareStatement(<span class="string">"select distinct loan_type from loan where bank=?"</span>);</span><br><span class="line">        preStatement.setString(<span class="number">1</span>, <span class="string">"Citibank"</span>);</span><br><span class="line"> </span><br><span class="line">        ResultSet result = preStatement.executeQuery();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span>(result.next())&#123;</span><br><span class="line">            System.out.println(<span class="string">"Loan Type: "</span> + result.getString(<span class="string">"loan_type"</span>));</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">Output:</span><br><span class="line">Loan Type: Personal Loan</span><br><span class="line">Loan Type: Auto Loan</span><br><span class="line">Loan Type: Home Loan</span><br><span class="line">Loan Type: Gold Loan</span><br></pre></td></tr></table></figure>
<h3 id="联合（复合）索引"><a href="#联合（复合）索引" class="headerlink" title="联合（复合）索引"></a>联合（复合）索引</h3><h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>索引是key index (a,b,c). 可以支持a | a,b| a,b,c 3种组合进行查找，但不支持 b,c或a,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。</p>
<p>要注意的是a，b，c的顺序可以乱调，mysql会调成合适的顺序，但是复合索引的最前面的字段a最好是经常出现在where条件中的</p>
<p>mysql的索引如果单索引在联合索引之前定义，那么只会用单索引而不会用联合索引了</p>
<p><strong>OR操作是不能用联合索引的</strong></p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>MySQL只对&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN使用索引</li>
<li>MySQL对LIKE ‘%name%’不使用索引，对LIKE ‘name%’使用索引</li>
</ul>
<h4 id="优化索引"><a href="#优化索引" class="headerlink" title="优化索引"></a>优化索引</h4><ul>
<li><p>索引不会包含有NULL值的列</p>
<p>只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。</p>
</li>
<li><p>使用短索引</p>
<p>对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。</p>
</li>
<li><p>索引列排序</p>
<p>MySQL查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。</p>
</li>
<li><p>like语句操作</p>
<p>一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。</p>
</li>
<li><p>不要在列上进行运算</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(adddate)&lt;<span class="number">2007</span>;</span><br></pre></td></tr></table></figure>
<p>将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> adddate&lt;<span class="string">'2007-01-01'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不使用NOT IN和&lt;&gt;操作</p>
<p>这个很简单，因为这两个操作不会使用索引。</p>
</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>索引虽然能提高查询性能，但是泛滥使用也会导致一些问题：</p>
<ul>
<li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件</li>
<li>建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。</li>
</ul>
<h4 id="参考路径"><a href="#参考路径" class="headerlink" title="参考路径"></a>参考路径</h4><p><a href="http://kael-aiur.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95.html" target="_blank" rel="noopener">数据库索引</a></p>
<h3 id="松散索引"><a href="#松散索引" class="headerlink" title="松散索引"></a>松散索引</h3><p>实际上就是当MySQL 完全利用索引扫描来实现GROUP BY 的时候，并不需要扫描所有满足条件的索引键即可完成操作得出结果。</p>
<p>要利用到松散索引扫描实现GROUP BY，需要至少满足以下几个条件：</p>
<ul>
<li>GROUP BY 条件字段必须在同一个索引中最前面的连续位置；</li>
<li>在使用GROUP BY 的同时，只能使用MAX 和MIN 这两个聚合函数；</li>
<li>如果引用到了该索引中GROUP BY 条件之外的字段条件的时候，必须以常量形式存在；</li>
</ul>
<h4 id="为什么松散索引扫描的效率会很高"><a href="#为什么松散索引扫描的效率会很高" class="headerlink" title="为什么松散索引扫描的效率会很高"></a>为什么松散索引扫描的效率会很高</h4><p>因为在没有WHERE 子句，也就是必须经过全索引扫描的时候， 松散索引扫描需要读取的键值数量与分组的组数量一样多，也就是说比实际存在的键值数目要少很多。而在WHERE 子句包含范围判断式或者等值表达式的时候， 松散索引扫描查找满足范围条件的每个组的第1 个关键字，并且再次读取尽可能最少数量的关键字。</p>
<h3 id="紧凑索引"><a href="#紧凑索引" class="headerlink" title="紧凑索引"></a>紧凑索引</h3><p>紧凑索引扫描实现GROUP BY 和松散索引扫描的区别主要在于他需要在扫描索引的时候，读取所有满足条件的索引键，然后再根据读取的数据来完成GROUP BY 操作得到相应结果。</p>
<h3 id="索引合并"><a href="#索引合并" class="headerlink" title="索引合并"></a>索引合并</h3><blockquote>
<p>index merge：对多个索引分别进行条件扫描，然后将它们各自的结果进行合并</p>
<p>MySQL5.0之前，<strong>一个表一次只能使用一个索引</strong>，无法同时使用多个索引分别进行条件扫描。但是从5.1开始，引入了 index merge 优化技术，对<strong>同一个表可以使用多个索引</strong>分别进行条件扫描。</p>
</blockquote>
<p>在mysql 5.1版本之前只要用了or，sql就不会用任何索引；<br>5.1之后依旧不能用联合索引，但是两个字段都建了索引的话，会用index_merge，但是如果只有其中一个字段建了索引，那就只会用那个索引</p>
<p>在使用or的时候，如果那两个字段都有索引，那么mysql会自动选择是不是索引合并比全表扫描好</p>
<h4 id="index-intersect-merge"><a href="#index-intersect-merge" class="headerlink" title="index intersect merge"></a>index intersect merge</h4><p>index intersect merge就是多个索引条件（单索引和联合索引）扫描得到的结果进行交集运算。显然在多个索引提交之间是 AND 运算时，才会出现 index intersect merge. 但是一般都可以用联合索引替代。</p>
<h4 id="index-uion-merge"><a href="#index-uion-merge" class="headerlink" title="index uion merge"></a>index uion merge</h4><p>index uion merge就是多个索引条件扫描，对得到的结果进行并集运算，显然是多个条件之间进行的是 OR 运算</p>
<h3 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h3><p>辅助索引又叫二级索引，他是指除了主键索引之外的索引，innodb的主键索引是聚簇索引，数据和索引放在一起，但是辅助索引是非聚簇索引，myisam的主键索引和辅助索引一样都是非聚簇索引</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://barry215.github.io/2017/04/04/mybatis-review/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="frank">
      <meta itemprop="description" content="总有一天你是我的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="麦金">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/04/04/mybatis-review/" class="post-title-link" itemprop="url">Mybatis基础回顾</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-04-04 19:40:09" itemprop="dateCreated datePublished" datetime="2017-04-04T19:40:09+08:00">2017-04-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-09 21:46:59" itemprop="dateModified" datetime="2017-08-09T21:46:59+08:00">2017-08-09</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Mybatis/" itemprop="url" rel="index"><span itemprop="name">Mybatis</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>用了很久的Mybatis，但是一直没有全面去学过，这次补一下基础吧</p>
</blockquote>
<h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><p>当使用Mybatis时，首先用字节流通过Resource将配置文件读入，然后通过SqlSessionFactoryBuilder().build方法创建SqlSessionFactory，然后再通过sqlSessionFactory.openSession()方法创建一个sqlSession。Mybatis通过xml文件映射到各实体类的Mapper接口，Mapper接口中配置了每个类对数据库所需进行的sql语句映射。<br>经历了Mybatis初始化 –&gt;创建SqlSession –&gt;运行SQL语句 返回结果三个过程</p>
<h3 id="mybatis缓存概念"><a href="#mybatis缓存概念" class="headerlink" title="mybatis缓存概念"></a>mybatis缓存概念</h3><p>当我们使用Mybatis进行数据库的操作时候，MyBatis会开启一个会话时，然后创建一个新的<strong>SqlSession</strong>对象，<strong>SqlSession</strong>对象中会有一个新的<strong>Executor</strong>对象，<strong>Executor</strong>对象中持有一个新的<strong>PerpetualCache</strong>对象；当会话结束时，<strong>SqlSession</strong>对象及其内部的<strong>Executor</strong>对象还有<strong>PerpetualCache</strong>对象也一并释放掉。</p>
<p>一级缓存：（HashMap来实现，并没有对<strong>HashMap</strong>的容量和大小进行限制，key为hashCode+sqlId+Sql语句。value为从查询出来映射生成的java对象）</p>
<p>对SqlSession的操作mybatis内部都是通过Executor来执行的，Executor在执行数据库查询的时候总是先查看缓存中是否存在，若不存在则查询数据库。</p>
<blockquote>
<p>SqlSession是对外接口，Executor是内部执行器</p>
</blockquote>
<p>二级缓存：</p>
<p>二级缓存的范围更大，根据<code>namespace</code>划分的，多个<code>SqlSession</code>可以共享一个<code>UserMapper</code>的二级缓存区域。</p>
<p>每一个<code>namespace</code>的<code>mapper</code>有一个二级缓存区域。也就是说如果两个<code>mapper</code>的<code>namespace</code>相同，那么这两个<code>mapper</code>执行<code>sql</code>查询到的数据将存储在一个二级缓存区域中。</p>
<blockquote>
<p>mybatis的二级缓存是通过CacheExecutor实现的。CacheExecutor其实是Executor的代理对象。所有的查询操作，在CacheExecutor中都会先匹配缓存中是否存在，不存在则查询数据库。二级缓存是可以跨SqlSession的</p>
</blockquote>
<p>MyBatis查询数据的顺序是：</p>
<p>二级缓存 ———&gt; 一级缓存——&gt; 数据库</p>
<p><img src="/2017/04/04/mybatis-review/mybatis.png" alt></p>
<p>要使用Mybatis的二级缓存，需要对Mybatis进行配置，配置分三步</p>
<ul>
<li><p>Mybatis全局配置中启用二级缓存配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在对应的Mapper.xml中配置cache节点</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"userMapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cache</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在对应的select查询节点中添加useCache=true</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultMap</span>=<span class="string">"user"</span> <span class="attr">useCache</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">  select * from users where id=#&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>实体类要实现序列化接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">  <span class="comment">//属性......</span></span><br><span class="line">  <span class="comment">//getter and setter......  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>一级缓存是sqlSession级别的缓存。在操作数据库时需要构造sqlSession对象，在对象中有一个数据结构(HashMap),用于存储缓存数据。不同的sqlSession之间的缓存区域(HashMap)是互不影响的。</p>
<p>二级缓存是mapper级别的缓存，多个sqlSession去操作同一个Mapper的sql语句，多个SqlSession可以公用二级缓存，二级缓存是跨sqlSession的。</p>
<h3 id="MyBatis和Hibernate各有什么优缺点"><a href="#MyBatis和Hibernate各有什么优缺点" class="headerlink" title="MyBatis和Hibernate各有什么优缺点?"></a>MyBatis和Hibernate各有什么优缺点?</h3><p><code>Hibernate</code>的优点是它是一个完全的<code>ORM框架</code>，使用<code>Hibernate</code>可以做到不用手写SQL，而且无须关心使用何种数据库，可移植性较好，当需要更变数据库时需要做的修改很少甚至为0。其缺点是需要根据数据库的设计在实体进行又一次的配置，且帮程序员做了太多事，如果需要进行调优的话需要对<code>Hibernate</code>有比较深的了解。<br><code>MyBatis</code>的优缺点差不多和<code>Hibernate</code>相反，我们需要<code>手写SQL</code>语句和<code>配置结果集和实体类的映射</code>，即使是简单的单表操作也需要写SQL(可以通过<code>拦截器</code>来实现CommonMapper，或者可以使用生成器来生成代码)，因此<code>MyBatis</code>要进行SQL调优也简单直接。其次是<code>MyBatis</code>的<code>二级缓存</code>功能较弱，是针对<code>namespace</code>的。</p>
<h3 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h3><p><a href="http://www.jianshu.com/p/7dd95270864c" target="_blank" rel="noopener">MyBatis系列之动态SQL语句</a></p>
<p><a href="http://www.ctolib.com/topics-102259.html" target="_blank" rel="noopener">MyBatis中的OGNL教程</a></p>
<h3 id="TypeHandler"><a href="#TypeHandler" class="headerlink" title="TypeHandler"></a>TypeHandler</h3><blockquote>
<p>TypeHandler可以让数据库字段类型和Java类做一个映射，就好像默认text类可以转成String，但是可以用TypeHandler来转成Java自定义类型</p>
</blockquote>
<p><a href="http://www.jianshu.com/p/17313a00a102" target="_blank" rel="noopener">http://www.jianshu.com/p/17313a00a102</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://barry215.github.io/2017/03/27/java-thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="frank">
      <meta itemprop="description" content="总有一天你是我的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="麦金">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/03/27/java-thread/" class="post-title-link" itemprop="url">Java多线程详解</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-03-27 10:48:22" itemprop="dateCreated datePublished" datetime="2017-03-27T10:48:22+08:00">2017-03-27</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-02-06 14:07:34" itemprop="dateModified" datetime="2018-02-06T14:07:34+08:00">2018-02-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>多线程之前了解的有点乱，特此整理</p>
</blockquote>
<h3 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h3><p><strong>公平性：</strong></p>
<ol>
<li>公平锁：线程按照他们发出请求的顺序来获得锁。如果有另一个线程持有这个锁或者有其他线程在队列中等待这个锁，那么新发出请求的线程将放入队列中。</li>
<li>非公平锁：非公平锁允许“插队”：当一个线程请求非公平的锁时，如果在发出请求的同时该锁的状态变为可用，那么这个线程将跳过排队队列，直接获取这个锁。</li>
</ol>
<blockquote>
<p>也就是说非公平锁在入队同时可以强锁，如果没抢到就得排队，公平锁只能排队</p>
</blockquote>
<p><strong>悲观／乐观：</strong></p>
<ol>
<li><p>悲观锁：把数据库里的某行数据锁住，或者整张表锁住，不让其他事务访问，数据库里一般会使用排它锁来实现悲观锁，但是因为其他事务不能访问，所以效率很低，适合数据竞争激烈的环境。可以防脏读。</p>
</li>
<li><p>乐观锁：在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。它可以让各事务能够在不产生锁的情况下处理各自影响的那部分数据。</p>
<p>乐观锁是基于CAS实现的，为了解决ABA问题，可以加上version的方法解决</p>
</li>
</ol>
<p><strong>排他(独占)／共享：</strong></p>
<ol>
<li>排他锁：只能有1个线程持有锁,可以有效的防止脏读</li>
<li>共享锁：共享锁不会阻止其他用户读，但是阻止其他的用户写和修改</li>
</ol>
<h5 id="锁状态"><a href="#锁状态" class="headerlink" title="锁状态"></a>锁状态</h5><blockquote>
<p>锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）</p>
</blockquote>
<p><strong>偏向锁：</strong></p>
<p>适合只有一个线程访问同步代码的场景</p>
<p>只要加了一次锁，之后访问里面的临界区都不用再加锁</p>
<p><strong>自旋锁：</strong></p>
<p>自身空循环来等待，然后再CAS请求锁</p>
<p><strong>轻量级锁：</strong></p>
<p>b线程在锁竞争时，发现锁已经被a线程占用，则b线程不进入内核态，让b线程自旋，执行空循环，等待a线程释放锁。如果，完成自旋策略执行CAS换锁操作，发现a线程还是没有释放锁，或者让c线程占用了。则b线程试图将轻量级锁升级为重量级锁。始终得不到锁竞争的线程使用自旋会消耗CPU。</p>
<p><strong>重量级锁：</strong></p>
<p>线程竞争不使用自旋，不会消耗CPU    线程阻塞，响应时间缓慢，适合追求吞吐量,锁占用时间较长</p>
<table>
<thead>
<tr>
<th><strong>锁</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距</td>
<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td>
<td>适用于只有一个线程访问同步块场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度</td>
<td>如果始终得不到索竞争的线程，使用自旋会消耗CPU</td>
<td>追求响应速度，同步块执行速度非常快</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋，不会消耗CPU</td>
<td>线程阻塞，响应时间缓慢</td>
<td>追求吞吐量，同步块执行速度较长</td>
</tr>
</tbody>
</table>
<p><strong>另外</strong></p>
<p>可重入锁：当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2。</p>
<p><strong>速学路径</strong></p>
<p><a href="http://kaimingwan.com/post/java/javanei-zhi-suo-kai-xiao-you-hua-pian-xiang-suo-qing-liang-ji-suo" target="_blank" rel="noopener">http://kaimingwan.com/post/java/javanei-zhi-suo-kai-xiao-you-hua-pian-xiang-suo-qing-liang-ji-suo</a></p>
<h3 id="CAS介绍"><a href="#CAS介绍" class="headerlink" title="CAS介绍"></a>CAS介绍</h3><p>CAS（Compare and Swap）即比较并替换，设计并发算法时常用到的一种技术。返回boolean值。</p>
<p>CAS是通过unsafe类的compareAndSwap方法实现的，是底层实现的原子指令</p>
<p>CAS用户程序不用直接调用，但是automicInteger内实现了这些方法，比如incrementAndGet()方法实际上就是不断循环CAS操作，直到成功</p>
<h4 id="具体说明"><a href="#具体说明" class="headerlink" title="具体说明"></a>具体说明</h4><p>赋值操作即是新值替换旧值，所以先比较现在的值是否为自己所以为的旧值，如果不是，则说明自己发生了脏读。本次操作失败返回false。</p>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p>
<h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p>就是一个变量V，如果变量V初次读取的时候是A，并且在准备赋值的时候检查到它仍然是A，那能说明它的值没有被其他线程修改过了吗？如果在这段期间它的值曾经被改成了B，然后又改回A，那CAS操作就会误认为它从来没有被修改过。</p>
<p>ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1。java并发包中提供了一个带有标记的原子引用类”AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。</p>
<h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p>java.util.concurrent包完全建立在CAS之上的，乐观锁就是基于CAS。</p>
<p>java.util.concurrent.atomic包下的原子操作类都是基于CAS实现的</p>
<h3 id="AQS介绍"><a href="#AQS介绍" class="headerlink" title="AQS介绍"></a>AQS介绍</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">  <span class="comment">// 等待对列的头节点</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line">  <span class="comment">// 等待队列的尾节点</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">  <span class="comment">// 同步状态</span></span><br><span class="line">  <span class="keyword">private</span> valatile <span class="keyword">int</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;<span class="comment">//该节点的状态</span></span><br><span class="line">	<span class="keyword">volatile</span> Node prev;<span class="comment">//同步等待队列前驱节点</span></span><br><span class="line">	<span class="keyword">volatile</span> Node next;<span class="comment">//同步等待队列后继节点</span></span><br><span class="line">	<span class="keyword">volatile</span> Thread thread;<span class="comment">//持有该节点的线程</span></span><br><span class="line">	Node nextWaiter;<span class="comment">//存储condition队列中的后继节点。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tryAcquire()修改状态，获取锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">	selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加入到等待队列，用cas原子替换tail，防止多线程错误</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failur</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不断循环获取队列前一个node，如果是头结点，则再次尝试修改state，获取锁，不然被阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>队列同步器AQS是用来构建锁或其他同步组件的基础框架，内部使用了一个int类型的volatile修饰的state来表示同步状态，通过acquire来尝试修改state的值（未实现），修改成功的线程表示获取到该锁，没有修改成功，或者发现状态state已经是加锁状态，则把当前线程包装成一个node节点，并通过CAS指令插入到FIFO等待队列的队尾。node插入到队尾后该线程不会马上挂起，而是进行自旋操作。如果前一个节点是头结点，他会自旋后再次尝试tryAcquire方法获取锁。只有当前一个节点pred的线程状态位SIGNAL时，当前节点的线程才能被挂起，并等待被唤醒。等待队列的头节点head和尾结点tail都是通过volatile修饰，保证了多个线程之间的可见性。</p>
<h3 id="synchronized介绍"><a href="#synchronized介绍" class="headerlink" title="synchronized介绍"></a>synchronized介绍</h3><p>synchronized是java语言的关键字，由jvm实现的语法级别的锁机制。是一种可重入/非公平/悲观/独占锁。</p>
<p>原理：</p>
<p>synchronized可以对一个代码块或是对一个方法上锁，方法块的原理是使用monitorenter和monitorexit指令，被“锁住”的地方称为临界区。线程执行到 monitorenter 指令时，将会尝试获取对象所对应的 monitor 的所有权，即尝试获得对象的锁，这样其他尝试进入临界区的线程会因无法获取monitor而被阻塞。由于等待另一个线程释放monitor而被阻塞的线程无法被中断。</p>
<p>同步方法 并不是由 monitorenter 和 monitorexit 指令来实现同步的，而是由方法调用指令读取运行时常量池中方法的 ACC_SYNCHRONIZED 标志来隐式实现的</p>
<blockquote>
<p>monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，每个monitorenter必须有一个monitorexit对应。</p>
</blockquote>
<p>Java中的每个对象都可以作为锁。</p>
<blockquote>
<p>任何对象都有一个 monitor 与之关联，当且一个monitor 被持有后，它将处于锁定状态</p>
</blockquote>
<ol>
<li>普通同步方法，锁是当前实例对象。</li>
<li>静态同步方法，锁是当前类的class对象。</li>
<li>同步代码块，锁是括号中的对象。</li>
</ol>
<p>作用于一段代码或方法，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到物理内存中。因此可以保证<strong>可见性</strong>，也能够保证<strong>原子性</strong>，synchronized修饰方法是获得对象锁</p>
<h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="comment">// todo</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写法一修饰的是一个方法，写法二修饰的是一个代码块，但写法一与写法二是等价的，都是锁定了整个方法时的内容。</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadlockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="keyword">new</span> String(<span class="string">"资源1"</span>);</span><br><span class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">"资源2"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Lock(str1, str2), <span class="string">"线程1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Lock(str2, str1), <span class="string">"线程2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String str1;</span><br><span class="line">    <span class="keyword">private</span> String str2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Lock</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.str1 = str1;</span><br><span class="line">        <span class="keyword">this</span>.str2 = str2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"运行"</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (str1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"锁住"</span> + str1);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (str2) &#123;</span><br><span class="line">                    <span class="comment">// 执行不到这里</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"锁住"</span> + str2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="效率低"><a href="#效率低" class="headerlink" title="效率低"></a>效率低</h4><p>监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从<strong>用户态</strong>转换到<strong>核心态</strong>，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因</p>
<h4 id="备注-1"><a href="#备注-1" class="headerlink" title="备注"></a>备注</h4><ol>
<li>synchronized关键字不能继承。</li>
<li>在定义接口方法时不能使用synchronized关键字。</li>
<li>构造方法不能使用synchronized关键字，但可以使用synchronized代码块来进行同步。</li>
<li>一个线程访问一个对象中的synchronized(this)同步代码块时，其他试图访问该对象的线程将被阻塞。</li>
</ol>
<p><a href="https://segmentfault.com/a/1190000004453860" target="_blank" rel="noopener">synchronized实现死锁</a></p>
<h3 id="Lock介绍"><a href="#Lock介绍" class="headerlink" title="Lock介绍"></a>Lock介绍</h3><p>Lock是Java 5以后引入的新的API</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取锁，否则会一直等待</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;    </span><br><span class="line">    <span class="comment">//获取锁，否则一直等待，但是等待状态可以被其他线程中断</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">//尝试获得锁，没抢到直接返回失败</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;        </span><br><span class="line">    <span class="comment">//尝试获取锁，没抢到则会等待一段时间，等待状态可以被其他线程中断</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//生成锁的条件变量，线程获取锁后，可以等待或者通知该条件变量</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Lock lock= ...;<span class="comment">//获取锁</span></span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="comment">//处理任务</span></span><br><span class="line">	&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>synchronized和Lock区别</strong></p>
<p><strong>相同点</strong></p>
<p>Lock 能完成synchronized所实现的所有功能</p>
<p><strong>不同点</strong></p>
<ul>
<li>synchronized会自动释放锁，而Lock一定要求程序员手工释放，且最好在finally 块中释放（否则会出现死锁）</li>
<li>通过Lock可以知道有没有成功获取锁，而synchronized却无法办到</li>
<li>synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生。Lock在发生异常时，如果没有主动通过unLock()方法去释放锁，则很可能造成死锁的现象，因此使用Lock时需要在finally块中释放锁</li>
</ul>
<h3 id="ReentrantLock介绍"><a href="#ReentrantLock介绍" class="headerlink" title="ReentrantLock介绍"></a>ReentrantLock介绍</h3><p>ReentrantLock实现了 Lock 接口，并提供了与 synchronized 相同的互斥和内存可见性</p>
<p>ReentrantLock 是可重入锁，根据构造器传入的布尔值来决定是否要公平锁</p>
<p>ReentrantLock是基于AQS实现的</p>
<h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><p>可重入锁中可重入表示的意义在于<strong>对于同一个线程，可以继续调用加锁的方法，而不会被挂起</strong>。可重入锁内部维护一个计数器，对于同一个线程调用lock方法，计数器+1，调用unlock方法，计数器-1</p>
<p>举例：在一个加锁方法execute中调用另外一个加锁方法anotherLock并不会被挂起，可以直接调用</p>
<blockquote>
<p>调用execute方法时计数器+1，然后内部又调用了anotherLock方法，计数器+1，变成了2</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" do something synchronize"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            anotherLock();</span><br><span class="line">            Thread.sleep(<span class="number">5000l</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(Thread.currentThread().getName() + <span class="string">" interrupted"</span>);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anotherLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" invoke anotherLock"</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span> <span class="keyword">do</span> something synchronize</span><br><span class="line">Thread-<span class="number">0</span> invoke anotherLock</span><br><span class="line"><span class="comment">// 隔了5秒钟 输入下面</span></span><br><span class="line">Thread-<span class="number">1</span> <span class="keyword">do</span> something synchronize</span><br><span class="line">Thread-<span class="number">1</span> invoke anotherLock</span><br></pre></td></tr></table></figure>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ol>
<li>lock()，如果获取了锁立即返回，如果别的线程持有锁，当前线程则一直处于休眠状态，直到获取锁</li>
<li>tryLock()，如果获取了锁立即返回true，如果别的线程正持有锁，立即返回false；</li>
<li>tryLock(long timeout,TimeUnit unit)，如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false；</li>
<li>lockInterruptibly，如果获取了锁定立即返回，如果没有获取锁定，当前线程处于休眠状态，这期间当前线程可以被中断。举个粟子，当A，B线程都试图使用lockInterruptibly()获取锁时，如果A获得了锁，B线程正在等待获取锁，则可以调用threadB.interrupt()能够中断线程B的等待。</li>
</ol>
<h4 id="举例-3"><a href="#举例-3" class="headerlink" title="举例"></a>举例</h4><p>线程A和B都要获取对象O的锁定，假设A获取了对象O锁，B将等待A释放对O的锁定，如果使用 synchronized ，如果A不释放，B将一直等下去，不能被中断如果 使用ReentrantLock，如果A不释放，可以使B在等待了足够长的时间以后，中断等待，而干别的事情</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Condition condition = lock.newCondition();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">while</span>(条件判断表达式) &#123;</span><br><span class="line">      condition.await();</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 处理逻辑</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="和synchronized区别"><a href="#和synchronized区别" class="headerlink" title="和synchronized区别"></a>和synchronized区别</h4><table>
<thead>
<tr>
<th></th>
<th>synchronized</th>
<th>ReentrantLock</th>
</tr>
</thead>
<tbody>
<tr>
<td>获取锁方式</td>
<td>抢锁失败只能无限等待</td>
<td>提供多种等待锁方式，可以中断正在等候获取一个锁的线程</td>
</tr>
<tr>
<td></td>
<td></td>
<td>可以限制等待超时</td>
</tr>
<tr>
<td></td>
<td></td>
<td>等待时可以被中断</td>
</tr>
<tr>
<td></td>
<td></td>
<td>可以<strong>无阻塞</strong>尝试获取锁</td>
</tr>
<tr>
<td>等待线程调度</td>
<td>未知，视 JVM 实现</td>
<td>公平锁：FIFO，按照进入同步队列顺序</td>
</tr>
<tr>
<td></td>
<td></td>
<td>非公平锁：<strong>第一次</strong>获取锁时有机会插队</td>
</tr>
<tr>
<td>编程便利性</td>
<td>获取锁/等待锁/释放锁都有内部实现，使用便利</td>
<td>需要显示获取锁，释放锁，切记<strong>要捕捉 exception， 在 finally 中释放锁</strong></td>
</tr>
<tr>
<td>性能</td>
<td>略低，Java6 后有显著提高</td>
<td>较高，Java6 后差距减小</td>
</tr>
<tr>
<td>调试</td>
<td>线程转储中给出哪些调用帧获得哪些锁</td>
<td>Java6 后提供管理和调试接口，锁需要通过该接口注册，相关加锁信息出现在线程转储中</td>
</tr>
</tbody>
</table>
<p><strong>总结</strong></p>
<p>Synchronized 与Lock都是可重入锁，同一个线程再次进入同步代码的时候.可以使用自己已经获取到的锁。</p>
<p>Synchronized是悲观锁机制，独占锁。而Locks.ReentrantLock是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。 ReentrantLock适用场景</p>
<ol>
<li>某个线程在等待一个锁的控制权的这段时间需要中断</li>
<li>需要分开处理一些wait-notify，ReentrantLock里面的Condition应用，能够控制notify哪个线程，锁可以绑定多个条件。</li>
<li>具有公平锁功能，每个到来的线程都将排队等候。</li>
</ol>
<h3 id="Condition介绍"><a href="#Condition介绍" class="headerlink" title="Condition介绍"></a>Condition介绍</h3><p>Condition是为解决Object.wait/notify/notifyAll难以使用的问题</p>
<p>一个ReentrantLock对象可以有多个Condition对象</p>
<blockquote>
<p>Condition的await方法代替Object的wait；<br>Condition的signal方法代替Object的notify方法；<br>Condition的signalAll方法代替Object的notifyAll方法；<br>Condition实例在使用时需要绑定到一个锁上，可以通过newCondition方法获取Condition实例。</p>
</blockquote>
<h4 id="举例-4"><a href="#举例-4" class="headerlink" title="举例"></a>举例</h4><p>一个线程调用<code>condition.await()</code>，此线程就会释放锁，阻塞。当另一个线程调用相同的condition的signal时，它才会重新竞争锁，然后从之前阻塞的地方继续开始。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">final</span> Condition condition = reentrantLock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    reentrantLock.lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"在等待被唤醒"</span>);</span><br><span class="line">                    condition.await();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"恢复执行了"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    reentrantLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"thread1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    reentrantLock.lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"抢到了锁"</span>);</span><br><span class="line">                    condition.signal();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"唤醒其它等待的线程"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    reentrantLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"thread2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thread1在等待被唤醒</span><br><span class="line">thread2抢到了锁</span><br><span class="line">thread2唤醒其它等待的线程</span><br><span class="line">thread1恢复执行了</span><br></pre></td></tr></table></figure>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ol>
<li><strong>await()</strong></li>
</ol>
<p><strong>调用await方法后，当前线程在接收到唤醒信号之前或被中断之前一直处于等待休眠状态。</strong>调用此方法时，当前线程保持了与此Condition有关联的锁，<strong>调用此方法后，当前线程释放持有的锁</strong>。此方法在返回当前线程之前，都必须重新获取与此条件有关的锁，在线程返回时，可以保证它保持此锁</p>
<ol start="2">
<li><strong>await(long time,TimeUnit unit)</strong></li>
</ol>
<p><strong>调用此方法后，会造成当前线程在接收到唤醒信号之前、被中断之前或到达指定等待时间之前一直处于等待状态。</strong>调用此方法时，当前线程保持了与此Condition有关联的锁，<strong>调用此方法后，当前线程释放持有的锁</strong>。time参数为最长等待时间；unit参数为time的时间单位。如果在从此方法返回前检测到等待时间超时，则返回 false，否则返回true。此方法在返回当前线程之前，都必须重新获取与此条件有关的锁，在线程返回时，可以保证它保持此锁。</p>
<ol start="3">
<li><strong>signal()</strong></li>
</ol>
<p><strong>唤醒一个等待线程，如果所有的线程都在等待此条件，则选择其中的一个唤醒。</strong>在从await返回之前，该线程必须重新获取锁。</p>
<ol start="4">
<li><strong>signalAll()</strong></li>
</ol>
<p><strong>唤醒所有等待线程，如果所有的线程都在等待此条件，则唤醒所有线程。</strong> 在从await返回之前，每个线程必须重新获取锁。</p>
<h4 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h4><blockquote>
<p>生产者消费者的实现</p>
<ol>
<li>通过java阻塞队列</li>
<li>wait，notify或await，signal的方式</li>
<li>通过不断轮询地cas</li>
<li>通过观察者模式</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();<span class="comment">//锁对象  </span></span><br><span class="line"> <span class="keyword">final</span> Condition notFull  = lock.newCondition();<span class="comment">//写线程条件   </span></span><br><span class="line"> <span class="keyword">final</span> Condition notEmpty = lock.newCondition();<span class="comment">//读线程条件   </span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];<span class="comment">//缓存队列  </span></span><br><span class="line"> <span class="keyword">int</span> putptr<span class="comment">/*写索引*/</span>, takeptr<span class="comment">/*读索引*/</span>, count<span class="comment">/*队列中存在的数据个数*/</span>;  </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">   lock.lock();  </span><br><span class="line">   <span class="keyword">try</span> &#123;  </span><br><span class="line">     <span class="keyword">while</span> (count == items.length)<span class="comment">//如果队列满了   </span></span><br><span class="line">       notFull.await();<span class="comment">//阻塞写线程  </span></span><br><span class="line">     items[putptr] = x;<span class="comment">//赋值   </span></span><br><span class="line">     <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;<span class="comment">//如果写索引写到队列的最后一个位置了，那么置为0  </span></span><br><span class="line">     ++count;<span class="comment">//个数++  </span></span><br><span class="line">     notEmpty.signal();<span class="comment">//唤醒读线程  </span></span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">     lock.unlock();  </span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">   lock.lock();  </span><br><span class="line">   <span class="keyword">try</span> &#123;  </span><br><span class="line">     <span class="keyword">while</span> (count == <span class="number">0</span>)<span class="comment">//如果队列为空  </span></span><br><span class="line">       notEmpty.await();<span class="comment">//阻塞读线程  </span></span><br><span class="line">     Object x = items[takeptr];<span class="comment">//取值   </span></span><br><span class="line">     <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;<span class="comment">//如果读索引读到队列的最后一个位置了，那么置为0  </span></span><br><span class="line">     --count;<span class="comment">//个数--  </span></span><br><span class="line">     notFull.signal();<span class="comment">//唤醒写线程  </span></span><br><span class="line">     <span class="keyword">return</span> x;  </span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">     lock.unlock();  </span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>注意</p>
<p>上面代码中使用while来判断队列，而不是用if，是因为多线程情况下，唤醒了wait状态的线程，如果保证不了它是想要的那个线程，那就用while来多判断一次缓冲队列的状态</p>
<ul>
<li>一种是wait和notify体系，消费者一次消费结束，notify了另一个阻塞的消费者，而那个消费者没有做再一次的判断，所以会造成多消费</li>
<li>一种是普遍模式，如果生产者生产了，然后唤醒了一个消费者，但是不幸又来了一个消费者提前把生产的消费了，所以这个被唤醒的消费者，如果不再一次进行检查，那会造成又一次的消费</li>
</ul>
<p>所以wait一定要放在while语句里</p>
<p>参考路径：</p>
<p><a href="http://www.jianshu.com/p/8123b85cdc87" target="_blank" rel="noopener">生产者消费者的五种实现</a></p>
<p><a href="http://blog.csdn.net/u011784767/article/details/51656697" target="_blank" rel="noopener">生产者和消费者的例子，有解释</a></p>
<p><a href="https://juejin.im/entry/5800896fa22b9d005b2cd766" target="_blank" rel="noopener">Java 多线程之并发协作生产者消费者设计模式</a></p>
<h3 id="volatile介绍"><a href="#volatile介绍" class="headerlink" title="volatile介绍"></a>volatile介绍</h3><p>volatile关键字提供了内存可见性和禁止内存重排序</p>
<h4 id="具体说明-1"><a href="#具体说明-1" class="headerlink" title="具体说明"></a>具体说明</h4><ul>
<li>某一个线程修改了被volatile修饰的变量之后，会立即把值更新到主内存，其他线程获取这个变量的时候不会在工作内存中拿取，而是直接去主内存中拿取，保证了<strong>可见性</strong></li>
<li>volatile可以禁止进行指令重排，保证了<strong>有序性</strong></li>
</ul>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>volatile是基于内存屏障（Memory Barrier）实现的</p>
<blockquote>
<p>内存屏障，又称内存栅栏，是一个CPU指令，基本上它是一条这样的指令：<br>1、插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。<br>2、强制更新一次不同CPU的缓存。例如，一个写屏障会把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程将得到最新值，而不用考虑到底是被哪个cpu核心或者哪颗CPU执行的。<br>3、如果你的字段是volatile，Java内存模型将在写操作后插入一个写屏障指令，在读操作前插入一个读屏障指令。这意味着如果你对一个volatile字段进行写操作，你必须知道：1、一旦你完成写入，任何访问这个字段的线程将会得到最新的值。2、在你写入前，会保证所有之前发生的事已经发生，并且任何更新过的数据值也是可见的，因为内存屏障会把之前的写入值都刷新到缓存。</p>
</blockquote>
<p><strong>原子性原理</strong></p>
<p>即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
<p>比如<code>x++</code>包括3个操作：</p>
<p>1）读取volatile变量值到local； 2）增加变量的值；3）把local的值写回，让其它的线程可见。</p>
<p>这3步的jvm指令为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov    <span class="number">0xc</span>(%r10),%r8d ; Load</span><br><span class="line">inc    %r8d           ; Increment</span><br><span class="line">mov    %r8d,<span class="number">0xc</span>(%r10) ; Store</span><br><span class="line">lock addl $<span class="number">0x0</span>,(%rsp) ; StoreLoad Barrier  <span class="comment">//注意最后一步是内存屏障</span></span><br></pre></td></tr></table></figure>
<p>从Load到store到内存屏障，一共4步，其中最后一步jvm让这个最新的变量的值在所有线程可见，也就是最后一步让所有的CPU内核都获得了最新的值，但在执行内存屏障之前，中间的几步（从Load到Store）是不安全的。</p>
<p>内存屏障可以被分为以下几种类型：</p>
<p>LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</p>
<p>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</p>
<p>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</p>
<p>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。</p>
<p><strong>可见性原理</strong></p>
<p>为在虚拟机内存中有主内存和工作内存的概念，每个线程都有自己的工作内存，当读取一个普通变量时，优先读取工作内存的变量，如果工作内存中没有对应的变量，则从主内存中加载到工作内存，对工作内存的普通变量进行修改，不会立马同步到主内存。<strong>对volatile修饰的变量进行写操作时，直接把最新值写到主内存中，并清空其它cpu工作内存中该变量所在的内存行数据</strong>（Write-Barrier（写入屏障）将刷新所有在 Barrier 之前写入 cache 的数据），<strong>对volatile修饰的变量进行读操作时，会读取主内存的数据</strong>。内存可见性保证了在多线程的场景下，保证了线程A对变量的修改，其它线程可以读到最新值。</p>
<p><strong>有序性原理</strong></p>
<p>插入一条Memory Barrier会告诉编译器和CPU：不管什么指令都不能和这条Memory Barrier指令重排序</p>
<h4 id="缺陷-1"><a href="#缺陷-1" class="headerlink" title="缺陷"></a>缺陷</h4><p>volatile并不保证原子性，比如i++，因为两个线程可以同时在主存获取变量i的值，然后同时修改后，保存到主存，这个过程一点也不违背可见性（获取最新，修改后立马更新），比如i=0的时候，两个线程同时获取，然后同时修改后，i是等于1，而不是等于2</p>
<p>不要将volatile用在getAndOperate场合（这种场合不原子，需要再加锁），仅仅set或者get的场景是适合volatile的。</p>
<p>参考路径</p>
<p><a href="http://blog.csdn.net/sinat_35512245/article/details/60325685" target="_blank" rel="noopener">http://blog.csdn.net/sinat_35512245/article/details/60325685</a></p>
<h3 id="ThreadLocal介绍"><a href="#ThreadLocal介绍" class="headerlink" title="ThreadLocal介绍"></a>ThreadLocal介绍</h3><p>ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p>
<h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>每当线程去访问TreadLocal时，它都会从线程对应的TreadLocalMap（其实是一个Entry数组，索引是ThreadLocal对象的hash与运算，如果重复会nextIndex，再获取一个索引）中拿出与之对应的Entry，Entry的key是当前ThreadLocal对象，Entry的value就是当前线程下ThreadLocal的值</p>
<p><img src="/2017/03/27/java-thread/ThreadLocal.png" alt></p>
<p>ThreadLocalMap实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个ThreadLocalMap对象赋值给当前线程的成员变量threadLocals</span></span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">        <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">        table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        setThreshold(INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>ThreadLocal.set() 实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i]; e != <span class="keyword">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ThreadLocal.get() 实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="举例-5"><a href="#举例-5" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> SimpleDateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Date date = <span class="keyword">new</span> Date();</span><br><span class="line">                System.out.println(dateFormatThreadLocal.get().format(date));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Date date = <span class="keyword">new</span> Date();</span><br><span class="line">                <span class="comment">//dateFormatThreadLocal.set(new SimpleDateFormat("yyyy-MM-dd")); </span></span><br><span class="line">                System.out.println(dateFormatThreadLocal.get().format(date));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><h4 id="Servlet不是线程安全的"><a href="#Servlet不是线程安全的" class="headerlink" title="Servlet不是线程安全的"></a>Servlet不是线程安全的</h4><p>serlvet采用多线程来处理多个请求同时访问，Tomcat容器维护了一个线程池来服务请求，serlvet也只会初始化一次，当被请求访问到的时候初始化。当容器收到一个Servlet请求，Dispatcher线程从线程池中选出一个工作组线程，将请求传递给该线程，然后由该线程来执行Servlet的service方法。当这个线程正在执行的时候，容器收到另一个请求，调度者线程将从线程池中选出另外一个工作组线程来服务这个新的请求，容器并不关心这个请求是否访问的是同一个Servlet还是另一个Servlet。当容器收到对同一个Servlet的多个请求的时候，那这个servlet的service方法将在多线程中并发的执行。</p>
<h4 id="SimpleDateFormat线程不安全"><a href="#SimpleDateFormat线程不安全" class="headerlink" title="SimpleDateFormat线程不安全"></a>SimpleDateFormat线程不安全</h4><p>SimpleDateFormat里会保持一个Calendar变量，如果每个线程都操作这个变量，就会发生线程安全问题</p>
<p><a href="http://blog.csdn.net/zq602316498/article/details/40263083" target="_blank" rel="noopener">http://blog.csdn.net/zq602316498/article/details/40263083</a></p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。</p>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>当在某个线程创建一个新的线程，这个线程有与创建线程相同的优先级。<br><code>setPriority(int newPriority)</code></p>
<h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>当一个jvm启动，这里通常有一个非守护线程(运行main函数)，但是jvm只剩下守护线程，守护线程不会支持jvm继续运行。</p>
<p><code>setDaemon(boolean on)</code></p>
<h4 id="线程API"><a href="#线程API" class="headerlink" title="线程API"></a>线程API</h4><p><img src="/2017/03/27/java-thread/threadapi.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前线程可转让cpu控制权，让优先级更高的线程运行(有可能还是自己)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Thread.yield()</span><br><span class="line"><span class="comment">//线程暂停一段时间，但在等待的时候仍然会持有monitor或者锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Thread.sleep()</span><br><span class="line"><span class="comment">//在一个线程中调用other.join(),将等待other执行完后才继续本线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">join</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//判断是否有中断信息，同时也会对中断状态进行复位</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>interrupt方法通过修改了被调用线程的中断状态来告知那个线程, 说它被中断了. 对于非阻塞中的线程, 只是改变了中断状态, 即Thread.isInterrupted()将返回true; 对于可取消的阻塞状态中的线程, 比如等待在这些函数上的线程, Thread.sleep(), Object.wait(), Thread.join(), 这个线程收到中断信号后, 会抛出InterruptedException，提前结束阻塞状态，但是run方法不会中断，需要自己实现中断方法执行。不是所有的阻塞方法收到中断后都可以取消阻塞状态, 输入和输出流类会阻塞等待 I/O 完成，但是它们不抛出 InterruptedException，而且在被中断的情况下也不会退出阻塞状态. 同时会把中断状态置回为true.但调用Thread.interrupted()会对中断状态进行复位。只有方法上有InterruptedException，才能进行中断，比如使用synchronized时线程获取锁而受阻，就无法中断，但是因为lock的lock方法上有这个异常，所以lock锁的阻塞可以中断。</p>
</blockquote>
<p><a href="http://blog.csdn.net/canot/article/details/51087772" target="_blank" rel="noopener">http://blog.csdn.net/canot/article/details/51087772</a></p>
<h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><p><img src="/2017/03/27/java-thread/ThreadLife.png" alt></p>
<ul>
<li><strong>NEW</strong> ：还未开始的线程</li>
<li><strong>RUNNABLE</strong> ：正在被jvm执行，但可能正在等待CPU调度</li>
<li><strong>BLOCKED</strong> ： 等待获取锁以进入同步方法/代码块</li>
<li><strong>WAITING</strong> ： 线程在这个状态下等待其他线程执行特定操作。通常为当执行以下操作后<br><code>Object.wait</code>,<br><code>Thread.join</code>,<br><code>LockSupport.park</code></li>
<li><strong>TIMED_WAITING</strong> ：当线程开始等待一段时间。通常为当执行以下操作后<br><code>Thread.sleep(long)</code>,<br><code>Object.wait(long)</code>,<br><code>Thread.join(long)</code>,<br><code>LockSupport.parkNanos</code>,<br><code>LockSupport.parkUntil</code></li>
<li><strong>TERMINATED</strong> ：线程已结束</li>
</ul>
<h4 id="操作系统的线程状态"><a href="#操作系统的线程状态" class="headerlink" title="操作系统的线程状态"></a>操作系统的线程状态</h4><ul>
<li>就绪</li>
<li>运行</li>
<li>阻塞</li>
</ul>
<h4 id="线程阻塞"><a href="#线程阻塞" class="headerlink" title="线程阻塞"></a>线程阻塞</h4><p>java线程到阻塞状态，需要从用户态转换到核心态，所以会耗费很多处理器时间，要尽量减少阻塞状态的频繁切换</p>
<h4 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h4><ul>
<li>线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务</li>
<li>进程是资源分配的最小单位，线程是程序执行的最小单位</li>
<li>一个进程是一个独立的运行环境，它可以被看作一个程序或者一个应用</li>
<li>一个进程下的所有线程共用一片内存，但是它们有各自的栈内存</li>
</ul>
<h4 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h4><ul>
<li>继承Thread，覆盖run()方法，创建线程对象并用start()方法启动线程</li>
<li>实现Runnable接口来创建Thread线程</li>
<li>通过实现Callable接口来创建Thread线程</li>
<li>借助框架程序 可用Executor框架来创建线程池，线程池可以限制线程的数量并且可以回收再利用这些线程</li>
</ul>
<h4 id="start-和-run-方法区别"><a href="#start-和-run-方法区别" class="headerlink" title="start() 和 run() 方法区别"></a>start() 和 run() 方法区别</h4><p>start()方法被用来启动新创建的线程，使该被创建的线程状态变为可运行状态。<br>当你调用run()方法的时候，没有新的线程启动，只会是在原来的线程中调用，这个方法同普通类的run方法一样。</p>
<h3 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待 / 通知机制"></a>等待 / 通知机制</h3><p><strong>wait()</strong>：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁； </p>
<p><strong>sleep()</strong>：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常； </p>
<p><strong>notify()</strong>：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；notify之后，需要把自身的同步代码块执行完毕后才会让出锁。</p>
<p><strong>notityAll()</strong>：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；</p>
<p><strong>join()</strong>：当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到执行join的线程运行结束，当前线程再由阻塞状态变为就绪状态。</p>
<p><strong>join(long millis)</strong>：millis的时间过后，当前线程转入阻塞状态，直到执行join的线程运行结束</p>
<h4 id="举例-6"><a href="#举例-6" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by j_zhan on 2016/7/6.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotify</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread A = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Wait(), <span class="string">"wait thread"</span>);</span><br><span class="line">        A.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        Thread B = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Notify(), <span class="string">"notify thread"</span>);</span><br><span class="line">        B.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Wait</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread() + <span class="string">" flag is true"</span>);</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">" flag is false"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Notify</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">7</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其相关方法定义在java.lang.Object上，线程A在获取锁后调用了对象lock的wait方法进入了等待状态，线程B调用对象lock的notifyAll()方法，线程A收到通知后从wait方法处返回继续执行，线程B对共享变量flag的修改对线程A来说是可见的。</p>
<p><strong>Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?</strong><br>sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，<strong>但是对象的锁依然保持</strong>，因此休眠时间结束后会自动恢复。wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果<strong>线程重新获得对象的锁就可以进入就绪状态</strong></p>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ol>
<li>使用wait()、notify()和notifyAll()时需要先对调用对象加锁，调用wait()方法后会释放锁。</li>
<li>调用wait()方法之后，线程状态由RUNNING变为WAITING，并将当前线程放置到对象的等待队列中。</li>
<li>notify()或notifyAll()方法调用后，等待线程不会立刻从wait()中返回，需要等该线程释放锁之后，才有机会获取锁之后从wait()返回。</li>
<li>notify()方法将等待队列中的一个等待线程从等待队列中移动到同步队列中；notifyAll()方法则是把等待队列中的所有线程都移动到同步队列中；被移动的线程状态从WAITING变为BLOCKED。</li>
<li>该线程从wait()方法返回的前提是获得了调用对象的锁。</li>
</ol>
<h3 id="Runnable介绍"><a href="#Runnable介绍" class="headerlink" title="Runnable介绍"></a>Runnable介绍</h3><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()).start();</span><br></pre></td></tr></table></figure>
<h3 id="Callable介绍"><a href="#Callable介绍" class="headerlink" title="Callable介绍"></a>Callable介绍</h3><h4 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;()),<span class="string">"线程名"</span>).start();</span><br></pre></td></tr></table></figure>
<h4 id="Callable和Runnable的区别"><a href="#Callable和Runnable的区别" class="headerlink" title="Callable和Runnable的区别"></a>Callable和Runnable的区别</h4><ol>
<li>Callable 的 call() 方法可以返回值和抛出异常，而 Runnable 的 run() 方法没有这些功能。</li>
<li>Callable 可以使用ExecutorService</li>
</ol>
<h3 id="Future介绍"><a href="#Future介绍" class="headerlink" title="Future介绍"></a>Future介绍</h3><p>Future是一个接口，定义了Future对于具体的Runnable或者Callable任务的执行结果进行取消、查询任务是否被取消，查询是否完成、获取结果。</p>
<h4 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//试图取消对此任务的执行。如果任务已完成、或已取消，或者由于某些其他原因而无法取消，则此尝试将失败。当调用 cancel() 时，如果调用成功，而此任务尚未启动，则此任务将永不运行。如果任务已经启动，则 mayInterruptIfRunning 参数确定是否应该以试图停止任务的方式来中断执行此任务的线程。此方法返回后，对 isDone() 的后续调用将始终返回 true。如果此方法返回 true，则对 isCancelled() 的后续调用将始终返回 true。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果在任务正常完成前将其取消，则返回 true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果任务已完成，则返回 true。 可能由于正常终止、异常或取消而完成，在所有这些情况中，此方法都将返回 true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如有必要，等待计算完成，然后获取其结果。如果运算尚未完成get方法将会阻塞</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如有必要，最多等待为使计算完成所给定的时间之后，获取其结果（如果结果可用）</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="举例-7"><a href="#举例-7" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"做一些耗时的任务..."</span>);</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureSimpleDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        Future&lt;String&gt; future = executorService.submit(<span class="keyword">new</span> MyCallable());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"dosomething..."</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"得到异步任务返回结果："</span> + future.get());</span><br><span class="line">        System.out.println(<span class="string">"Completed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="FutureTask介绍"><a href="#FutureTask介绍" class="headerlink" title="FutureTask介绍"></a>FutureTask介绍</h3><p>FutureTask的父类是RunnableFuture，而RunnableFuture继承了Runnbale和Futrue这两个接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.callable = callable;</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>FutureTask最终都是执行Callable类型的任务。</li>
<li>如果构造函数参数是Runnable，会被Executors.callable方法转换为Callable类型。</li>
</ol>
<h4 id="举例-8"><a href="#举例-8" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableAndFuture</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Callable&lt;Integer&gt; callable = <span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        FutureTask&lt;Integer&gt; future = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(callable);</span><br><span class="line">        <span class="keyword">new</span> Thread(future).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);<span class="comment">// 可能做一些事情</span></span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程</p>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。</li>
</ol>
<h4 id="线程池接口图"><a href="#线程池接口图" class="headerlink" title="线程池接口图"></a>线程池接口图</h4><p><img src="/2017/03/27/java-thread/Executor.png" alt></p>
<h4 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h4><p>普通类 Executors 里面调用的就是 ThreadPoolExecutor。</p>
<p>Executors提供了一系列工厂方法用于创先线程池，返回的线程池都实现了ExecutorService接口。ScheduleExecutorService代表可在指定延迟后或周期性地执行线程任务的线程池。</p>
<h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p><img src="/2017/03/27/java-thread/ThreadPool.png" alt></p>
<h5 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         threadFactory, defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>corePoolSize</strong>：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。<br><strong>maximumPoolSize</strong>：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。<br><strong>keepAliveTime</strong>： 线程池维护线程所允许的空闲时间<br><strong>unit</strong>： 线程池维护线程所允许的空闲时间的单位<br><strong>workQueue</strong>： 线程池所使用的缓冲队列<br><strong>threadFactory</strong>：线程工厂，它是一个接口，用来为线程池创建新线程的<br><strong>handler</strong>： 超出线程池容量以及队列长度后拒绝任务的策略</p>
</blockquote>
<p>针对handler，线程池提供了4种策略：<br>1、AbortPolicy：直接抛出异常，默认策略；<br>2、CallerRunsPolicy：用调用者所在的线程来执行任务；<br>3、DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；<br>4、DiscardPolicy：直接丢弃任务；</p>
<h4 id="corePoolSize-和-maximumPoolSize"><a href="#corePoolSize-和-maximumPoolSize" class="headerlink" title="corePoolSize 和 maximumPoolSize"></a>corePoolSize 和 maximumPoolSize</h4><p><img src="/2017/03/27/java-thread/corePoolSize.png" alt></p>
<h5 id="具体说明-2"><a href="#具体说明-2" class="headerlink" title="具体说明"></a>具体说明</h5><p>提交任务，线程池中的线程数可以增长至corePoolSize，之后继续提交任务将暂存至队列中，如果队列满，则看是否能继续增长线程数至maximumPoolSize，超出后将进行拒绝策略处理。如果采用无界队列，那么maximumPoolSize将失效，线程池中的线程最多就是corePoolSize个线程工作</p>
<h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><h5 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h5><p>一个基于数组实现的有界阻塞队列。ArrayBlockingQueue在生产者放入和消费者获取数据时共用一个锁对象，所以说对一个queue而言并没有做到真正的并行</p>
<h5 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h5><p>SynchronousQueue无数据缓冲区，相当于生产者和消费者直接交换数据而不通过任何中介。SynchronousQueue中每一个put操作必须等待一个take操作，否则不能继续添加元素。如果没有空闲线程，就构造一个新的线程加入线程池，如果线程池里没有空闲线程，则不会进行任务，newCachedThreadPool采用的便是这种策略</p>
<h5 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h5><p>一个基于链表实现的有界阻塞队列。不同于ArrayBlockingQueue，其对生产者和消费者端分别采用了独立的锁来控制数据同步，因此提高了队列的并发性能。需要注意的是此队列的默认长度是Integer,MAX_VALUE，即无限大小，当生产者速度过快时，系统内存有被耗尽的风险，newFixedThreadPool采用的便是这种策略</p>
<h5 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h5><p>元素是按照顺序储存的，一个具有优先级的无限阻塞队列</p>
<h5 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h5><p>队列中的每个元素实现了Delayed接口，只有当指定的延迟时间到了，才能够从队列中获取该元素。DelayQueue可以用于保存将要执行的任务和执行时间，newScheduledThreadPool采用的便是这种策略，也是无界</p>
<h4 id="Executors-提供四种线程池"><a href="#Executors-提供四种线程池" class="headerlink" title="Executors 提供四种线程池"></a>Executors 提供四种线程池</h4><h5 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h5><p>一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。<strong>对于执行很多短期异步任务的程序而言，这个线程池通常可提高程序性能。</strong>调用 execute() 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。如果是长期异步任务，就不要用这种，因为每当创建新线程执行任务，会导致一定的系统开销，<strong>所以，使用该线程池时，一定要注意控制并发的任务数，否则创建大量的线程可能导致严重的性能问题。</strong>线程池的线程数可达到Integer.MAX_VALUE，即2147483647</p>
<h5 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h5><p>一个单线程池，也就是该线程池只有一个线程在工作，所有的任务是串行执行的，如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它，此线程池保证所有任务的执行顺序按照任务的提交顺序执行</p>
<h5 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h5><p>创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小，线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程</p>
<h5 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h5><p>初始化的线程池可以在指定的时间内周期性的执行所提交的任务，在实际的业务场景中可以使用该线程池定期的同步数据。</p>
<h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService0 = Executors.newCachedThreadPool();</span><br><span class="line">ExecutorService executorService1 = Executors.newSingleThreadExecutor();  </span><br><span class="line">ExecutorService executorService2 = Executors.newFixedThreadPool(<span class="number">10</span>);  </span><br><span class="line">ExecutorService executorService3 = Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h4 id="ExecutorService方法"><a href="#ExecutorService方法" class="headerlink" title="ExecutorService方法"></a>ExecutorService方法</h4><ol>
<li>execute(Runnable)  </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">executorService.execute(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Asynchronous task"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>submit(Runnable)  </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Future future = executorService.submit(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Asynchronous task"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>submit(Callable) </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Future future = executorService.submit(<span class="keyword">new</span> Callable()&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Asynchronous Callable"</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Callable Result"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>submit(new FutureTask<integer>(Callable))</integer></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">submit(<span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Callable()&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Asynchronous Callable"</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Callable Result"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<ol start="5">
<li><p>invokeAny(…)  </p>
<p>方法 invokeAny() 接收一个包含 Callable 对象的集合作为参数。调用该方法不会返回 Future 对象，而是返回集合中某一个 Callable 对象的结果，而且无法保证调用之后返回的结果是哪一个 Callable，只知道它是这些 Callable 中一个执行结束的 Callable 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newSingleThreadExecutor();  </span><br><span class="line"></span><br><span class="line">Set&lt;Callable&lt;String&gt;&gt; callables = <span class="keyword">new</span> HashSet&lt;Callable&lt;String&gt;&gt;();  </span><br><span class="line"></span><br><span class="line">callables.add(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Task 1"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);  </span><br><span class="line">callables.add(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Task 2"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);  </span><br><span class="line">callables.add(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Task 3"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line">String result = executorService.invokeAny(callables);  </span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"result = "</span> + result);  </span><br><span class="line"></span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure>
</li>
<li><p>invokeAll(…)</p>
<p>方法 invokeAll() 会调用存在于参数集合中的所有 Callable 对象，并且返回一个包含 Future 对象的集合，你可以通过这个返回的集合来管理每个 Callable 的执行结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个线程数固定大小为10的线程池</span></span><br><span class="line">ExecutorService executorService = Executors.newFixedThreadPool( <span class="number">10</span> ) ;</span><br><span class="line">List&lt;Callable&lt;String&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;() ;</span><br><span class="line"><span class="comment">//创建第一个 Callable</span></span><br><span class="line">Callable&lt;String&gt; callable1 = <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.d( <span class="string">"callable 1 线程是： "</span>+ Thread.currentThread().getName()  );</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"执行完了 callable 1"</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//创建第二个 Callable</span></span><br><span class="line">Callable&lt;String&gt; callable2 = <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.d( <span class="string">"callable 2 线程是： "</span>+ Thread.currentThread().getName()  );</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"执行完了 callable 2"</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">list.add(callable1 ) ;</span><br><span class="line">list.add(callable2 ) ;</span><br><span class="line">List&lt;Future&lt;String&gt;&gt; result;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    result = executorService.invokeAll( list );</span><br><span class="line">    <span class="keyword">for</span> (Future&lt;String&gt; future : result) &#123;</span><br><span class="line">        Log.d( <span class="string">"结果是： "</span>+ future.get()  );</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭线程池</span></span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure>
</li>
<li><p>shutdown()</p>
<p>不会立即的终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务</p>
</li>
<li><p>shutdownNow() </p>
<p>立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务</p>
</li>
</ol>
<h4 id="ForkJoinPool介绍"><a href="#ForkJoinPool介绍" class="headerlink" title="ForkJoinPool介绍"></a>ForkJoinPool介绍</h4><p>ForkJoinPool同ThreadPoolExecutor一样，也实现了Executor和ExecutorService接口。它使用了一个无限队列来保存需要执行的任务，而线程的数量则是通过构造函数传入，如果没有向构造函数中传入希望的线程数量，那么当前计算机可用的CPU数量会被设置为线程数量作为默认值。</p>
<p>ForkJoinPool的另外一个特性是它能够实现工作窃取(Work Stealing)，在该线程池的每个线程中会维护一个队列来存放需要被执行的任务。当线程自身队列中的任务都执行完毕后，它会从别的线程中拿到未被执行的任务并帮助它执行。</p>
<p>可以把一个任务拆分成多个小任务，然后再把多个小任务合成总的计算结果</p>
<ul>
<li>分解（Fork）操作：当需要将一个任务拆分成更小的多个任务时，在框架中执行这些任务</li>
<li>合并（Join）操作：当一个主任务等待其创建的多个子任务的完成执行</li>
<li>ForkJoinPool类的execute(ForkJoinTask<t> task)方法是异步调用的</t></li>
<li>ForkJoinPool类的invoke(ForkJoinTask<t> task)方法则是同步调用的</t></li>
</ul>
<p><img src="/2017/03/27/java-thread/ForkJoinPool.png" alt></p>
<h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><table>
<thead>
<tr>
<th>区别</th>
<th>Executor</th>
<th>ForkJoinPool</th>
</tr>
</thead>
<tbody>
<tr>
<td>接受的对象</td>
<td>Runnable和Callable的实例</td>
<td>Runnable、Callable和ForkJoinTask的实例</td>
</tr>
<tr>
<td>调度模式</td>
<td>处于后面等待中的任务需要等待前面任务执行后才有机会被执行，是否被执行取决于具体的调度规则</td>
<td>采用work-stealing模式帮助其他线程执行任务，即ExcuteService解决的是并发问题，而ForkJoinPool解决的是并行问题。</td>
</tr>
</tbody>
</table>
<h5 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h5><p>ForkJoinTask继承与Future接口，代表一个可以并行、合并的任务.</p>
<p>它有两个抽象子类：RecursiveAction和RecursiveTask。</p>
<ul>
<li>RecursiveTask代表有返回值的任务</li>
<li>RecursiveAction代表没有返回值的任务</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://barry215.github.io/2017/03/26/java-collection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="frank">
      <meta itemprop="description" content="总有一天你是我的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="麦金">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/03/26/java-collection/" class="post-title-link" itemprop="url">Java集合深入详解</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-03-26 15:11:09" itemprop="dateCreated datePublished" datetime="2017-03-26T15:11:09+08:00">2017-03-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-10-09 22:01:25" itemprop="dateModified" datetime="2017-10-09T22:01:25+08:00">2017-10-09</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>之前对于Java的集合类仅仅只是一笔带过，现在我打算仔细地介绍一遍</p>
</blockquote>
<p><img src="/2017/03/26/java-collection/collection.png" alt></p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>ArrayList是<strong>基于数组</strong>实现的，是一个动态数组，其容量能自动增长，默认容量是10。当容量不足时，就设置新的容量为旧的容量的1.5倍加1，如果还不够就直接令新容量设置为传入的参数。容量增加的方法是用<code>System.arraycopy(oldArrays,old_start_index,newArrays,new_start_index,oldArrays.length)</code>方法把原来的元素拷贝进一个新数组。</p>
<h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>ArrayList是<strong>非线程安全</strong>的，只能用在单线程环境下，多线程环境下可以考虑用<code>Collections.synchronizedList(List list)</code>函数返回一个线程安全的ArrayList类，也可以使用<code>concurrent</code>并发包下的<code>CopyOnWriteArrayList</code>类。</p>
<h4 id="不安全性"><a href="#不安全性" class="headerlink" title="不安全性"></a>不安全性</h4><p>ArrayList在添加一个元素的时候，它可能会有两步来完成：1. 在 Items[Size] 的位置存放此元素；2. 增大 Size 的值。在单线程运行的情况下，如果 Size = 0，添加一个元素后，此元素在位置 0，而且 Size=1；而如果是在多线程情况下，比如有两个线程，线程 A 先将元素存放在位置 0。但是此时 CPU 调度线程A暂停，线程 B 得到运行的机会。线程B也向此 ArrayList 添加元素，因为此时 Size 仍然等于 0 （注意哦，我们假设的是添加一个元素是要两个步骤哦，而线程A仅仅完成了步骤1），所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，都增加 Size 的值。那好，我们来看看 ArrayList 的情况，元素实际上只有一个，存放在位置 0，而 Size 却等于 2。这就是“线程不安全”了</p>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>因为基于数组，有下标索引，所以便于遍历查找</p>
<h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><p>ArrayList不适合频繁插入或删除元素，因为这样会大量地移动元素<br>不是线程安全，如果两个线程同时插入，会导致size不一致情况</p>
<h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p>ArrayList中允许元素为null</p>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><h4 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h4><p>写时<strong>加锁</strong>，当添加一个元素的时候，将原来的容器进行copy，复制出一个新的容器，然后在新的容器里面写，写完之后再将原容器的引用指向新的容器，而读的时候是读旧容器的数据，所以可以进行并发的读，但这是一种共享锁的策略。 </p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>CopyOnWriteArrayList适合使用在读操作远远大于写操作的场景里，比如缓存。</p>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><h4 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h4><p>LinkedList是基于<strong>双向循环链表</strong>实现的，且头结点中不存放数据，除了可以当做链表来操作外，它还可以当做栈、队列和双端队列来使用。</p>
<p><img src="/2017/03/26/java-collection/LinkedList.png" alt></p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//元素结点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取元素方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过一次二分法的遍历</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//源码中先将index与长度size的一半比较，如果index&lt;size/2，就只从位置0往后遍历到位置index处，而如果index&gt;size/2，就只从位置size往前遍历到位置index处。这样可以减少一部分不必要的遍历，从而提高一定的效率（实际上效率还是很低）。</span></span><br></pre></td></tr></table></figure>
<h4 id="线程安全-1"><a href="#线程安全-1" class="headerlink" title="线程安全"></a>线程安全</h4><p>LinkedList是<strong>非线程安全</strong>的，只在单线程下适合使用。</p>
<h4 id="不安全性-1"><a href="#不安全性-1" class="headerlink" title="不安全性"></a>不安全性</h4><p>进队列操作</p>
<ul>
<li>获取链表的链尾【断点】</li>
<li>插入元素</li>
<li>把链尾指向当前元素</li>
</ul>
<p>出队列操作</p>
<ul>
<li>获取头结点【断点】</li>
<li>获取头结点的下一个节结点</li>
<li>把头结点指针指向下一个节点</li>
<li>然后把之前的头结点置null，next指针也置null</li>
</ul>
<p>多线程下，进队列操作会出现元素覆盖的问题<br>出队列会出现头结点没有后续元素，其实是因为头结点被置null了</p>
<h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><p>因为基于链表，所以方便增加和删除元素，也方便获取第一和最后元素</p>
<p>LinkedList实现了Queue接口，因此也可以作为栈、队列和双端队列来使用</p>
<h4 id="局限性-1"><a href="#局限性-1" class="headerlink" title="局限性"></a>局限性</h4><p>不适合遍历查找</p>
<h4 id="备注-1"><a href="#备注-1" class="headerlink" title="备注"></a>备注</h4><p>LinkedList实现了Serializable接口，因此它支持序列化，能够通过序列化传输，实现了Cloneable接口，能被克隆。</p>
<p>LinkedList中允许元素为null</p>
<h3 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h3><h4 id="实现原理-3"><a href="#实现原理-3" class="headerlink" title="实现原理"></a>实现原理</h4><p>ArrayDeque继承于AbstractCollection，底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即循环数组（circular array），也就是说数组的任何一点都可能被看作起点或者终点</p>
<h4 id="线程安全-2"><a href="#线程安全-2" class="headerlink" title="线程安全"></a>线程安全</h4><p>ArrayDeque是非线程安全的</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>Queue是一个接口，当需要使用栈和队列时首选ArrayDeque（双端队列）了，次选是LinkedList，不推荐使用Stack</p>
<p>下表列出了Deque与Queue相对应的接口：</p>
<table>
<thead>
<tr>
<th>Queue Method</th>
<th>Equivalent Deque Method</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>add(e)</code></td>
<td><code>addLast(e)</code></td>
<td>向队尾插入元素，失败则抛出异常</td>
</tr>
<tr>
<td><code>offer(e)</code></td>
<td><code>offerLast(e)</code></td>
<td>向队尾插入元素，失败则返回<code>false</code></td>
</tr>
<tr>
<td><code>remove()</code></td>
<td><code>removeFirst()</code></td>
<td>获取并删除队首元素，失败则抛出异常</td>
</tr>
<tr>
<td><code>poll()</code></td>
<td><code>pollFirst()</code></td>
<td>获取并删除队首元素，失败则返回<code>null</code></td>
</tr>
<tr>
<td><code>element()</code></td>
<td><code>getFirst()</code></td>
<td>获取但不删除队首元素，失败则抛出异常</td>
</tr>
<tr>
<td><code>peek()</code></td>
<td><code>peekFirst()</code></td>
<td>获取但不删除队首元素，失败则返回<code>null</code></td>
</tr>
</tbody>
</table>
<p>下表列出了Deque与Stack对应的接口：</p>
<table>
<thead>
<tr>
<th>Stack Method</th>
<th>Equivalent Deque Method</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>push(e)</code></td>
<td><code>addFirst(e)</code></td>
<td>向栈顶插入元素，失败则抛出异常</td>
</tr>
<tr>
<td>无</td>
<td><code>offerFirst(e)</code></td>
<td>向栈顶插入元素，失败则返回<code>false</code></td>
</tr>
<tr>
<td><code>pop()</code></td>
<td><code>removeFirst()</code></td>
<td>获取并删除栈顶元素，失败则抛出异常</td>
</tr>
<tr>
<td>无</td>
<td><code>pollFirst()</code></td>
<td>获取并删除栈顶元素，失败则返回<code>null</code></td>
</tr>
<tr>
<td><code>peek()</code></td>
<td><code>peekFirst()</code></td>
<td>获取但不删除栈顶元素，失败则抛出异常</td>
</tr>
<tr>
<td>无</td>
<td><code>peekFirst()</code></td>
<td>获取但不删除栈顶元素，失败则返回<code>null</code></td>
</tr>
</tbody>
</table>
<h4 id="备注-2"><a href="#备注-2" class="headerlink" title="备注"></a>备注</h4><p>ArrayDeque不允许放入<code>null</code>元素</p>
<h4 id="参考路径"><a href="#参考路径" class="headerlink" title="参考路径"></a>参考路径</h4><p><a href="https://zhuanlan.zhihu.com/p/24752167?refer=dreawer" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24752167?refer=dreawer</a></p>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><h4 id="实现原理-4"><a href="#实现原理-4" class="headerlink" title="实现原理"></a>实现原理</h4><p>Vector也是基于数组实现的，是一个动态数组，其容量能自动增长。总体上和ArrayList一样，只是很多方法都加入了synchronized同步语句，来保证线程安全</p>
<h4 id="线程安全-3"><a href="#线程安全-3" class="headerlink" title="线程安全"></a>线程安全</h4><p>Vector是<strong>线程安全</strong>的</p>
<h4 id="优势-2"><a href="#优势-2" class="headerlink" title="优势"></a>优势</h4><p>因为很多方法加了synchronized，所以可以用于多线程环境</p>
<p>和ArrayList一样便于遍历查找</p>
<h4 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h4><p>和ArrayList一样，不适合频繁插入或删除元素</p>
<h4 id="备注-3"><a href="#备注-3" class="headerlink" title="备注"></a>备注</h4><p>Vector中允许元素为nul</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><h4 id="实现原理-5"><a href="#实现原理-5" class="headerlink" title="实现原理"></a>实现原理</h4><p>HashSet是对HashMap的简单包装，对HashSet的函数调用都会转换成合适的HashMap方法</p>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><h4 id="实现原理-6"><a href="#实现原理-6" class="headerlink" title="实现原理"></a>实现原理</h4><p>TreeSet是对TreeMap的简单包装，对TreeSet的函数调用都会转换成合适的TreeMap方法</p>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><h4 id="实现原理-7"><a href="#实现原理-7" class="headerlink" title="实现原理"></a>实现原理</h4><p>LinkedHashSet是对LinkedHashMap的简单包装，对LinkedHashSet的函数调用都会转换成合适的LinkedHashMap方法</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h4 id="实现原理-8"><a href="#实现原理-8" class="headerlink" title="实现原理"></a>实现原理</h4><p>HashMap是基于数组和链表实现的，每一个元素是一个key-value对，其内部通过单链表解决冲突问题，容量不足（超过了阀值）时，创建原来HashMap两倍大小的数组。默认初始容量是16，默认加载因子为0.75 。</p>
<p>HashMap的key做hash算法，并将hash值映射到内存地址（数组索引），直接取得key对应的value</p>
<p>HashMap把新元素放在链表的队首</p>
<p><img src="/2017/03/26/java-collection/HashMap.png" alt></p>
<h4 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据结点</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">	<span class="keyword">final</span> K key;</span><br><span class="line">	V value;</span><br><span class="line">	Node&lt;K,V&gt; next;</span><br><span class="line">	Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    	<span class="keyword">this</span>.hash = hash;</span><br><span class="line">    	<span class="keyword">this</span>.key = key;</span><br><span class="line">    	<span class="keyword">this</span>.value = value;</span><br><span class="line">    	<span class="keyword">this</span>.next = next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//储存元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果table为null，inflate 该table</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当key为null，调用putForNullKey方法，保存null与table第一个位置中，这是HashMap允许为null的原因</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="comment">// 根据key的hashcode进行计算hash值。</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 根据指定hash值在找到对应的table中的索引。 </span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 若 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素。</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="comment">// 判断该条链上是否有hash值相同的(key相同)</span></span><br><span class="line">        <span class="comment">// 若存在相同，则直接覆盖value，返回旧value</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果i索引处的Entry为null，表明此处还没有Entry。</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 将key、value添加到i索引处。</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当我们向HashMap中put元素的时候，先根据key的hashCode的值计算hash值，根据hash值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。addEntry(hash, key, value, i)方法根据计算出的hash值，将key-value对放在数组table的i索引处。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 如果 Map 中的 key-value 对的数量超过了极限</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span>!=table[bucketIndex]))&#123;</span><br><span class="line">        <span class="comment">// 把 table 对象的长度扩充到原来的2倍。 </span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据bucketIndex 获取对应的 Entry  </span></span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">// 将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry </span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 如果key = null时，返回null对应的value值。</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)  </span><br><span class="line">        <span class="keyword">return</span> getForNullKey(); </span><br><span class="line">    <span class="comment">// 根据key的hashcode值做hash获取对应的值</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.hashCode()); </span><br><span class="line">    <span class="comment">// 根据指定hash值在找到对应的table中的索引，并根据索引获取该处的Entry，通过循环不断遍历 e 元素的下一个元素。</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];  e != <span class="keyword">null</span>;  e = e.next) &#123;  </span><br><span class="line">        Object k;  </span><br><span class="line">        <span class="comment">// 判断e元素的hash与hash是否相等，如果相等并且e元素与key相等则返回e的原则的value</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))  </span><br><span class="line">            <span class="keyword">return</span> e.value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 如果指定hash值在找到对应的table中的索引，并根据索引获取该处的Entry的为null，则返回null。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//从HashMap中get元素时，首先计算key的hashCode，通过IndexFor(hash,table.length)找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。</span></span><br></pre></td></tr></table></figure>
<h4 id="线程安全-4"><a href="#线程安全-4" class="headerlink" title="线程安全"></a>线程安全</h4><p>HashMap是<strong>非线程安全</strong>的</p>
<blockquote>
<p>HashMap 在并发时可能出现的问题主要是两方面,首先如果多个线程同时使用put方法添加元素，而且假设正好存在两个 put 的 key 发生了碰撞(根据 hash 值计算的 bucket 一样)，那么根据 HashMap 的实现，这两个 key 会添加到数组的同一个位置，这样最终就会发生其中一个线程的 put 的数据被覆盖。第二就是如果多个线程同时检测到元素个数超过数组大小* loadFactor ，这样就会发生多个线程同时对 Node 数组进行扩容，都在重新计算元素位置以及复制数据，但是最终只有一个线程扩容后的数组会赋给 table，也就是说其他线程的都会丢失，并且各自线程 put 的数据也丢失。</p>
</blockquote>
<p>可以以下三种方法来实现线程安全</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; hashtable = <span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line">Map&lt;String, String&gt; synchronizedHashMap = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;String, String&gt;());</span><br><span class="line">Map&lt;String, String&gt; concurrentHashMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h4 id="1-8实现"><a href="#1-8实现" class="headerlink" title="1.8实现"></a>1.8实现</h4><p>采用数组+链表+红黑树，如果链表长度超过8，则改为红黑树</p>
<ol>
<li>先判断当前位置有没有值，没有则新建node插入</li>
<li>如果有值，则判断是否为同一个key，若是则更新，如不是再判断是否是红黑树</li>
<li>若还不是同一个key，遍历链表更新节点或在链表最后插入新节点</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="备注-4"><a href="#备注-4" class="headerlink" title="备注"></a>备注</h4><p>key最好是不可变的final对象，因为如果key可变，那下次获取键值对的时候，key的hashcode会和之前的不一样，而导致无法取出，如果一定要用可变对象的话，那就要重写这个对象的hashcode方法</p>
<p>HashMap可以key和value均可以为null</p>
<h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><h4 id="实现原理-9"><a href="#实现原理-9" class="headerlink" title="实现原理"></a>实现原理</h4><p>HashMap和Hashtable采用的是相同的存储机制，因此两者的实现基本一致。</p>
<h4 id="与HashMap区别"><a href="#与HashMap区别" class="headerlink" title="与HashMap区别"></a>与HashMap区别</h4><ul>
<li>HashMap可以key和value均可以为null，而HashTable则不可以。Hashtable不允许null的值，Hashtable的key为null的时候，HashTable调用put方法时，直接抛出NullPointerException。其它细微的差别还有，比如初始化Entry数组的大小等等。</li>
<li>Hashtable是线程安全的，内部的方法基本都是synchronized。HashMap则不是线程安全的。</li>
<li>Hashtable中的hash数组默认是11，增加方式old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。</li>
<li>哈希值的使用不同，HashTable直接使用对象的hashCode，而HashMap重新实现哈hash方法</li>
<li>HashMap继承的是AbstractMap，Hashtable继承的是Dictionary</li>
</ul>
<h4 id="线程安全-5"><a href="#线程安全-5" class="headerlink" title="线程安全"></a>线程安全</h4><p>Hashtable是<strong>线程安全</strong>的，因为方法上加了synchronized</p>
<h4 id="局限-1"><a href="#局限-1" class="headerlink" title="局限"></a>局限</h4><p>因为加了synchronized同步锁，获得的是对象锁，所以没有得到锁的其他线程会一直等待，影响效率</p>
<h4 id="备注-5"><a href="#备注-5" class="headerlink" title="备注"></a>备注</h4><p>Hashtable不能有null值</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><h4 id="实现原理-10"><a href="#实现原理-10" class="headerlink" title="实现原理"></a>实现原理</h4><h5 id="1-7实现"><a href="#1-7实现" class="headerlink" title="1.7实现"></a>1.7实现</h5><p>ConcurrentHashMap是使用了分段锁技术来保证线程安全的，底层采用数组+链表+红黑树的存储结构。分段锁技术：它相当于把一个数组分成好几段，每一段是一个 segment ，里面包含了一小段的hash table。segment继承了ReentrantLock，所以有自己的锁。当一个线程占用锁来访问其中一段数据的时候，其他段的数据也能被其他线程访问。但是如果有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。这里的按顺序是为了避免死锁。</p>
<blockquote>
<p>在ConcurrentHashMap内部，段数组是final的，并且其成员变量实际上也是final的，但是，仅仅是将数组声明为final的并不保证数组成员也是final的，这需要实现上的保证。这可以确保不会出现死锁，因为获得锁的顺序是固定的。</p>
<p>如果不是final，则有可能一段数据里包含了另一段数据的引用</p>
</blockquote>
<p><img src="/2017/03/26/java-collection/ConcurrentHashMap.png" alt></p>
<blockquote>
<p><strong>Segment继承ReentrantLock用来充当锁的角色</strong>，每个 Segment 对象守护每个散列映射表的若干个桶。</p>
<p>HashEntry 用来封装映射表的键 / 值对；</p>
<p>每个桶是由若干个 HashEntry 对象链接起来的链表。</p>
</blockquote>
<h4 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;  </span><br><span class="line">     <span class="keyword">final</span> K key;  </span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">int</span> hash;  </span><br><span class="line">     <span class="keyword">volatile</span> V value;    <span class="comment">//为了确保读操作能够看到最新的值，将value设置成volatile，这避免了加锁</span></span><br><span class="line">     <span class="keyword">final</span> HashEntry&lt;K,V&gt; next;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-8实现-1"><a href="#1-8实现-1" class="headerlink" title="1.8实现"></a>1.8实现</h5><p>1.8中放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现，底层依然采用数组+链表+红黑树的存储结构。当一个链表中的元素达到8个时，会调用treeifyBin()方法把链表结构转化成红黑树结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2017/03/26/java-collection/ConcurrentHashMap2.png" alt></p>
<h4 id="put实现"><a href="#put实现" class="headerlink" title="put实现"></a>put实现</h4><p>当执行put方法插入数据时，根据key的hash值，在Node数组中找到相应的位置，实现如下：</p>
<p>1、如果相应位置的Node还未初始化，则通过CAS插入相应的数据；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>, <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">        <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    binCount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">        K ek;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((ek = e.key) == key ||</span><br><span class="line">             (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">            oldVal = e.val;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                e.val = value;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;K,V&gt; pred = e;</span><br><span class="line">        <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">    Node&lt;K,V&gt; p;</span><br><span class="line">    binCount = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        oldVal = p.val;</span><br><span class="line">        <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">            p.val = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">        treeifyBin(tab, i);</span><br><span class="line">    <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount；</p>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p><strong>与Hashtable的区别</strong></p>
<p>Hashtable的synchronized是针对整张Hash表的，即每次锁住整张表让线程独占</p>
<p>ConcurrentHashMap分段锁是针对一部分数据的，segment数组里的每个元素单独加锁</p>
<p><strong>与Collections.synchronizedMap()的区别</strong></p>
<p>Collections.synchronizedMap()和Hashtable一样，实现上在调用map所有方法时，都对整个map进行同步，而ConcurrentHashMap的实现却更加精细，它对map中的所有桶加了锁。</p>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><h4 id="实现原理-11"><a href="#实现原理-11" class="headerlink" title="实现原理"></a>实现原理</h4><p>TreeMap实现了SortedMap接口，底层通过红黑树实现，也就是说会按照key的大小顺序对Map中的元素进行排序，key大小的评判可以通过其本身的自然顺序，也可以通过构造时传入的比较器（Comparator）</p>
<p><code>get(Object key)</code>方法根据指定的<code>key</code>值返回对应的<code>value</code>，该方法调用了<code>getEntry(Object key)</code>得到相应的<code>entry</code>，然后返回<code>entry.value</code>。因此<code>getEntry()</code>是算法的核心。算法思想是根据<code>key</code>的自然顺序（或者比较器顺序）对二叉查找树进行查找，直到找到满足<code>k.compareTo(p.key) == 0</code>的<code>entry</code>。</p>
<p><code>put(K key, V value)</code>方法是将指定的<code>key</code>, <code>value</code>对添加到<code>map</code>里。该方法首先会对<code>map</code>做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>getEntry()</code>方法；如果没有找到则会在红黑树中插入新的<code>entry</code>，如果插入之后破坏了红黑树的约束条件，还需要进行调整（旋转，改变某些节点的颜色）。</p>
<h4 id="线程安全-6"><a href="#线程安全-6" class="headerlink" title="线程安全"></a>线程安全</h4><p>TreeMap是<strong>非线程安全</strong>的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SortedMap m = Collections.synchronizedSortedMap(<span class="keyword">new</span> TreeMap(...));</span><br></pre></td></tr></table></figure>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p><img src="/2017/03/26/java-collection/red-black-tree.png" alt></p>
<p><strong>红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一倍</strong>。具体来说，红黑树是满足如下条件的二叉查找树（binary search tree）：</p>
<ol>
<li>每个节点要么是红色，要么是黑色。</li>
<li>根节点必须是黑色</li>
<li>红色节点不能连续（也即是，红色节点的孩子和父亲都不能是红色）。</li>
<li>对于每个节点，从该点至<code>null</code>（树尾端）的任何路径，都含有相同个数的黑色节点。</li>
<li>每个空叶子节点必须是黑色的；</li>
</ol>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><h4 id="实现原理-12"><a href="#实现原理-12" class="headerlink" title="实现原理"></a>实现原理</h4><p>LinkedHashMap是HashMap的直接子类，二者唯一的区别是LinkedHashMap在HashMap的基础上，采用双向链表的形式将所有entry连接起来，这样是为保证元素的迭代顺序跟插入顺序相同。</p>
<p><img src="/2017/03/26/java-collection/LinkedHashMap.png" alt></p>
<h4 id="优势-3"><a href="#优势-3" class="headerlink" title="优势"></a>优势</h4><p>迭代LinkedHashMap时不需要像HashMap那样遍历整个table，而只需要直接遍历header指向的双向链表即可</p>
<p>该双向链表的迭代顺序就是entry的插入顺序</p>
<h4 id="备注-6"><a href="#备注-6" class="headerlink" title="备注"></a>备注</h4><p>LinkedHashMap允许null值</p>
<p>本文参考：</p>
<p><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/0-Introduction.md" target="_blank" rel="noopener">https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/0-Introduction.md</a></p>
<p><a href="http://www.jianshu.com/u/90ab66c248e6" target="_blank" rel="noopener">http://www.jianshu.com/u/90ab66c248e6</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://barry215.github.io/2017/03/22/spring-review/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="frank">
      <meta itemprop="description" content="总有一天你是我的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="麦金">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/03/22/spring-review/" class="post-title-link" itemprop="url">Spring IOC&&AOP</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-03-22 15:23:51" itemprop="dateCreated datePublished" datetime="2017-03-22T15:23:51+08:00">2017-03-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-09 20:57:46" itemprop="dateModified" datetime="2017-08-09T20:57:46+08:00">2017-08-09</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><h4 id="Spring-IOC-Inverse-of-Control"><a href="#Spring-IOC-Inverse-of-Control" class="headerlink" title="Spring IOC (Inverse of Control)"></a>Spring IOC (Inverse of Control)</h4><p>思想：</p>
<p>IOC意思是控制反转，控制权由对象本身转向容器，由容器根据配置文件去创建实例并创建各个实例之间的依赖关系</p>
<p>这个容器叫做bean工厂；在Spring中，bean工厂创建的各个实例称作bean </p>
<p>原理：</p>
<p>利用java反射，就是在Spring运行时，bean工厂根据Spring的xml配置文件或扫描指定包下注解来动态地生成一个实例，并且调用对象里的方法的</p>
<p>Spring支持三种依赖注入方式，分别是属性（Setter方法）注入，接口注入和构造注入。</p>
<p>一般不采用接口注入，因为注入对象还必须实现某个接口，比较麻烦。</p>
<p><a href="http://www.paymoon.com:8001/index.php/2017/01/06/why-spring-ioc-mechanism-is-not-new-but-reflection/" target="_blank" rel="noopener">http://www.paymoon.com:8001/index.php/2017/01/06/why-spring-ioc-mechanism-is-not-new-but-reflection/</a></p>
<h4 id="SpringMVC运行原理"><a href="#SpringMVC运行原理" class="headerlink" title="SpringMVC运行原理"></a>SpringMVC运行原理</h4><ol>
<li>客户端请求提交到DispatcherServlet</li>
<li>由DispatcherServlet控制器查询HandlerMapping，找到并分发到指定的Controller中。</li>
<li>Controller调用业务逻辑处理后，返回ModelAndView</li>
<li>DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图</li>
<li>视图负责将结果显示到客户端</li>
</ol>
<p><img src="/2017/03/22/spring-review/SpringMVC.jpg" alt></p>
<p><a href="http://www.cnblogs.com/xiaoxing/p/5836835.html" target="_blank" rel="noopener">http://www.cnblogs.com/xiaoxing/p/5836835.html</a></p>
<h4 id="Resource跟-Autowired比较"><a href="#Resource跟-Autowired比较" class="headerlink" title="@Resource跟@Autowired比较"></a>@Resource跟@Autowired比较</h4><p>上面介绍中Controller中注入userService或者 Service层里面注入dao都是用@Resource标签，其实也可以使用@Autowired来替代，但是建议使用@Resource。下面说说这2者的区别：</p>
<ol>
<li><p>@Autowired和@Resource都可以用来装配bean，都可以写在字段上，或者方法上。</p>
</li>
<li><p>@Autowired属于Spring的；@Resource为JSR-250标准的注释，属于J2EE的。</p>
</li>
<li><p>@Autowired默认按类型装配，默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，例如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"baseDao"</span>)</span><br><span class="line"><span class="keyword">private</span> BaseDao baseDao;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@Resource，默认按照名称进行装配，名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取字段名进行安装名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span>(name=<span class="string">"baseDao"</span>)</span><br><span class="line"><span class="keyword">private</span> BaseDao baseDao;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>之所以推荐使用@Resource，因为这个注解是属于J2EE的，减少了与spring的耦合。这样代码看起就比较优雅。</li>
</ol>
</li>
</ol>
<p><a href="http://www.jianshu.com/p/135693f589c4" target="_blank" rel="noopener">http://www.jianshu.com/p/135693f589c4</a></p>
<h4 id="SpringAOP原理"><a href="#SpringAOP原理" class="headerlink" title="SpringAOP原理"></a>SpringAOP原理</h4><p>AOP是通过动态代理来实现的，有两种常用的技术，一是<code>JDK的动态代理</code>，二是<code>CGLIB</code>，而无论是前者还是后者，都是生成动态生成类的字节码来实现的。<code>JDK的动态代理只能处理接口实现的方法</code>，而CGLIB则没有这个限制。因为字节码是动态生成的，所以可以在生成的字节码当中，在目标方法前后插入定义好的方法的调用。</p>
<p>切面（Aspect）：一个关注点的模块化，这个关注点可能会横切多个对象。 在Spring  AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @Aspect 注解（@AspectJ风格）来实现</p>
<p>连接点（Joinpoint）： 在程序执行过程中某个特定的点，比如某方法调用的时候或者处理异常的时候。在Spring AOP中，一个连接点 总是  代表一个方法的执行。通过声明一个org.aspectj.lang.JoinPoint类型的参数可以使通知（Advice）的主体部分获得连接点信息。</p>
<p>通知（Advice）：在切面的某个特定的连接点（Joinpoint）上执行的动作。通知有各种类型，其中包括“around”、“before”和“after”等通知。通知的类型将在后面部分进行讨论。许多AOP框架，包括Spring，都是以拦截器做通知模型，并维护一个以连接点为中心的拦截器链。</p>
<p>切入点（Pointcut）：匹配连接点（Joinpoint）的断言。通知和一个切入点表达式关联，并在满足这个切入点的连接点上运行（例如，当执行某个特定名称的方法时）。切入点表达式如何和连接点匹配是AOP的核心：Spring缺省使用AspectJ切入点语法。</p>
<p>引入（Introduction）： （也被称为内部类型声明（inter-type declaration））。声明额外的方法或者某个类型的字段。  Spring允许引入新的接口（以及一个对应的实现）到任何被代理的对象。例如，你可以使用一个引入来使bean实现 IsModified  接口，以便简化缓存机制。</p>
<p>织入（Weaving）：  把切面（aspect）连接到其它的应用程序类型或者对象上，并创建一个被通知（advised）的对象。这些可以在编译时（例如使用AspectJ编译器），类加载时和运行时完成。  Spring和其他纯Java AOP框架一样，在运行时完成织入。</p>
<p>通知的类型：</p>
<p>前置通知（Before advice）： 在某连接点（join  point）之前执行的通知，但这个通知不能阻止连接点前的执行（除非它抛出一个异常）。</p>
<p>返回后通知（After returning advice）： 在某连接点（join  point）正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。</p>
<p>抛出异常后通知（After throwing advice）： 在方法抛出异常退出时执行的通知。</p>
<p>后通知（After (finally) advice）： 当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。</p>
<p>环绕通知（Around Advice）： 包围一个连接点（join  point）的通知，如方法调用。这是最强大的一种通知类型。环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它们自己的返回值或抛出异常来结束执行。</p>
<p>原接口：很多种方法定义</p>
<p>委托类：实现接口的方法</p>
<p>代理类：引用委托类实现方法的同时，额外做一些事情</p>
<h5 id="AOP速学路径"><a href="#AOP速学路径" class="headerlink" title="AOP速学路径"></a>AOP速学路径</h5><p><a href="https://segmentfault.com/a/1190000007469982" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007469982</a></p>
<h4 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h4><p>使用java反射机制，在运行期时，插入自定义的方法调用</p>
<p>具体是通过Proxy和InvocationHandler这个<strong>接口</strong>来实现的，InvocationHandler里有invoke(Object proxy, Method method, Object[] args)这个方法，它可以有委托类方法和参数引用，所以可以在invoke方法中围绕着委托类的方法做一些前置、后置操作</p>
<p>Proxy会用newProxyInstance(ClassLoader,interfaces,InvocationHandlerImpl)生成<strong>动态代理类</strong>，这个代理类会实现委托类的接口，当执行代理类的方法时，实际上是执行InvocationHandler的invoke方法，所以就实现了之前我们的前置、后置操作</p>
<h5 id="动态代理速学路径"><a href="#动态代理速学路径" class="headerlink" title="动态代理速学路径"></a>动态代理速学路径</h5><p><a href="https://segmentfault.com/a/1190000007089902" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007089902</a></p>
<p><a href="http://blog.csdn.net/qqHJQS/article/details/53402493" target="_blank" rel="noopener">http://blog.csdn.net/qqHJQS/article/details/53402493</a></p>
<h4 id="CGLIB代理"><a href="#CGLIB代理" class="headerlink" title="CGLIB代理"></a>CGLIB代理</h4><p>cglib是用asm框架生成的字节码文件，而且生成的<strong>动态代理类</strong>是<strong>委托类</strong>的子类，所以委托类不能是final</p>
<p>利用MethodInterceptor接口的intercept方法，可以在这个方法里调用invokeSuper来操作委托类方法，同样就可以围绕着委托类的方法做一些前置、后置操作</p>
<p>速学路径：</p>
<p><a href="http://www.deanwangpro.com/2017/02/08/aop-in-java/" target="_blank" rel="noopener">http://www.deanwangpro.com/2017/02/08/aop-in-java/</a></p>
<p><strong><a href="http://blog.csdn.net/panyongcsd/article/details/53204719" target="_blank" rel="noopener">http://blog.csdn.net/panyongcsd/article/details/53204719</a></strong></p>
<p><a href="http://www.importnew.com/20732.html" target="_blank" rel="noopener">http://www.importnew.com/20732.html</a></p>
<p><a href="http://www.jianshu.com/p/d35e46f27187" target="_blank" rel="noopener">http://www.jianshu.com/p/d35e46f27187</a></p>
<h4 id="Spring-AOP应用场景"><a href="#Spring-AOP应用场景" class="headerlink" title="Spring AOP应用场景"></a>Spring AOP应用场景</h4><p>性能检测，访问控制，日志管理，事务</p>
<h4 id="Spring-Bean的作用域区别"><a href="#Spring-Bean的作用域区别" class="headerlink" title="Spring Bean的作用域区别"></a>Spring Bean的作用域区别</h4><p>Spring容器中的bean可以分为5个范围。所有范围的名称都是自说明的，但是为了避免混淆，还是让我们来解释一下：</p>
<ol>
<li>singleton：这种bean范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个bean的实例，单例的模式由bean factory自身来维护。</li>
<li>prototype：原形范围与单例范围相反，为每一个bean请求提供一个实例。</li>
<li>request：在请求bean范围内会每一个来自客户端的网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。</li>
<li>Session：与请求范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。</li>
<li>global-session：global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。</li>
</ol>
<p>全局作用域与Servlet中的session作用域效果相同。</p>
<h4 id="Spring中的单例Beans是线程安全的吗"><a href="#Spring中的单例Beans是线程安全的吗" class="headerlink" title="Spring中的单例Beans是线程安全的吗"></a>Spring中的单例Beans是线程安全的吗</h4><p>不是，Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的Spring bean并没有可变的状态(比如Service类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。如果你的bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。Spring原理上使用ThreadLocal来保证单例安全的。</p>
<p>最浅显的解决办法就是将单态bean的作用域由<strong>“singleton</strong>”变更为“<strong>prototype</strong>”。<br>当然，scope的值不止这两种，还包括了request,session 等。但用的最多的还是singleton单态，prototype多态。<br>singleton表示该bean全局只有一个实例，Spring中bean的scope默认也是singleton.<br>prototype表示该bean在每次被注入的时候，都要重新创建一个实例，这种情况适用于有状态的Bean.</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://barry215.github.io/2017/03/11/algorithm-review/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="frank">
      <meta itemprop="description" content="总有一天你是我的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="麦金">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/03/11/algorithm-review/" class="post-title-link" itemprop="url">查找和排序算法大杂烩</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-03-11 09:45:30" itemprop="dateCreated datePublished" datetime="2017-03-11T09:45:30+08:00">2017-03-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-03 23:30:26" itemprop="dateModified" datetime="2017-08-03T23:30:26+08:00">2017-08-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>很多算法都一知半解，就是现在，一个个击破它们吧！</p>
</blockquote>
<h2 id="链表算法"><a href="#链表算法" class="headerlink" title="链表算法"></a>链表算法</h2><h3 id="反转单链"><a href="#反转单链" class="headerlink" title="反转单链"></a>反转单链</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单链表的转置,循环方法</span></span><br><span class="line">Node* reverseByLoop(Node *head)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == NULL || head-&gt;next == NULL)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    Node *pre = NULL;</span><br><span class="line">    Node *next = NULL;</span><br><span class="line">    <span class="keyword">while</span>(head != NULL)   <span class="comment">//总体来说就是进来一个，指向新链表一次，后面的链表由next保存</span></span><br><span class="line">    &#123;</span><br><span class="line">        next = head-&gt;next;<span class="comment">//保存之后的链表</span></span><br><span class="line">        head-&gt;next = pre; <span class="comment">//使当前的点指向之前生成的新链表</span></span><br><span class="line">        pre = head;       <span class="comment">//新链表指向当前点形成更新的链表</span></span><br><span class="line">        head = next;      <span class="comment">//当前元素变成之前的next的第一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链表倒数第k个节点"><a href="#链表倒数第k个节点" class="headerlink" title="链表倒数第k个节点"></a>链表倒数第k个节点</h3><blockquote>
<p>设置两个指针 p1、p2，首先 p1 和 p2 都指向 head，然后 p2 向前走 k 步，这样 p1 和 p2 之间就间隔 k 个节点，最后 p1 和 p2 同时向前移动，直至 p2 走到链表末尾</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  ListNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">    <span class="keyword">this</span>.val = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>||k&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode pre=head;</span><br><span class="line">    ListNode last=head;       </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(pre.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        pre=pre.next;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pre.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      pre = pre.next;</span><br><span class="line">      last=last.next;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>速学路径</p>
<p><a href="http://hanhailong.com/2016/02/25/Java%E5%8F%8D%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8%E5%AE%9E%E6%88%98/" target="_blank" rel="noopener">Java反转单链表实战</a></p>
<p><a href="http://wuchong.me/blog/2014/03/25/interview-link-questions/" target="_blank" rel="noopener">逆序、求倒数第K个节点，判断是否有环</a></p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>数组方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackArray</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;<span class="comment">//用数组实现</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top; <span class="comment">//栈顶指针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> size = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StackArray</span><span class="params">()</span></span>&#123;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        top = -<span class="number">1</span>; <span class="comment">//栈空的时候 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//压栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> element)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(top == size-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StackOverflowError();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            array[++top] = element;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//弹栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(top == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[top--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(top == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链表方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedStack</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Stack</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//不用容器或者数组等数据结构存储节点</span></span><br><span class="line">    <span class="comment">//Node定义一个节点类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">U</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> U item; <span class="comment">//存储的data</span></span><br><span class="line">        <span class="keyword">private</span> Node&lt;U&gt; next; <span class="comment">//类似指针</span></span><br><span class="line">        Node()&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node(U item, Node&lt;U&gt; next)&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> item == <span class="keyword">null</span> &amp;&amp; next == <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; top ; <span class="comment">//栈顶指针</span></span><br><span class="line">    LinkedStack()&#123;</span><br><span class="line">        top = <span class="keyword">new</span> Node&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//弹栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.isEmpty() == <span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        &#125;</span><br><span class="line">        T result = top.item;</span><br><span class="line">        <span class="keyword">if</span>(!top.end())</span><br><span class="line">        &#123;</span><br><span class="line">            top = top.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//压栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T element)</span></span>&#123;</span><br><span class="line">        top = <span class="keyword">new</span> Node&lt;T&gt;(element, top);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  top.end();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.isEmpty() == <span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        &#125;</span><br><span class="line">        T result = top.item;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考路径</p>
<p><a href="https://segmentfault.com/a/1190000002516799" target="_blank" rel="noopener">Stack的三种实现（数组，容器，链表）</a></p>
<h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><h3 id="字符串逆转"><a href="#字符串逆转" class="headerlink" title="字符串逆转"></a>字符串逆转</h3><p>数组方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">strReverseWithArray2</span><span class="params">(String string)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(string==<span class="keyword">null</span>||string.length()==<span class="number">0</span>)<span class="keyword">return</span> string;</span><br><span class="line">       <span class="keyword">int</span> length = string.length();</span><br><span class="line">       <span class="keyword">char</span> [] array = string.toCharArray();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length/<span class="number">2</span>;i++)&#123;</span><br><span class="line">           array[i] = string.charAt(length-<span class="number">1</span>-i);</span><br><span class="line">           array[length-<span class="number">1</span>-i] = string.charAt(i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> String(array);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>栈方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">strReverseWithStack</span><span class="params">(String string)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(string==<span class="keyword">null</span>||string.length()==<span class="number">0</span>)<span class="keyword">return</span> string;</span><br><span class="line">       Stack&lt;Character&gt; stringStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       <span class="keyword">char</span> [] array = string.toCharArray();</span><br><span class="line">       <span class="keyword">for</span>(Character c:array)&#123;</span><br><span class="line">           stringStack.push(c);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> length = string.length();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">           array[i] = stringStack.pop();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> String(array);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>参考路径</p>
<p><a href="http://www.cnblogs.com/JohnTsai/p/5606719.html" target="_blank" rel="noopener">http://www.cnblogs.com/JohnTsai/p/5606719.html</a></p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>二叉树遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序递归遍历</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrderRe</span><span class="params">(Node node,List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(list==<span class="keyword">null</span>)&#123;</span><br><span class="line">        list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        inOrderRe(node.left,list);</span><br><span class="line">    &#125;</span><br><span class="line">    list.add(node.data);</span><br><span class="line">    <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        inOrderRe(node.right,list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="comment">//根节点不为空</span></span><br><span class="line">        root = node;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node current = root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.data &lt;= current.data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                current.left = node;</span><br><span class="line">                size++;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                current.right = node;</span><br><span class="line">                size++;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h3><p>搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// while循环</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> end = arr.length - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> mid;</span><br><span class="line">	<span class="keyword">while</span>(start &lt;= end)&#123;</span><br><span class="line">		mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (val &lt; arr[mid]) &#123;</span><br><span class="line">			end = mid - <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span> (val &gt; arr[mid]) &#123;</span><br><span class="line">			start = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归版本</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> val,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (val &lt; arr[mid]) &#123;</span><br><span class="line">		binary_search(arr,val,start,mid-<span class="number">1</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span> (val &gt; arr[mid]) &#123;</span><br><span class="line">		binary_search(arr,val,mid+<span class="number">1</span>,end);</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> mid;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><ol>
<li>若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树；</li>
<li>没有键值相等的节点。</li>
</ol>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>升序是从小到大</p>
<p>降序是从大到小</p>
<p>速学路径</p>
<p><a href="http://www.jianshu.com/p/bbb7c838880f" target="_blank" rel="noopener">http://www.jianshu.com/p/bbb7c838880f</a></p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>说白了就是循环一遍，每个元素都按大小插到前面的序列里</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] list)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = list.length;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">int</span> j =  <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = list[i];</span><br><span class="line">        <span class="comment">//假如temp比前面的值小，则将前面的值后移</span></span><br><span class="line">        <span class="keyword">for</span>(j = i ; j &gt; <span class="number">0</span> &amp;&amp; temp &lt; list[j-<span class="number">1</span>] ; j --)</span><br><span class="line">        &#123;</span><br><span class="line">        	list[j] = list[j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        list[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>有间隔的直接插入排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="comment">//每次将步长缩短为原来的一半</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> increment = data.length / <span class="number">2</span>; increment &gt; <span class="number">0</span>; increment /= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = increment; i &lt; data.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = data[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &gt;= increment; j -= increment)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(temp &lt; data[j - increment])<span class="comment">//如想从小到大排只需修改这里</span></span><br><span class="line">                &#123;</span><br><span class="line">                    data[j] = data[j - increment];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            data[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆是一颗完全二叉树，除了最底层之外，每一层都是满的。</p>
<p>它有最大堆和最小堆之分</p>
<p>堆中每个父节点的元素值都<strong>大于等于</strong>其孩子结点的堆就是一个最大堆</p>
<p>那么相反，每个父节点都<strong>小于等于</strong>其孩子结点的堆就是一个最小堆</p>
<p>堆排序的时间复杂度为O(n*logn)</p>
<p>他的排序方法就是先形成一个堆</p>
<p>父节点和两个子节点进行比较，把最大的那个换到父节点上，然后那两个子节点就递归这个比较和交换</p>
<p>然后开始排序了</p>
<p>把堆顶的元素拿下，并且把最小的元素换到堆顶，然后形成一个新堆，然后循环这样的操作，取出来的元素就有序了</p>
<blockquote>
<p><strong>满二叉树</strong>：除了叶结点外<strong>每一个结点都有左右子叶</strong>且叶结点都处在最底层的二叉树；</p>
<p><strong>完全二叉树</strong>：只有最下面的两层结点度小于2，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树；</p>
<p>堆是一种完全二叉树或者近似完全二叉树</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arrayLength=a.length;</span><br><span class="line">    <span class="comment">//循环建堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arrayLength-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//建堆</span></span><br><span class="line">        buildMaxHeap(a,arrayLength-<span class="number">1</span>-i);</span><br><span class="line">        <span class="comment">//交换堆顶和最后一个元素</span></span><br><span class="line">        swap(a,<span class="number">0</span>,arrayLength-<span class="number">1</span>-i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对data数组从0到lastIndex建大顶堆</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> lastIndex)</span></span>&#123;</span><br><span class="line">    <span class="comment">//从lastIndex处节点（最后一个节点）的父节点开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=(lastIndex-<span class="number">1</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="comment">//k保存正在判断的节点</span></span><br><span class="line">        <span class="keyword">int</span> k=i;</span><br><span class="line">        <span class="comment">//如果当前k节点的子节点存在</span></span><br><span class="line">        <span class="keyword">while</span>(k*<span class="number">2</span>+<span class="number">1</span>&lt;=lastIndex)&#123;</span><br><span class="line">            <span class="comment">//k节点的左子节点的索引</span></span><br><span class="line">            <span class="keyword">int</span> biggerIndex=<span class="number">2</span>*k+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//如果biggerIndex小于lastIndex，即biggerIndex+1代表的k节点的右子节点存在</span></span><br><span class="line">            <span class="keyword">if</span>(biggerIndex&lt;lastIndex)&#123;</span><br><span class="line">                <span class="comment">//若果右子节点的值较大</span></span><br><span class="line">                <span class="keyword">if</span>(data[biggerIndex]&lt;data[biggerIndex+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="comment">//biggerIndex总是记录较大子节点的索引</span></span><br><span class="line">                    biggerIndex++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果k节点的值小于其较大的子节点的值</span></span><br><span class="line">            <span class="keyword">if</span>(data[k]&lt;data[biggerIndex])&#123;</span><br><span class="line">                <span class="comment">//交换他们</span></span><br><span class="line">                swap(data,k,biggerIndex);</span><br><span class="line">                <span class="comment">//将biggerIndex赋予k，开始while循环的下一次循环，重新保证k节点的值大于其左右子节点的值</span></span><br><span class="line">                k=biggerIndex;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=data[i];</span><br><span class="line">    data[i]=data[j];</span><br><span class="line">    data[j]=tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>将两个已经排序的序列合并成一个序列的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] gb_sort(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="comment">// 左边</span></span><br><span class="line">        gb_sort(nums, low, mid);</span><br><span class="line">        <span class="comment">// 右边</span></span><br><span class="line">        gb_sort(nums, mid + <span class="number">1</span>, high);</span><br><span class="line">        <span class="comment">// 左右归并</span></span><br><span class="line">        merge(nums, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = low;<span class="comment">// 左指针</span></span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;<span class="comment">// 右指针</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 把较小的数先移到新数组中</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; nums[j]) &#123;</span><br><span class="line">            temp[k++] = nums[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把左边剩余的数移入数组</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        temp[k++] = nums[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把右边边剩余的数移入数组</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">        temp[k++] = nums[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把新数组中的数覆盖nums数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k2 = <span class="number">0</span>; k2 &lt; temp.length; k2++) &#123;</span><br><span class="line">        nums[k2 + low] = temp[k2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>空间复杂度</strong></p>
<p>平均时间复杂度是logn，所以根据遍历次数，推出空间复杂度也是logn</p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><blockquote>
<p>从需要排序的数里面随便找出一个，然后，把<strong>比这个数小的放在这个数左边，比这个数大的放在这个数右边，一样大的和这个数放在一起</strong>，最后，<strong>左右两边各自重复上述过程</strong>，直到左边或右边只剩下一个数（或零个数）无法继续为止。</p>
</blockquote>
<p>取出第一个元素为基准，然后有两个指针，一个指向第二个元素，一个指向最后一个元素，先从最后一个进行比较，如果比基准大的话，就向前移向下一个，如果元素比基准小的话，就把那个元素替换到前面那个空位，然后前面的指针开始比较，如果比基准小，就移向向后下一个，如果比基准大，就替换到后面的那个空位。然后又变成后指针开始移动比较。这样的比较替换后，除去基准的那个元素，再分成前后两组，然后进行这个过程，直到前后两个指针重合，排序也就结束了。</p>
<p>快速排序不稳定，它的时间复杂度最好时为O(n<em>logn)，最差情况是O(n\</em>n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key = arr[start];</span><br><span class="line">    <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end &amp;&amp; key &lt;= arr[end])&#123;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[start] = arr[end];</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end &amp;&amp; key &gt;= arr[start])&#123;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[end] = arr[start];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[start] = key;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; end)&#123;</span><br><span class="line">        <span class="keyword">int</span> middle = partition(arr,start,end);</span><br><span class="line">        sort(arr,<span class="number">0</span>,middle-<span class="number">1</span>);</span><br><span class="line">        sort(arr,middle+<span class="number">1</span>,end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优化</strong></p>
<p>三值取中法： 待排序序列的前(第一个位置)、中(中间位置)、后(最后一个位置)三个记录中的中间值(按大小排序)作为枢轴</p>
<p><strong>空间复杂度</strong></p>
<p>就空间复杂度来说，主要是递归造成的栈空间的使用，最好情况，递归的深度为log2n，其空间复杂度也就为O(logn)，最坏情况，需要进行n‐1递归调用，其空间复杂度为O(n)，平均情况，空间复杂度也为O(logn)。</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ol>
<li>比较相邻的元素。 如果第一个比第二个大，就交换他们两个。</li>
<li>从开始第一对到结尾的最后一对，每对相邻元素都作同样的工作，。 这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> swaped;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        swaped = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> f = <span class="number">0</span>;f&lt;arr.length-i-<span class="number">1</span>;f++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[f] &gt; arr[f+<span class="number">1</span>])&#123;</span><br><span class="line">                temp = arr[f];</span><br><span class="line">                arr[f] = arr[f+<span class="number">1</span>];</span><br><span class="line">                arr[f+<span class="number">1</span>] = temp;</span><br><span class="line">                swaped = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!swaped)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>首先在序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max_index;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        max_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> f = <span class="number">0</span>;f&lt;arr.length-i;f++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[f] &gt; arr[max_index])&#123;</span><br><span class="line">                max_index = f;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[arr.length-i-<span class="number">1</span>];</span><br><span class="line">        arr[arr.length-i-<span class="number">1</span>] = arr[max_index];</span><br><span class="line">        arr[max_index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">radix_sort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] &gt; max)&#123;</span><br><span class="line">            max = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (max&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        max /= <span class="number">10</span>;</span><br><span class="line">        time++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> max_sd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] tempArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][array.length];</span><br><span class="line">    <span class="keyword">int</span>[] order = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">while</span> (m&lt;time)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sd = (array[i] / n) % <span class="number">10</span>;</span><br><span class="line">            tempArr[sd][order[sd]] = array[i];</span><br><span class="line">            order[sd]++;</span><br><span class="line">            <span class="keyword">if</span> (sd&gt;max_sd)&#123;</span><br><span class="line">                max_sd = sd;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;order[i] != <span class="number">0</span> &amp;&amp; j&lt;order[i];j++)&#123;</span><br><span class="line">                array[k++] = tempArr[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            order[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n *= <span class="number">10</span>;</span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        m++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>Algorithm</th>
<th>Average</th>
<th>Best</th>
<th>Worst</th>
<th>extra space</th>
<th>stable</th>
</tr>
</thead>
<tbody>
<tr>
<td>冒泡排序</td>
<td>O(N^2)</td>
<td>O(N)</td>
<td>O(N^2)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>直接插入排序</td>
<td>O(N^2)</td>
<td>O(N)</td>
<td>O(N^2)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(N^1.3)</td>
<td>O(N)</td>
<td>O(N^2)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>简单选择排序</td>
<td>O(N^2)</td>
<td>O(N^2)</td>
<td>O(N^2)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(NlogN)</td>
<td>O(NlogN)</td>
<td>O(N^2)</td>
<td>O(logN)~O(N^2)</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(NlogN)</td>
<td>O(NlogN)</td>
<td>O(NlogN)</td>
<td>O(N)</td>
<td>稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(NlogN)</td>
<td>O(NlogN)</td>
<td>O(NlogN)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>计数排序</td>
<td>O(d*(N+K))</td>
<td>O(d*(N+K))</td>
<td>O(d*(N+K))</td>
<td>O(N+K)</td>
<td>稳定</td>
</tr>
</tbody>
</table>
<h3 id="排序方法的选择"><a href="#排序方法的选择" class="headerlink" title="排序方法的选择"></a>排序方法的选择</h3><ol>
<li>若n较小(如n≤50)，可采用直接插入或直接选择排序。</li>
</ol>
<p>　当记录规模较小时，直接插入排序较好；否则因为直接选择移动的记录数少于直接插人，应选直接选择排序为宜。</p>
<ol start="2">
<li>若文件初始状态基本有序(指正序)，则应选用直接插人、冒泡或随机的快速排序为宜；</li>
<li>若n较大，则应采用时间复杂度为O(nlgn)的排序方法：快速排序、堆排序或归并排序。</li>
</ol>
<p>快速排序是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；<br>堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况。这两种排序都是不稳定的;<br>若要求排序稳定，则可选用归并排序。</p>
<blockquote>
<p>但本章介绍的从单个记录起进行两两归并的排序算法并不值得提倡，通常可以将它和直接插入排序结合在一起使用。先利用直接插入排序求得较长的有序子文件，然后再两两归并之。因为直接插入排序是稳定 的，所以改进后的归并排序仍是稳定的。</p>
</blockquote>
<p>参考资料：</p>
<p><a href="https://segmentfault.com/a/1190000004994003?f=tt&amp;hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#articleHeader22" target="_blank" rel="noopener">排序总结</a></p>
<p><a href="https://segmentfault.com/a/1190000002595152" target="_blank" rel="noopener">常用排序算法总结(性能+代码)</a></p>
<p><a href="https://segmentfault.com/a/1190000009069319" target="_blank" rel="noopener">Java常用的八种排序算法与代码实现精解</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">frank</p>
              <div class="site-description motion-element" itemprop="description">总有一天你是我的</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">29</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">18</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">27</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">frank</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.1.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
    
  
  <script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.1"></script>

  <script src="/js/motion.js?v=7.1.1"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.1"></script>




  

  


  <script src="/js/next-boot.js?v=7.1.1"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
