<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.1.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="多线程之前了解的有点乱，特此整理  锁类型公平性：  公平锁：线程按照他们发出请求的顺序来获得锁。如果有另一个线程持有这个锁或者有其他线程在队列中等待这个锁，那么新发出请求的线程将放入队列中。 非公平锁：非公平锁允许“插队”：当一个线程请求非公平的锁时，如果在发出请求的同时该锁的状态变为可用，那么这个线程将跳过排队队列，直接获取这个锁。   也就是说非公平锁在入队同时可以强锁，如果没抢到就得排队">
<meta name="keywords" content="java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java多线程详解">
<meta property="og:url" content="https://barry215.github.io/2017/03/27/java-thread/index.html">
<meta property="og:site_name" content="麦金">
<meta property="og:description" content="多线程之前了解的有点乱，特此整理  锁类型公平性：  公平锁：线程按照他们发出请求的顺序来获得锁。如果有另一个线程持有这个锁或者有其他线程在队列中等待这个锁，那么新发出请求的线程将放入队列中。 非公平锁：非公平锁允许“插队”：当一个线程请求非公平的锁时，如果在发出请求的同时该锁的状态变为可用，那么这个线程将跳过排队队列，直接获取这个锁。   也就是说非公平锁在入队同时可以强锁，如果没抢到就得排队">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://barry215.github.io/2017/03/27/java-thread/java-thread/ThreadLocal.png">
<meta property="og:image" content="https://barry215.github.io/2017/03/27/java-thread/java-thread/threadapi.png">
<meta property="og:image" content="https://barry215.github.io/2017/03/27/java-thread/java-thread/ThreadLife.png">
<meta property="og:image" content="https://barry215.github.io/2017/03/27/java-thread/java-thread/Executor.png">
<meta property="og:image" content="https://barry215.github.io/2017/03/27/java-thread/java-thread/ThreadPool.png">
<meta property="og:image" content="https://barry215.github.io/2017/03/27/java-thread/java-thread/corePoolSize.png">
<meta property="og:image" content="https://barry215.github.io/2017/03/27/java-thread/java-thread/ForkJoinPool.png">
<meta property="og:updated_time" content="2018-02-06T06:07:34.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java多线程详解">
<meta name="twitter:description" content="多线程之前了解的有点乱，特此整理  锁类型公平性：  公平锁：线程按照他们发出请求的顺序来获得锁。如果有另一个线程持有这个锁或者有其他线程在队列中等待这个锁，那么新发出请求的线程将放入队列中。 非公平锁：非公平锁允许“插队”：当一个线程请求非公平的锁时，如果在发出请求的同时该锁的状态变为可用，那么这个线程将跳过排队队列，直接获取这个锁。   也就是说非公平锁在入队同时可以强锁，如果没抢到就得排队">
<meta name="twitter:image" content="https://barry215.github.io/2017/03/27/java-thread/java-thread/ThreadLocal.png">





  
  
  <link rel="canonical" href="https://barry215.github.io/2017/03/27/java-thread/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Java多线程详解 | 麦金</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">麦金</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">麦金的博客</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://barry215.github.io/2017/03/27/java-thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="frank">
      <meta itemprop="description" content="总有一天你是我的">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="麦金">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java多线程详解

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-03-27 10:48:22" itemprop="dateCreated datePublished" datetime="2017-03-27T10:48:22+08:00">2017-03-27</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-02-06 14:07:34" itemprop="dateModified" datetime="2018-02-06T14:07:34+08:00">2018-02-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>多线程之前了解的有点乱，特此整理</p>
</blockquote>
<h3 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h3><p><strong>公平性：</strong></p>
<ol>
<li>公平锁：线程按照他们发出请求的顺序来获得锁。如果有另一个线程持有这个锁或者有其他线程在队列中等待这个锁，那么新发出请求的线程将放入队列中。</li>
<li>非公平锁：非公平锁允许“插队”：当一个线程请求非公平的锁时，如果在发出请求的同时该锁的状态变为可用，那么这个线程将跳过排队队列，直接获取这个锁。</li>
</ol>
<blockquote>
<p>也就是说非公平锁在入队同时可以强锁，如果没抢到就得排队，公平锁只能排队</p>
</blockquote>
<p><strong>悲观／乐观：</strong></p>
<ol>
<li><p>悲观锁：把数据库里的某行数据锁住，或者整张表锁住，不让其他事务访问，数据库里一般会使用排它锁来实现悲观锁，但是因为其他事务不能访问，所以效率很低，适合数据竞争激烈的环境。可以防脏读。</p>
</li>
<li><p>乐观锁：在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。它可以让各事务能够在不产生锁的情况下处理各自影响的那部分数据。</p>
<p>乐观锁是基于CAS实现的，为了解决ABA问题，可以加上version的方法解决</p>
</li>
</ol>
<p><strong>排他(独占)／共享：</strong></p>
<ol>
<li>排他锁：只能有1个线程持有锁,可以有效的防止脏读</li>
<li>共享锁：共享锁不会阻止其他用户读，但是阻止其他的用户写和修改</li>
</ol>
<h5 id="锁状态"><a href="#锁状态" class="headerlink" title="锁状态"></a>锁状态</h5><blockquote>
<p>锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）</p>
</blockquote>
<p><strong>偏向锁：</strong></p>
<p>适合只有一个线程访问同步代码的场景</p>
<p>只要加了一次锁，之后访问里面的临界区都不用再加锁</p>
<p><strong>自旋锁：</strong></p>
<p>自身空循环来等待，然后再CAS请求锁</p>
<p><strong>轻量级锁：</strong></p>
<p>b线程在锁竞争时，发现锁已经被a线程占用，则b线程不进入内核态，让b线程自旋，执行空循环，等待a线程释放锁。如果，完成自旋策略执行CAS换锁操作，发现a线程还是没有释放锁，或者让c线程占用了。则b线程试图将轻量级锁升级为重量级锁。始终得不到锁竞争的线程使用自旋会消耗CPU。</p>
<p><strong>重量级锁：</strong></p>
<p>线程竞争不使用自旋，不会消耗CPU    线程阻塞，响应时间缓慢，适合追求吞吐量,锁占用时间较长</p>
<table>
<thead>
<tr>
<th><strong>锁</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距</td>
<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td>
<td>适用于只有一个线程访问同步块场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度</td>
<td>如果始终得不到索竞争的线程，使用自旋会消耗CPU</td>
<td>追求响应速度，同步块执行速度非常快</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋，不会消耗CPU</td>
<td>线程阻塞，响应时间缓慢</td>
<td>追求吞吐量，同步块执行速度较长</td>
</tr>
</tbody>
</table>
<p><strong>另外</strong></p>
<p>可重入锁：当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2。</p>
<p><strong>速学路径</strong></p>
<p><a href="http://kaimingwan.com/post/java/javanei-zhi-suo-kai-xiao-you-hua-pian-xiang-suo-qing-liang-ji-suo" target="_blank" rel="noopener">http://kaimingwan.com/post/java/javanei-zhi-suo-kai-xiao-you-hua-pian-xiang-suo-qing-liang-ji-suo</a></p>
<h3 id="CAS介绍"><a href="#CAS介绍" class="headerlink" title="CAS介绍"></a>CAS介绍</h3><p>CAS（Compare and Swap）即比较并替换，设计并发算法时常用到的一种技术。返回boolean值。</p>
<p>CAS是通过unsafe类的compareAndSwap方法实现的，是底层实现的原子指令</p>
<p>CAS用户程序不用直接调用，但是automicInteger内实现了这些方法，比如incrementAndGet()方法实际上就是不断循环CAS操作，直到成功</p>
<h4 id="具体说明"><a href="#具体说明" class="headerlink" title="具体说明"></a>具体说明</h4><p>赋值操作即是新值替换旧值，所以先比较现在的值是否为自己所以为的旧值，如果不是，则说明自己发生了脏读。本次操作失败返回false。</p>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p>
<h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p>就是一个变量V，如果变量V初次读取的时候是A，并且在准备赋值的时候检查到它仍然是A，那能说明它的值没有被其他线程修改过了吗？如果在这段期间它的值曾经被改成了B，然后又改回A，那CAS操作就会误认为它从来没有被修改过。</p>
<p>ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1。java并发包中提供了一个带有标记的原子引用类”AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。</p>
<h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p>java.util.concurrent包完全建立在CAS之上的，乐观锁就是基于CAS。</p>
<p>java.util.concurrent.atomic包下的原子操作类都是基于CAS实现的</p>
<h3 id="AQS介绍"><a href="#AQS介绍" class="headerlink" title="AQS介绍"></a>AQS介绍</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">  <span class="comment">// 等待对列的头节点</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line">  <span class="comment">// 等待队列的尾节点</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">  <span class="comment">// 同步状态</span></span><br><span class="line">  <span class="keyword">private</span> valatile <span class="keyword">int</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;<span class="comment">//该节点的状态</span></span><br><span class="line">	<span class="keyword">volatile</span> Node prev;<span class="comment">//同步等待队列前驱节点</span></span><br><span class="line">	<span class="keyword">volatile</span> Node next;<span class="comment">//同步等待队列后继节点</span></span><br><span class="line">	<span class="keyword">volatile</span> Thread thread;<span class="comment">//持有该节点的线程</span></span><br><span class="line">	Node nextWaiter;<span class="comment">//存储condition队列中的后继节点。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tryAcquire()修改状态，获取锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">	selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加入到等待队列，用cas原子替换tail，防止多线程错误</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failur</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不断循环获取队列前一个node，如果是头结点，则再次尝试修改state，获取锁，不然被阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>队列同步器AQS是用来构建锁或其他同步组件的基础框架，内部使用了一个int类型的volatile修饰的state来表示同步状态，通过acquire来尝试修改state的值（未实现），修改成功的线程表示获取到该锁，没有修改成功，或者发现状态state已经是加锁状态，则把当前线程包装成一个node节点，并通过CAS指令插入到FIFO等待队列的队尾。node插入到队尾后该线程不会马上挂起，而是进行自旋操作。如果前一个节点是头结点，他会自旋后再次尝试tryAcquire方法获取锁。只有当前一个节点pred的线程状态位SIGNAL时，当前节点的线程才能被挂起，并等待被唤醒。等待队列的头节点head和尾结点tail都是通过volatile修饰，保证了多个线程之间的可见性。</p>
<h3 id="synchronized介绍"><a href="#synchronized介绍" class="headerlink" title="synchronized介绍"></a>synchronized介绍</h3><p>synchronized是java语言的关键字，由jvm实现的语法级别的锁机制。是一种可重入/非公平/悲观/独占锁。</p>
<p>原理：</p>
<p>synchronized可以对一个代码块或是对一个方法上锁，方法块的原理是使用monitorenter和monitorexit指令，被“锁住”的地方称为临界区。线程执行到 monitorenter 指令时，将会尝试获取对象所对应的 monitor 的所有权，即尝试获得对象的锁，这样其他尝试进入临界区的线程会因无法获取monitor而被阻塞。由于等待另一个线程释放monitor而被阻塞的线程无法被中断。</p>
<p>同步方法 并不是由 monitorenter 和 monitorexit 指令来实现同步的，而是由方法调用指令读取运行时常量池中方法的 ACC_SYNCHRONIZED 标志来隐式实现的</p>
<blockquote>
<p>monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，每个monitorenter必须有一个monitorexit对应。</p>
</blockquote>
<p>Java中的每个对象都可以作为锁。</p>
<blockquote>
<p>任何对象都有一个 monitor 与之关联，当且一个monitor 被持有后，它将处于锁定状态</p>
</blockquote>
<ol>
<li>普通同步方法，锁是当前实例对象。</li>
<li>静态同步方法，锁是当前类的class对象。</li>
<li>同步代码块，锁是括号中的对象。</li>
</ol>
<p>作用于一段代码或方法，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到物理内存中。因此可以保证<strong>可见性</strong>，也能够保证<strong>原子性</strong>，synchronized修饰方法是获得对象锁</p>
<h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="comment">// todo</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写法一修饰的是一个方法，写法二修饰的是一个代码块，但写法一与写法二是等价的，都是锁定了整个方法时的内容。</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadlockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="keyword">new</span> String(<span class="string">"资源1"</span>);</span><br><span class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">"资源2"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Lock(str1, str2), <span class="string">"线程1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Lock(str2, str1), <span class="string">"线程2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String str1;</span><br><span class="line">    <span class="keyword">private</span> String str2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Lock</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.str1 = str1;</span><br><span class="line">        <span class="keyword">this</span>.str2 = str2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"运行"</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (str1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"锁住"</span> + str1);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (str2) &#123;</span><br><span class="line">                    <span class="comment">// 执行不到这里</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"锁住"</span> + str2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="效率低"><a href="#效率低" class="headerlink" title="效率低"></a>效率低</h4><p>监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从<strong>用户态</strong>转换到<strong>核心态</strong>，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因</p>
<h4 id="备注-1"><a href="#备注-1" class="headerlink" title="备注"></a>备注</h4><ol>
<li>synchronized关键字不能继承。</li>
<li>在定义接口方法时不能使用synchronized关键字。</li>
<li>构造方法不能使用synchronized关键字，但可以使用synchronized代码块来进行同步。</li>
<li>一个线程访问一个对象中的synchronized(this)同步代码块时，其他试图访问该对象的线程将被阻塞。</li>
</ol>
<p><a href="https://segmentfault.com/a/1190000004453860" target="_blank" rel="noopener">synchronized实现死锁</a></p>
<h3 id="Lock介绍"><a href="#Lock介绍" class="headerlink" title="Lock介绍"></a>Lock介绍</h3><p>Lock是Java 5以后引入的新的API</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取锁，否则会一直等待</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;    </span><br><span class="line">    <span class="comment">//获取锁，否则一直等待，但是等待状态可以被其他线程中断</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">//尝试获得锁，没抢到直接返回失败</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;        </span><br><span class="line">    <span class="comment">//尝试获取锁，没抢到则会等待一段时间，等待状态可以被其他线程中断</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//生成锁的条件变量，线程获取锁后，可以等待或者通知该条件变量</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Lock lock= ...;<span class="comment">//获取锁</span></span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="comment">//处理任务</span></span><br><span class="line">	&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>synchronized和Lock区别</strong></p>
<p><strong>相同点</strong></p>
<p>Lock 能完成synchronized所实现的所有功能</p>
<p><strong>不同点</strong></p>
<ul>
<li>synchronized会自动释放锁，而Lock一定要求程序员手工释放，且最好在finally 块中释放（否则会出现死锁）</li>
<li>通过Lock可以知道有没有成功获取锁，而synchronized却无法办到</li>
<li>synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生。Lock在发生异常时，如果没有主动通过unLock()方法去释放锁，则很可能造成死锁的现象，因此使用Lock时需要在finally块中释放锁</li>
</ul>
<h3 id="ReentrantLock介绍"><a href="#ReentrantLock介绍" class="headerlink" title="ReentrantLock介绍"></a>ReentrantLock介绍</h3><p>ReentrantLock实现了 Lock 接口，并提供了与 synchronized 相同的互斥和内存可见性</p>
<p>ReentrantLock 是可重入锁，根据构造器传入的布尔值来决定是否要公平锁</p>
<p>ReentrantLock是基于AQS实现的</p>
<h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><p>可重入锁中可重入表示的意义在于<strong>对于同一个线程，可以继续调用加锁的方法，而不会被挂起</strong>。可重入锁内部维护一个计数器，对于同一个线程调用lock方法，计数器+1，调用unlock方法，计数器-1</p>
<p>举例：在一个加锁方法execute中调用另外一个加锁方法anotherLock并不会被挂起，可以直接调用</p>
<blockquote>
<p>调用execute方法时计数器+1，然后内部又调用了anotherLock方法，计数器+1，变成了2</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" do something synchronize"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            anotherLock();</span><br><span class="line">            Thread.sleep(<span class="number">5000l</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(Thread.currentThread().getName() + <span class="string">" interrupted"</span>);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anotherLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" invoke anotherLock"</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span> <span class="keyword">do</span> something synchronize</span><br><span class="line">Thread-<span class="number">0</span> invoke anotherLock</span><br><span class="line"><span class="comment">// 隔了5秒钟 输入下面</span></span><br><span class="line">Thread-<span class="number">1</span> <span class="keyword">do</span> something synchronize</span><br><span class="line">Thread-<span class="number">1</span> invoke anotherLock</span><br></pre></td></tr></table></figure>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ol>
<li>lock()，如果获取了锁立即返回，如果别的线程持有锁，当前线程则一直处于休眠状态，直到获取锁</li>
<li>tryLock()，如果获取了锁立即返回true，如果别的线程正持有锁，立即返回false；</li>
<li>tryLock(long timeout,TimeUnit unit)，如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false；</li>
<li>lockInterruptibly，如果获取了锁定立即返回，如果没有获取锁定，当前线程处于休眠状态，这期间当前线程可以被中断。举个粟子，当A，B线程都试图使用lockInterruptibly()获取锁时，如果A获得了锁，B线程正在等待获取锁，则可以调用threadB.interrupt()能够中断线程B的等待。</li>
</ol>
<h4 id="举例-3"><a href="#举例-3" class="headerlink" title="举例"></a>举例</h4><p>线程A和B都要获取对象O的锁定，假设A获取了对象O锁，B将等待A释放对O的锁定，如果使用 synchronized ，如果A不释放，B将一直等下去，不能被中断如果 使用ReentrantLock，如果A不释放，可以使B在等待了足够长的时间以后，中断等待，而干别的事情</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Condition condition = lock.newCondition();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">while</span>(条件判断表达式) &#123;</span><br><span class="line">      condition.await();</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 处理逻辑</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="和synchronized区别"><a href="#和synchronized区别" class="headerlink" title="和synchronized区别"></a>和synchronized区别</h4><table>
<thead>
<tr>
<th></th>
<th>synchronized</th>
<th>ReentrantLock</th>
</tr>
</thead>
<tbody>
<tr>
<td>获取锁方式</td>
<td>抢锁失败只能无限等待</td>
<td>提供多种等待锁方式，可以中断正在等候获取一个锁的线程</td>
</tr>
<tr>
<td></td>
<td></td>
<td>可以限制等待超时</td>
</tr>
<tr>
<td></td>
<td></td>
<td>等待时可以被中断</td>
</tr>
<tr>
<td></td>
<td></td>
<td>可以<strong>无阻塞</strong>尝试获取锁</td>
</tr>
<tr>
<td>等待线程调度</td>
<td>未知，视 JVM 实现</td>
<td>公平锁：FIFO，按照进入同步队列顺序</td>
</tr>
<tr>
<td></td>
<td></td>
<td>非公平锁：<strong>第一次</strong>获取锁时有机会插队</td>
</tr>
<tr>
<td>编程便利性</td>
<td>获取锁/等待锁/释放锁都有内部实现，使用便利</td>
<td>需要显示获取锁，释放锁，切记<strong>要捕捉 exception， 在 finally 中释放锁</strong></td>
</tr>
<tr>
<td>性能</td>
<td>略低，Java6 后有显著提高</td>
<td>较高，Java6 后差距减小</td>
</tr>
<tr>
<td>调试</td>
<td>线程转储中给出哪些调用帧获得哪些锁</td>
<td>Java6 后提供管理和调试接口，锁需要通过该接口注册，相关加锁信息出现在线程转储中</td>
</tr>
</tbody>
</table>
<p><strong>总结</strong></p>
<p>Synchronized 与Lock都是可重入锁，同一个线程再次进入同步代码的时候.可以使用自己已经获取到的锁。</p>
<p>Synchronized是悲观锁机制，独占锁。而Locks.ReentrantLock是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。 ReentrantLock适用场景</p>
<ol>
<li>某个线程在等待一个锁的控制权的这段时间需要中断</li>
<li>需要分开处理一些wait-notify，ReentrantLock里面的Condition应用，能够控制notify哪个线程，锁可以绑定多个条件。</li>
<li>具有公平锁功能，每个到来的线程都将排队等候。</li>
</ol>
<h3 id="Condition介绍"><a href="#Condition介绍" class="headerlink" title="Condition介绍"></a>Condition介绍</h3><p>Condition是为解决Object.wait/notify/notifyAll难以使用的问题</p>
<p>一个ReentrantLock对象可以有多个Condition对象</p>
<blockquote>
<p>Condition的await方法代替Object的wait；<br>Condition的signal方法代替Object的notify方法；<br>Condition的signalAll方法代替Object的notifyAll方法；<br>Condition实例在使用时需要绑定到一个锁上，可以通过newCondition方法获取Condition实例。</p>
</blockquote>
<h4 id="举例-4"><a href="#举例-4" class="headerlink" title="举例"></a>举例</h4><p>一个线程调用<code>condition.await()</code>，此线程就会释放锁，阻塞。当另一个线程调用相同的condition的signal时，它才会重新竞争锁，然后从之前阻塞的地方继续开始。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">final</span> Condition condition = reentrantLock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    reentrantLock.lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"在等待被唤醒"</span>);</span><br><span class="line">                    condition.await();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"恢复执行了"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    reentrantLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"thread1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    reentrantLock.lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"抢到了锁"</span>);</span><br><span class="line">                    condition.signal();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"唤醒其它等待的线程"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    reentrantLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"thread2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thread1在等待被唤醒</span><br><span class="line">thread2抢到了锁</span><br><span class="line">thread2唤醒其它等待的线程</span><br><span class="line">thread1恢复执行了</span><br></pre></td></tr></table></figure>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ol>
<li><strong>await()</strong></li>
</ol>
<p><strong>调用await方法后，当前线程在接收到唤醒信号之前或被中断之前一直处于等待休眠状态。</strong>调用此方法时，当前线程保持了与此Condition有关联的锁，<strong>调用此方法后，当前线程释放持有的锁</strong>。此方法在返回当前线程之前，都必须重新获取与此条件有关的锁，在线程返回时，可以保证它保持此锁</p>
<ol start="2">
<li><strong>await(long time,TimeUnit unit)</strong></li>
</ol>
<p><strong>调用此方法后，会造成当前线程在接收到唤醒信号之前、被中断之前或到达指定等待时间之前一直处于等待状态。</strong>调用此方法时，当前线程保持了与此Condition有关联的锁，<strong>调用此方法后，当前线程释放持有的锁</strong>。time参数为最长等待时间；unit参数为time的时间单位。如果在从此方法返回前检测到等待时间超时，则返回 false，否则返回true。此方法在返回当前线程之前，都必须重新获取与此条件有关的锁，在线程返回时，可以保证它保持此锁。</p>
<ol start="3">
<li><strong>signal()</strong></li>
</ol>
<p><strong>唤醒一个等待线程，如果所有的线程都在等待此条件，则选择其中的一个唤醒。</strong>在从await返回之前，该线程必须重新获取锁。</p>
<ol start="4">
<li><strong>signalAll()</strong></li>
</ol>
<p><strong>唤醒所有等待线程，如果所有的线程都在等待此条件，则唤醒所有线程。</strong> 在从await返回之前，每个线程必须重新获取锁。</p>
<h4 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h4><blockquote>
<p>生产者消费者的实现</p>
<ol>
<li>通过java阻塞队列</li>
<li>wait，notify或await，signal的方式</li>
<li>通过不断轮询地cas</li>
<li>通过观察者模式</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();<span class="comment">//锁对象  </span></span><br><span class="line"> <span class="keyword">final</span> Condition notFull  = lock.newCondition();<span class="comment">//写线程条件   </span></span><br><span class="line"> <span class="keyword">final</span> Condition notEmpty = lock.newCondition();<span class="comment">//读线程条件   </span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];<span class="comment">//缓存队列  </span></span><br><span class="line"> <span class="keyword">int</span> putptr<span class="comment">/*写索引*/</span>, takeptr<span class="comment">/*读索引*/</span>, count<span class="comment">/*队列中存在的数据个数*/</span>;  </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">   lock.lock();  </span><br><span class="line">   <span class="keyword">try</span> &#123;  </span><br><span class="line">     <span class="keyword">while</span> (count == items.length)<span class="comment">//如果队列满了   </span></span><br><span class="line">       notFull.await();<span class="comment">//阻塞写线程  </span></span><br><span class="line">     items[putptr] = x;<span class="comment">//赋值   </span></span><br><span class="line">     <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;<span class="comment">//如果写索引写到队列的最后一个位置了，那么置为0  </span></span><br><span class="line">     ++count;<span class="comment">//个数++  </span></span><br><span class="line">     notEmpty.signal();<span class="comment">//唤醒读线程  </span></span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">     lock.unlock();  </span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">   lock.lock();  </span><br><span class="line">   <span class="keyword">try</span> &#123;  </span><br><span class="line">     <span class="keyword">while</span> (count == <span class="number">0</span>)<span class="comment">//如果队列为空  </span></span><br><span class="line">       notEmpty.await();<span class="comment">//阻塞读线程  </span></span><br><span class="line">     Object x = items[takeptr];<span class="comment">//取值   </span></span><br><span class="line">     <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;<span class="comment">//如果读索引读到队列的最后一个位置了，那么置为0  </span></span><br><span class="line">     --count;<span class="comment">//个数--  </span></span><br><span class="line">     notFull.signal();<span class="comment">//唤醒写线程  </span></span><br><span class="line">     <span class="keyword">return</span> x;  </span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">     lock.unlock();  </span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>注意</p>
<p>上面代码中使用while来判断队列，而不是用if，是因为多线程情况下，唤醒了wait状态的线程，如果保证不了它是想要的那个线程，那就用while来多判断一次缓冲队列的状态</p>
<ul>
<li>一种是wait和notify体系，消费者一次消费结束，notify了另一个阻塞的消费者，而那个消费者没有做再一次的判断，所以会造成多消费</li>
<li>一种是普遍模式，如果生产者生产了，然后唤醒了一个消费者，但是不幸又来了一个消费者提前把生产的消费了，所以这个被唤醒的消费者，如果不再一次进行检查，那会造成又一次的消费</li>
</ul>
<p>所以wait一定要放在while语句里</p>
<p>参考路径：</p>
<p><a href="http://www.jianshu.com/p/8123b85cdc87" target="_blank" rel="noopener">生产者消费者的五种实现</a></p>
<p><a href="http://blog.csdn.net/u011784767/article/details/51656697" target="_blank" rel="noopener">生产者和消费者的例子，有解释</a></p>
<p><a href="https://juejin.im/entry/5800896fa22b9d005b2cd766" target="_blank" rel="noopener">Java 多线程之并发协作生产者消费者设计模式</a></p>
<h3 id="volatile介绍"><a href="#volatile介绍" class="headerlink" title="volatile介绍"></a>volatile介绍</h3><p>volatile关键字提供了内存可见性和禁止内存重排序</p>
<h4 id="具体说明-1"><a href="#具体说明-1" class="headerlink" title="具体说明"></a>具体说明</h4><ul>
<li>某一个线程修改了被volatile修饰的变量之后，会立即把值更新到主内存，其他线程获取这个变量的时候不会在工作内存中拿取，而是直接去主内存中拿取，保证了<strong>可见性</strong></li>
<li>volatile可以禁止进行指令重排，保证了<strong>有序性</strong></li>
</ul>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>volatile是基于内存屏障（Memory Barrier）实现的</p>
<blockquote>
<p>内存屏障，又称内存栅栏，是一个CPU指令，基本上它是一条这样的指令：<br>1、插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。<br>2、强制更新一次不同CPU的缓存。例如，一个写屏障会把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程将得到最新值，而不用考虑到底是被哪个cpu核心或者哪颗CPU执行的。<br>3、如果你的字段是volatile，Java内存模型将在写操作后插入一个写屏障指令，在读操作前插入一个读屏障指令。这意味着如果你对一个volatile字段进行写操作，你必须知道：1、一旦你完成写入，任何访问这个字段的线程将会得到最新的值。2、在你写入前，会保证所有之前发生的事已经发生，并且任何更新过的数据值也是可见的，因为内存屏障会把之前的写入值都刷新到缓存。</p>
</blockquote>
<p><strong>原子性原理</strong></p>
<p>即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
<p>比如<code>x++</code>包括3个操作：</p>
<p>1）读取volatile变量值到local； 2）增加变量的值；3）把local的值写回，让其它的线程可见。</p>
<p>这3步的jvm指令为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov    <span class="number">0xc</span>(%r10),%r8d ; Load</span><br><span class="line">inc    %r8d           ; Increment</span><br><span class="line">mov    %r8d,<span class="number">0xc</span>(%r10) ; Store</span><br><span class="line">lock addl $<span class="number">0x0</span>,(%rsp) ; StoreLoad Barrier  <span class="comment">//注意最后一步是内存屏障</span></span><br></pre></td></tr></table></figure>
<p>从Load到store到内存屏障，一共4步，其中最后一步jvm让这个最新的变量的值在所有线程可见，也就是最后一步让所有的CPU内核都获得了最新的值，但在执行内存屏障之前，中间的几步（从Load到Store）是不安全的。</p>
<p>内存屏障可以被分为以下几种类型：</p>
<p>LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</p>
<p>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</p>
<p>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</p>
<p>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。</p>
<p><strong>可见性原理</strong></p>
<p>为在虚拟机内存中有主内存和工作内存的概念，每个线程都有自己的工作内存，当读取一个普通变量时，优先读取工作内存的变量，如果工作内存中没有对应的变量，则从主内存中加载到工作内存，对工作内存的普通变量进行修改，不会立马同步到主内存。<strong>对volatile修饰的变量进行写操作时，直接把最新值写到主内存中，并清空其它cpu工作内存中该变量所在的内存行数据</strong>（Write-Barrier（写入屏障）将刷新所有在 Barrier 之前写入 cache 的数据），<strong>对volatile修饰的变量进行读操作时，会读取主内存的数据</strong>。内存可见性保证了在多线程的场景下，保证了线程A对变量的修改，其它线程可以读到最新值。</p>
<p><strong>有序性原理</strong></p>
<p>插入一条Memory Barrier会告诉编译器和CPU：不管什么指令都不能和这条Memory Barrier指令重排序</p>
<h4 id="缺陷-1"><a href="#缺陷-1" class="headerlink" title="缺陷"></a>缺陷</h4><p>volatile并不保证原子性，比如i++，因为两个线程可以同时在主存获取变量i的值，然后同时修改后，保存到主存，这个过程一点也不违背可见性（获取最新，修改后立马更新），比如i=0的时候，两个线程同时获取，然后同时修改后，i是等于1，而不是等于2</p>
<p>不要将volatile用在getAndOperate场合（这种场合不原子，需要再加锁），仅仅set或者get的场景是适合volatile的。</p>
<p>参考路径</p>
<p><a href="http://blog.csdn.net/sinat_35512245/article/details/60325685" target="_blank" rel="noopener">http://blog.csdn.net/sinat_35512245/article/details/60325685</a></p>
<h3 id="ThreadLocal介绍"><a href="#ThreadLocal介绍" class="headerlink" title="ThreadLocal介绍"></a>ThreadLocal介绍</h3><p>ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p>
<h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>每当线程去访问TreadLocal时，它都会从线程对应的TreadLocalMap（其实是一个Entry数组，索引是ThreadLocal对象的hash与运算，如果重复会nextIndex，再获取一个索引）中拿出与之对应的Entry，Entry的key是当前ThreadLocal对象，Entry的value就是当前线程下ThreadLocal的值</p>
<p><img src="java-thread/ThreadLocal.png" alt></p>
<p>ThreadLocalMap实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个ThreadLocalMap对象赋值给当前线程的成员变量threadLocals</span></span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">        <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">        table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        setThreshold(INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>ThreadLocal.set() 实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i]; e != <span class="keyword">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ThreadLocal.get() 实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="举例-5"><a href="#举例-5" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> SimpleDateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Date date = <span class="keyword">new</span> Date();</span><br><span class="line">                System.out.println(dateFormatThreadLocal.get().format(date));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Date date = <span class="keyword">new</span> Date();</span><br><span class="line">                <span class="comment">//dateFormatThreadLocal.set(new SimpleDateFormat("yyyy-MM-dd")); </span></span><br><span class="line">                System.out.println(dateFormatThreadLocal.get().format(date));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><h4 id="Servlet不是线程安全的"><a href="#Servlet不是线程安全的" class="headerlink" title="Servlet不是线程安全的"></a>Servlet不是线程安全的</h4><p>serlvet采用多线程来处理多个请求同时访问，Tomcat容器维护了一个线程池来服务请求，serlvet也只会初始化一次，当被请求访问到的时候初始化。当容器收到一个Servlet请求，Dispatcher线程从线程池中选出一个工作组线程，将请求传递给该线程，然后由该线程来执行Servlet的service方法。当这个线程正在执行的时候，容器收到另一个请求，调度者线程将从线程池中选出另外一个工作组线程来服务这个新的请求，容器并不关心这个请求是否访问的是同一个Servlet还是另一个Servlet。当容器收到对同一个Servlet的多个请求的时候，那这个servlet的service方法将在多线程中并发的执行。</p>
<h4 id="SimpleDateFormat线程不安全"><a href="#SimpleDateFormat线程不安全" class="headerlink" title="SimpleDateFormat线程不安全"></a>SimpleDateFormat线程不安全</h4><p>SimpleDateFormat里会保持一个Calendar变量，如果每个线程都操作这个变量，就会发生线程安全问题</p>
<p><a href="http://blog.csdn.net/zq602316498/article/details/40263083" target="_blank" rel="noopener">http://blog.csdn.net/zq602316498/article/details/40263083</a></p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。</p>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>当在某个线程创建一个新的线程，这个线程有与创建线程相同的优先级。<br><code>setPriority(int newPriority)</code></p>
<h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>当一个jvm启动，这里通常有一个非守护线程(运行main函数)，但是jvm只剩下守护线程，守护线程不会支持jvm继续运行。</p>
<p><code>setDaemon(boolean on)</code></p>
<h4 id="线程API"><a href="#线程API" class="headerlink" title="线程API"></a>线程API</h4><p><img src="java-thread/threadapi.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前线程可转让cpu控制权，让优先级更高的线程运行(有可能还是自己)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Thread.yield()</span><br><span class="line"><span class="comment">//线程暂停一段时间，但在等待的时候仍然会持有monitor或者锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Thread.sleep()</span><br><span class="line"><span class="comment">//在一个线程中调用other.join(),将等待other执行完后才继续本线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">join</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//判断是否有中断信息，同时也会对中断状态进行复位</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>interrupt方法通过修改了被调用线程的中断状态来告知那个线程, 说它被中断了. 对于非阻塞中的线程, 只是改变了中断状态, 即Thread.isInterrupted()将返回true; 对于可取消的阻塞状态中的线程, 比如等待在这些函数上的线程, Thread.sleep(), Object.wait(), Thread.join(), 这个线程收到中断信号后, 会抛出InterruptedException，提前结束阻塞状态，但是run方法不会中断，需要自己实现中断方法执行。不是所有的阻塞方法收到中断后都可以取消阻塞状态, 输入和输出流类会阻塞等待 I/O 完成，但是它们不抛出 InterruptedException，而且在被中断的情况下也不会退出阻塞状态. 同时会把中断状态置回为true.但调用Thread.interrupted()会对中断状态进行复位。只有方法上有InterruptedException，才能进行中断，比如使用synchronized时线程获取锁而受阻，就无法中断，但是因为lock的lock方法上有这个异常，所以lock锁的阻塞可以中断。</p>
</blockquote>
<p><a href="http://blog.csdn.net/canot/article/details/51087772" target="_blank" rel="noopener">http://blog.csdn.net/canot/article/details/51087772</a></p>
<h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><p><img src="java-thread/ThreadLife.png" alt></p>
<ul>
<li><strong>NEW</strong> ：还未开始的线程</li>
<li><strong>RUNNABLE</strong> ：正在被jvm执行，但可能正在等待CPU调度</li>
<li><strong>BLOCKED</strong> ： 等待获取锁以进入同步方法/代码块</li>
<li><strong>WAITING</strong> ： 线程在这个状态下等待其他线程执行特定操作。通常为当执行以下操作后<br><code>Object.wait</code>,<br><code>Thread.join</code>,<br><code>LockSupport.park</code></li>
<li><strong>TIMED_WAITING</strong> ：当线程开始等待一段时间。通常为当执行以下操作后<br><code>Thread.sleep(long)</code>,<br><code>Object.wait(long)</code>,<br><code>Thread.join(long)</code>,<br><code>LockSupport.parkNanos</code>,<br><code>LockSupport.parkUntil</code></li>
<li><strong>TERMINATED</strong> ：线程已结束</li>
</ul>
<h4 id="操作系统的线程状态"><a href="#操作系统的线程状态" class="headerlink" title="操作系统的线程状态"></a>操作系统的线程状态</h4><ul>
<li>就绪</li>
<li>运行</li>
<li>阻塞</li>
</ul>
<h4 id="线程阻塞"><a href="#线程阻塞" class="headerlink" title="线程阻塞"></a>线程阻塞</h4><p>java线程到阻塞状态，需要从用户态转换到核心态，所以会耗费很多处理器时间，要尽量减少阻塞状态的频繁切换</p>
<h4 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h4><ul>
<li>线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务</li>
<li>进程是资源分配的最小单位，线程是程序执行的最小单位</li>
<li>一个进程是一个独立的运行环境，它可以被看作一个程序或者一个应用</li>
<li>一个进程下的所有线程共用一片内存，但是它们有各自的栈内存</li>
</ul>
<h4 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h4><ul>
<li>继承Thread，覆盖run()方法，创建线程对象并用start()方法启动线程</li>
<li>实现Runnable接口来创建Thread线程</li>
<li>通过实现Callable接口来创建Thread线程</li>
<li>借助框架程序 可用Executor框架来创建线程池，线程池可以限制线程的数量并且可以回收再利用这些线程</li>
</ul>
<h4 id="start-和-run-方法区别"><a href="#start-和-run-方法区别" class="headerlink" title="start() 和 run() 方法区别"></a>start() 和 run() 方法区别</h4><p>start()方法被用来启动新创建的线程，使该被创建的线程状态变为可运行状态。<br>当你调用run()方法的时候，没有新的线程启动，只会是在原来的线程中调用，这个方法同普通类的run方法一样。</p>
<h3 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待 / 通知机制"></a>等待 / 通知机制</h3><p><strong>wait()</strong>：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁； </p>
<p><strong>sleep()</strong>：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常； </p>
<p><strong>notify()</strong>：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；notify之后，需要把自身的同步代码块执行完毕后才会让出锁。</p>
<p><strong>notityAll()</strong>：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；</p>
<p><strong>join()</strong>：当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到执行join的线程运行结束，当前线程再由阻塞状态变为就绪状态。</p>
<p><strong>join(long millis)</strong>：millis的时间过后，当前线程转入阻塞状态，直到执行join的线程运行结束</p>
<h4 id="举例-6"><a href="#举例-6" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by j_zhan on 2016/7/6.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotify</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread A = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Wait(), <span class="string">"wait thread"</span>);</span><br><span class="line">        A.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        Thread B = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Notify(), <span class="string">"notify thread"</span>);</span><br><span class="line">        B.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Wait</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread() + <span class="string">" flag is true"</span>);</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">" flag is false"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Notify</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">7</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其相关方法定义在java.lang.Object上，线程A在获取锁后调用了对象lock的wait方法进入了等待状态，线程B调用对象lock的notifyAll()方法，线程A收到通知后从wait方法处返回继续执行，线程B对共享变量flag的修改对线程A来说是可见的。</p>
<p><strong>Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?</strong><br>sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，<strong>但是对象的锁依然保持</strong>，因此休眠时间结束后会自动恢复。wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果<strong>线程重新获得对象的锁就可以进入就绪状态</strong></p>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ol>
<li>使用wait()、notify()和notifyAll()时需要先对调用对象加锁，调用wait()方法后会释放锁。</li>
<li>调用wait()方法之后，线程状态由RUNNING变为WAITING，并将当前线程放置到对象的等待队列中。</li>
<li>notify()或notifyAll()方法调用后，等待线程不会立刻从wait()中返回，需要等该线程释放锁之后，才有机会获取锁之后从wait()返回。</li>
<li>notify()方法将等待队列中的一个等待线程从等待队列中移动到同步队列中；notifyAll()方法则是把等待队列中的所有线程都移动到同步队列中；被移动的线程状态从WAITING变为BLOCKED。</li>
<li>该线程从wait()方法返回的前提是获得了调用对象的锁。</li>
</ol>
<h3 id="Runnable介绍"><a href="#Runnable介绍" class="headerlink" title="Runnable介绍"></a>Runnable介绍</h3><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()).start();</span><br></pre></td></tr></table></figure>
<h3 id="Callable介绍"><a href="#Callable介绍" class="headerlink" title="Callable介绍"></a>Callable介绍</h3><h4 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;()),<span class="string">"线程名"</span>).start();</span><br></pre></td></tr></table></figure>
<h4 id="Callable和Runnable的区别"><a href="#Callable和Runnable的区别" class="headerlink" title="Callable和Runnable的区别"></a>Callable和Runnable的区别</h4><ol>
<li>Callable 的 call() 方法可以返回值和抛出异常，而 Runnable 的 run() 方法没有这些功能。</li>
<li>Callable 可以使用ExecutorService</li>
</ol>
<h3 id="Future介绍"><a href="#Future介绍" class="headerlink" title="Future介绍"></a>Future介绍</h3><p>Future是一个接口，定义了Future对于具体的Runnable或者Callable任务的执行结果进行取消、查询任务是否被取消，查询是否完成、获取结果。</p>
<h4 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//试图取消对此任务的执行。如果任务已完成、或已取消，或者由于某些其他原因而无法取消，则此尝试将失败。当调用 cancel() 时，如果调用成功，而此任务尚未启动，则此任务将永不运行。如果任务已经启动，则 mayInterruptIfRunning 参数确定是否应该以试图停止任务的方式来中断执行此任务的线程。此方法返回后，对 isDone() 的后续调用将始终返回 true。如果此方法返回 true，则对 isCancelled() 的后续调用将始终返回 true。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果在任务正常完成前将其取消，则返回 true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果任务已完成，则返回 true。 可能由于正常终止、异常或取消而完成，在所有这些情况中，此方法都将返回 true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如有必要，等待计算完成，然后获取其结果。如果运算尚未完成get方法将会阻塞</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如有必要，最多等待为使计算完成所给定的时间之后，获取其结果（如果结果可用）</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="举例-7"><a href="#举例-7" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"做一些耗时的任务..."</span>);</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureSimpleDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        Future&lt;String&gt; future = executorService.submit(<span class="keyword">new</span> MyCallable());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"dosomething..."</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"得到异步任务返回结果："</span> + future.get());</span><br><span class="line">        System.out.println(<span class="string">"Completed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="FutureTask介绍"><a href="#FutureTask介绍" class="headerlink" title="FutureTask介绍"></a>FutureTask介绍</h3><p>FutureTask的父类是RunnableFuture，而RunnableFuture继承了Runnbale和Futrue这两个接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.callable = callable;</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>FutureTask最终都是执行Callable类型的任务。</li>
<li>如果构造函数参数是Runnable，会被Executors.callable方法转换为Callable类型。</li>
</ol>
<h4 id="举例-8"><a href="#举例-8" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableAndFuture</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Callable&lt;Integer&gt; callable = <span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        FutureTask&lt;Integer&gt; future = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(callable);</span><br><span class="line">        <span class="keyword">new</span> Thread(future).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);<span class="comment">// 可能做一些事情</span></span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程</p>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。</li>
</ol>
<h4 id="线程池接口图"><a href="#线程池接口图" class="headerlink" title="线程池接口图"></a>线程池接口图</h4><p><img src="java-thread/Executor.png" alt></p>
<h4 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h4><p>普通类 Executors 里面调用的就是 ThreadPoolExecutor。</p>
<p>Executors提供了一系列工厂方法用于创先线程池，返回的线程池都实现了ExecutorService接口。ScheduleExecutorService代表可在指定延迟后或周期性地执行线程任务的线程池。</p>
<h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p><img src="java-thread/ThreadPool.png" alt></p>
<h5 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         threadFactory, defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>corePoolSize</strong>：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。<br><strong>maximumPoolSize</strong>：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。<br><strong>keepAliveTime</strong>： 线程池维护线程所允许的空闲时间<br><strong>unit</strong>： 线程池维护线程所允许的空闲时间的单位<br><strong>workQueue</strong>： 线程池所使用的缓冲队列<br><strong>threadFactory</strong>：线程工厂，它是一个接口，用来为线程池创建新线程的<br><strong>handler</strong>： 超出线程池容量以及队列长度后拒绝任务的策略</p>
</blockquote>
<p>针对handler，线程池提供了4种策略：<br>1、AbortPolicy：直接抛出异常，默认策略；<br>2、CallerRunsPolicy：用调用者所在的线程来执行任务；<br>3、DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；<br>4、DiscardPolicy：直接丢弃任务；</p>
<h4 id="corePoolSize-和-maximumPoolSize"><a href="#corePoolSize-和-maximumPoolSize" class="headerlink" title="corePoolSize 和 maximumPoolSize"></a>corePoolSize 和 maximumPoolSize</h4><p><img src="java-thread/corePoolSize.png" alt></p>
<h5 id="具体说明-2"><a href="#具体说明-2" class="headerlink" title="具体说明"></a>具体说明</h5><p>提交任务，线程池中的线程数可以增长至corePoolSize，之后继续提交任务将暂存至队列中，如果队列满，则看是否能继续增长线程数至maximumPoolSize，超出后将进行拒绝策略处理。如果采用无界队列，那么maximumPoolSize将失效，线程池中的线程最多就是corePoolSize个线程工作</p>
<h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><h5 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h5><p>一个基于数组实现的有界阻塞队列。ArrayBlockingQueue在生产者放入和消费者获取数据时共用一个锁对象，所以说对一个queue而言并没有做到真正的并行</p>
<h5 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h5><p>SynchronousQueue无数据缓冲区，相当于生产者和消费者直接交换数据而不通过任何中介。SynchronousQueue中每一个put操作必须等待一个take操作，否则不能继续添加元素。如果没有空闲线程，就构造一个新的线程加入线程池，如果线程池里没有空闲线程，则不会进行任务，newCachedThreadPool采用的便是这种策略</p>
<h5 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h5><p>一个基于链表实现的有界阻塞队列。不同于ArrayBlockingQueue，其对生产者和消费者端分别采用了独立的锁来控制数据同步，因此提高了队列的并发性能。需要注意的是此队列的默认长度是Integer,MAX_VALUE，即无限大小，当生产者速度过快时，系统内存有被耗尽的风险，newFixedThreadPool采用的便是这种策略</p>
<h5 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h5><p>元素是按照顺序储存的，一个具有优先级的无限阻塞队列</p>
<h5 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h5><p>队列中的每个元素实现了Delayed接口，只有当指定的延迟时间到了，才能够从队列中获取该元素。DelayQueue可以用于保存将要执行的任务和执行时间，newScheduledThreadPool采用的便是这种策略，也是无界</p>
<h4 id="Executors-提供四种线程池"><a href="#Executors-提供四种线程池" class="headerlink" title="Executors 提供四种线程池"></a>Executors 提供四种线程池</h4><h5 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h5><p>一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。<strong>对于执行很多短期异步任务的程序而言，这个线程池通常可提高程序性能。</strong>调用 execute() 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。如果是长期异步任务，就不要用这种，因为每当创建新线程执行任务，会导致一定的系统开销，<strong>所以，使用该线程池时，一定要注意控制并发的任务数，否则创建大量的线程可能导致严重的性能问题。</strong>线程池的线程数可达到Integer.MAX_VALUE，即2147483647</p>
<h5 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h5><p>一个单线程池，也就是该线程池只有一个线程在工作，所有的任务是串行执行的，如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它，此线程池保证所有任务的执行顺序按照任务的提交顺序执行</p>
<h5 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h5><p>创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小，线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程</p>
<h5 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h5><p>初始化的线程池可以在指定的时间内周期性的执行所提交的任务，在实际的业务场景中可以使用该线程池定期的同步数据。</p>
<h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService0 = Executors.newCachedThreadPool();</span><br><span class="line">ExecutorService executorService1 = Executors.newSingleThreadExecutor();  </span><br><span class="line">ExecutorService executorService2 = Executors.newFixedThreadPool(<span class="number">10</span>);  </span><br><span class="line">ExecutorService executorService3 = Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h4 id="ExecutorService方法"><a href="#ExecutorService方法" class="headerlink" title="ExecutorService方法"></a>ExecutorService方法</h4><ol>
<li>execute(Runnable)  </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">executorService.execute(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Asynchronous task"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>submit(Runnable)  </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Future future = executorService.submit(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Asynchronous task"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>submit(Callable) </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Future future = executorService.submit(<span class="keyword">new</span> Callable()&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Asynchronous Callable"</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Callable Result"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>submit(new FutureTask<integer>(Callable))</integer></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">submit(<span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Callable()&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Asynchronous Callable"</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Callable Result"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<ol start="5">
<li><p>invokeAny(…)  </p>
<p>方法 invokeAny() 接收一个包含 Callable 对象的集合作为参数。调用该方法不会返回 Future 对象，而是返回集合中某一个 Callable 对象的结果，而且无法保证调用之后返回的结果是哪一个 Callable，只知道它是这些 Callable 中一个执行结束的 Callable 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newSingleThreadExecutor();  </span><br><span class="line"></span><br><span class="line">Set&lt;Callable&lt;String&gt;&gt; callables = <span class="keyword">new</span> HashSet&lt;Callable&lt;String&gt;&gt;();  </span><br><span class="line"></span><br><span class="line">callables.add(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Task 1"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);  </span><br><span class="line">callables.add(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Task 2"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);  </span><br><span class="line">callables.add(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Task 3"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line">String result = executorService.invokeAny(callables);  </span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"result = "</span> + result);  </span><br><span class="line"></span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure>
</li>
<li><p>invokeAll(…)</p>
<p>方法 invokeAll() 会调用存在于参数集合中的所有 Callable 对象，并且返回一个包含 Future 对象的集合，你可以通过这个返回的集合来管理每个 Callable 的执行结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个线程数固定大小为10的线程池</span></span><br><span class="line">ExecutorService executorService = Executors.newFixedThreadPool( <span class="number">10</span> ) ;</span><br><span class="line">List&lt;Callable&lt;String&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;() ;</span><br><span class="line"><span class="comment">//创建第一个 Callable</span></span><br><span class="line">Callable&lt;String&gt; callable1 = <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.d( <span class="string">"callable 1 线程是： "</span>+ Thread.currentThread().getName()  );</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"执行完了 callable 1"</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//创建第二个 Callable</span></span><br><span class="line">Callable&lt;String&gt; callable2 = <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.d( <span class="string">"callable 2 线程是： "</span>+ Thread.currentThread().getName()  );</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"执行完了 callable 2"</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">list.add(callable1 ) ;</span><br><span class="line">list.add(callable2 ) ;</span><br><span class="line">List&lt;Future&lt;String&gt;&gt; result;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    result = executorService.invokeAll( list );</span><br><span class="line">    <span class="keyword">for</span> (Future&lt;String&gt; future : result) &#123;</span><br><span class="line">        Log.d( <span class="string">"结果是： "</span>+ future.get()  );</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭线程池</span></span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure>
</li>
<li><p>shutdown()</p>
<p>不会立即的终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务</p>
</li>
<li><p>shutdownNow() </p>
<p>立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务</p>
</li>
</ol>
<h4 id="ForkJoinPool介绍"><a href="#ForkJoinPool介绍" class="headerlink" title="ForkJoinPool介绍"></a>ForkJoinPool介绍</h4><p>ForkJoinPool同ThreadPoolExecutor一样，也实现了Executor和ExecutorService接口。它使用了一个无限队列来保存需要执行的任务，而线程的数量则是通过构造函数传入，如果没有向构造函数中传入希望的线程数量，那么当前计算机可用的CPU数量会被设置为线程数量作为默认值。</p>
<p>ForkJoinPool的另外一个特性是它能够实现工作窃取(Work Stealing)，在该线程池的每个线程中会维护一个队列来存放需要被执行的任务。当线程自身队列中的任务都执行完毕后，它会从别的线程中拿到未被执行的任务并帮助它执行。</p>
<p>可以把一个任务拆分成多个小任务，然后再把多个小任务合成总的计算结果</p>
<ul>
<li>分解（Fork）操作：当需要将一个任务拆分成更小的多个任务时，在框架中执行这些任务</li>
<li>合并（Join）操作：当一个主任务等待其创建的多个子任务的完成执行</li>
<li>ForkJoinPool类的execute(ForkJoinTask<t> task)方法是异步调用的</t></li>
<li>ForkJoinPool类的invoke(ForkJoinTask<t> task)方法则是同步调用的</t></li>
</ul>
<p><img src="java-thread/ForkJoinPool.png" alt></p>
<h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><table>
<thead>
<tr>
<th>区别</th>
<th>Executor</th>
<th>ForkJoinPool</th>
</tr>
</thead>
<tbody>
<tr>
<td>接受的对象</td>
<td>Runnable和Callable的实例</td>
<td>Runnable、Callable和ForkJoinTask的实例</td>
</tr>
<tr>
<td>调度模式</td>
<td>处于后面等待中的任务需要等待前面任务执行后才有机会被执行，是否被执行取决于具体的调度规则</td>
<td>采用work-stealing模式帮助其他线程执行任务，即ExcuteService解决的是并发问题，而ForkJoinPool解决的是并行问题。</td>
</tr>
</tbody>
</table>
<h5 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h5><p>ForkJoinTask继承与Future接口，代表一个可以并行、合并的任务.</p>
<p>它有两个抽象子类：RecursiveAction和RecursiveTask。</p>
<ul>
<li>RecursiveTask代表有返回值的任务</li>
<li>RecursiveAction代表没有返回值的任务</li>
</ul>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"># java</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/03/26/java-collection/" rel="next" title="Java集合深入详解">
                <i class="fa fa-chevron-left"></i> Java集合深入详解
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/04/04/mybatis-review/" rel="prev" title="Mybatis基础回顾">
                Mybatis基础回顾 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">frank</p>
              <div class="site-description motion-element" itemprop="description">总有一天你是我的</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">29</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">18</span>
                    <span class="site-state-item-name">分类</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">27</span>
                    <span class="site-state-item-name">标签</span>
                  
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#锁类型"><span class="nav-number">1.</span> <span class="nav-text">锁类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#锁状态"><span class="nav-number">1.0.1.</span> <span class="nav-text">锁状态</span></a></li></ol></li></ol><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS介绍"><span class="nav-number">2.</span> <span class="nav-text">CAS介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#具体说明"><span class="nav-number">2.1.</span> <span class="nav-text">具体说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#举例"><span class="nav-number">2.2.</span> <span class="nav-text">举例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺陷"><span class="nav-number">2.3.</span> <span class="nav-text">缺陷</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#备注"><span class="nav-number">2.4.</span> <span class="nav-text">备注</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS介绍"><span class="nav-number">3.</span> <span class="nav-text">AQS介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#原理"><span class="nav-number">3.1.</span> <span class="nav-text">原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized介绍"><span class="nav-number">4.</span> <span class="nav-text">synchronized介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#举例-1"><span class="nav-number">4.1.</span> <span class="nav-text">举例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁"><span class="nav-number">4.2.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#效率低"><span class="nav-number">4.3.</span> <span class="nav-text">效率低</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#备注-1"><span class="nav-number">4.4.</span> <span class="nav-text">备注</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lock介绍"><span class="nav-number">5.</span> <span class="nav-text">Lock介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#举例-2"><span class="nav-number">5.1.</span> <span class="nav-text">举例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantLock介绍"><span class="nav-number">6.</span> <span class="nav-text">ReentrantLock介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#可重入锁"><span class="nav-number">6.1.</span> <span class="nav-text">可重入锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法"><span class="nav-number">6.2.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#举例-3"><span class="nav-number">6.3.</span> <span class="nav-text">举例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#和synchronized区别"><span class="nav-number">6.4.</span> <span class="nav-text">和synchronized区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Condition介绍"><span class="nav-number">7.</span> <span class="nav-text">Condition介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#举例-4"><span class="nav-number">7.1.</span> <span class="nav-text">举例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常用方法"><span class="nav-number">7.2.</span> <span class="nav-text">常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#生产者消费者"><span class="nav-number">7.3.</span> <span class="nav-text">生产者消费者</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile介绍"><span class="nav-number">8.</span> <span class="nav-text">volatile介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#具体说明-1"><span class="nav-number">8.1.</span> <span class="nav-text">具体说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原理-1"><span class="nav-number">8.2.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺陷-1"><span class="nav-number">8.3.</span> <span class="nav-text">缺陷</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal介绍"><span class="nav-number">9.</span> <span class="nav-text">ThreadLocal介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#原理-2"><span class="nav-number">9.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#举例-5"><span class="nav-number">9.2.</span> <span class="nav-text">举例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程安全问题"><span class="nav-number">10.</span> <span class="nav-text">线程安全问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Servlet不是线程安全的"><span class="nav-number">10.1.</span> <span class="nav-text">Servlet不是线程安全的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SimpleDateFormat线程不安全"><span class="nav-number">10.2.</span> <span class="nav-text">SimpleDateFormat线程不安全</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程"><span class="nav-number">11.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#优先级"><span class="nav-number">11.1.</span> <span class="nav-text">优先级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#守护线程"><span class="nav-number">11.2.</span> <span class="nav-text">守护线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程API"><span class="nav-number">11.3.</span> <span class="nav-text">线程API</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程中断"><span class="nav-number">12.</span> <span class="nav-text">线程中断</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程状态"><span class="nav-number">12.1.</span> <span class="nav-text">线程状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#操作系统的线程状态"><span class="nav-number">12.2.</span> <span class="nav-text">操作系统的线程状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程阻塞"><span class="nav-number">12.3.</span> <span class="nav-text">线程阻塞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程与进程的区别"><span class="nav-number">12.4.</span> <span class="nav-text">线程与进程的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建线程"><span class="nav-number">12.5.</span> <span class="nav-text">创建线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#start-和-run-方法区别"><span class="nav-number">12.6.</span> <span class="nav-text">start() 和 run() 方法区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#等待-通知机制"><span class="nav-number">13.</span> <span class="nav-text">等待 / 通知机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#举例-6"><span class="nav-number">13.1.</span> <span class="nav-text">举例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注意点"><span class="nav-number">13.2.</span> <span class="nav-text">注意点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Runnable介绍"><span class="nav-number">14.</span> <span class="nav-text">Runnable介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#源码分析"><span class="nav-number">14.1.</span> <span class="nav-text">源码分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用方法"><span class="nav-number">14.2.</span> <span class="nav-text">使用方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Callable介绍"><span class="nav-number">15.</span> <span class="nav-text">Callable介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#源码分析-1"><span class="nav-number">15.1.</span> <span class="nav-text">源码分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用方法-1"><span class="nav-number">15.2.</span> <span class="nav-text">使用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Callable和Runnable的区别"><span class="nav-number">15.3.</span> <span class="nav-text">Callable和Runnable的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Future介绍"><span class="nav-number">16.</span> <span class="nav-text">Future介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#源码分析-2"><span class="nav-number">16.1.</span> <span class="nav-text">源码分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#举例-7"><span class="nav-number">16.2.</span> <span class="nav-text">举例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FutureTask介绍"><span class="nav-number">17.</span> <span class="nav-text">FutureTask介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造方法"><span class="nav-number">17.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#举例-8"><span class="nav-number">17.2.</span> <span class="nav-text">举例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池"><span class="nav-number">18.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#优势"><span class="nav-number">18.1.</span> <span class="nav-text">优势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程池接口图"><span class="nav-number">18.2.</span> <span class="nav-text">线程池接口图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Executors"><span class="nav-number">18.3.</span> <span class="nav-text">Executors</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadPoolExecutor"><span class="nav-number">18.4.</span> <span class="nav-text">ThreadPoolExecutor</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#构造方法-1"><span class="nav-number">18.4.1.</span> <span class="nav-text">构造方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#corePoolSize-和-maximumPoolSize"><span class="nav-number">18.5.</span> <span class="nav-text">corePoolSize 和 maximumPoolSize</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#具体说明-2"><span class="nav-number">18.5.1.</span> <span class="nav-text">具体说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BlockingQueue"><span class="nav-number">18.6.</span> <span class="nav-text">BlockingQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ArrayBlockingQueue"><span class="nav-number">18.6.1.</span> <span class="nav-text">ArrayBlockingQueue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SynchronousQueue"><span class="nav-number">18.6.2.</span> <span class="nav-text">SynchronousQueue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LinkedBlockingQueue"><span class="nav-number">18.6.3.</span> <span class="nav-text">LinkedBlockingQueue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#PriorityBlockingQueue"><span class="nav-number">18.6.4.</span> <span class="nav-text">PriorityBlockingQueue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DelayQueue"><span class="nav-number">18.6.5.</span> <span class="nav-text">DelayQueue</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Executors-提供四种线程池"><span class="nav-number">18.7.</span> <span class="nav-text">Executors 提供四种线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#newCachedThreadPool"><span class="nav-number">18.7.1.</span> <span class="nav-text">newCachedThreadPool</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#newSingleThreadExecutor"><span class="nav-number">18.7.2.</span> <span class="nav-text">newSingleThreadExecutor</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#newFixedThreadPool"><span class="nav-number">18.7.3.</span> <span class="nav-text">newFixedThreadPool</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#newScheduledThreadPool"><span class="nav-number">18.7.4.</span> <span class="nav-text">newScheduledThreadPool</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现方式"><span class="nav-number">18.8.</span> <span class="nav-text">实现方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ExecutorService方法"><span class="nav-number">18.9.</span> <span class="nav-text">ExecutorService方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ForkJoinPool介绍"><span class="nav-number">18.10.</span> <span class="nav-text">ForkJoinPool介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#区别"><span class="nav-number">18.10.1.</span> <span class="nav-text">区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ForkJoinTask"><span class="nav-number">18.10.2.</span> <span class="nav-text">ForkJoinTask</span></a></li></ol></li></ol></li></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">frank</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.1.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.1"></script>

  <script src="/js/motion.js?v=7.1.1"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.1"></script>



  
  <script src="/js/scrollspy.js?v=7.1.1"></script>
<script src="/js/post-details.js?v=7.1.1"></script>



  


  <script src="/js/next-boot.js?v=7.1.1"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
